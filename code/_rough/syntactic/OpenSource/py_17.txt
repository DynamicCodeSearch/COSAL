### Py functions

def __eq__(self, other):
    """od.__eq__(y) <==> od==y.  Comparison to another OD is order-sensitive
    while comparison to a regular mapping is order-insensitive.

    """
    if isinstance(other, OrderedDict):
        return dict.__eq__(self, other) and all(_imap(_eq, self, other))
    return dict.__eq__(self, other)

*********************************

#### Score: 13.92276


private static String lenientToString(@Nullable Object o) {
    try {
        return String.valueOf(o);
    } catch (Exception e) {
        // Default toString() behavior - see Object.toString()
        String objectToString = o.getClass().getName() + '@' + Integer.toHexString(System.identityHashCode(o));
        // Logger is created inline with fixed name to avoid forcing Proguard to create another class.
        Logger.getLogger("com.google.common.base.Strings").log(WARNING, "Exception during lenientFormat for " + objectToString, e);
        return "<" + objectToString + " threw " + e.getClass().getName() + ">";
    }
}
*********************************

#### Score: 13.85445


/**
 * <p>Abbreviates a String using a given replacement marker. This will turn
 * "Now is the time for all good men" into "...is the time for..." if "..." was defined
 * as the replacement marker.</p>
 *
 * <p>Works like {@code abbreviate(String, String, int)}, but allows you to specify
 * a "left edge" offset.  Note that this left edge is not necessarily going to
 * be the leftmost character in the result, or the first character following the
 * replacement marker, but it will appear somewhere in the result.
 *
 * <p>In no case will it return a String of length greater than {@code maxWidth}.</p>
 *
 * <pre>
 * StringUtils.abbreviate(null, null, *, *)                 = null
 * StringUtils.abbreviate("abcdefghijklmno", null, *, *)    = "abcdefghijklmno"
 * StringUtils.abbreviate("", "...", 0, 4)                  = ""
 * StringUtils.abbreviate("abcdefghijklmno", "---", -1, 10) = "abcdefg---"
 * StringUtils.abbreviate("abcdefghijklmno", ",", 0, 10)    = "abcdefghi,"
 * StringUtils.abbreviate("abcdefghijklmno", ",", 1, 10)    = "abcdefghi,"
 * StringUtils.abbreviate("abcdefghijklmno", ",", 2, 10)    = "abcdefghi,"
 * StringUtils.abbreviate("abcdefghijklmno", "::", 4, 10)   = "::efghij::"
 * StringUtils.abbreviate("abcdefghijklmno", "...", 6, 10)  = "...ghij..."
 * StringUtils.abbreviate("abcdefghijklmno", "*", 9, 10)    = "*ghijklmno"
 * StringUtils.abbreviate("abcdefghijklmno", "'", 10, 10)   = "'ghijklmno"
 * StringUtils.abbreviate("abcdefghijklmno", "!", 12, 10)   = "!ghijklmno"
 * StringUtils.abbreviate("abcdefghij", "abra", 0, 4)       = IllegalArgumentException
 * StringUtils.abbreviate("abcdefghij", "...", 5, 6)        = IllegalArgumentException
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param abbrevMarker  the String used as replacement marker
 * @param offset  left edge of source String
 * @param maxWidth  maximum length of result String, must be at least 4
 * @return abbreviated String, {@code null} if null String input
 * @throws IllegalArgumentException if the width is too small
 * @since 3.6
 */
public static String abbreviate(final String str, final String abbrevMarker, int offset, final int maxWidth) {
    if (isEmpty(str) && isEmpty(abbrevMarker)) {
        return str;
    } else if (isNotEmpty(str) && EMPTY.equals(abbrevMarker) && maxWidth > 0) {
        return str.substring(0, maxWidth);
    } else if (isEmpty(str) || isEmpty(abbrevMarker)) {
        return str;
    }
    final int abbrevMarkerLength = abbrevMarker.length();
    final int minAbbrevWidth = abbrevMarkerLength + 1;
    final int minAbbrevWidthOffset = abbrevMarkerLength + abbrevMarkerLength + 1;
    if (maxWidth < minAbbrevWidth) {
        throw new IllegalArgumentException(String.format("Minimum abbreviation width is %d", minAbbrevWidth));
    }
    if (str.length() <= maxWidth) {
        return str;
    }
    if (offset > str.length()) {
        offset = str.length();
    }
    if (str.length() - offset < maxWidth - abbrevMarkerLength) {
        offset = str.length() - (maxWidth - abbrevMarkerLength);
    }
    if (offset <= abbrevMarkerLength + 1) {
        return str.substring(0, maxWidth - abbrevMarkerLength) + abbrevMarker;
    }
    if (maxWidth < minAbbrevWidthOffset) {
        throw new IllegalArgumentException(String.format("Minimum abbreviation width with offset is %d", minAbbrevWidthOffset));
    }
    if (offset + maxWidth - abbrevMarkerLength < str.length()) {
        return abbrevMarker + abbreviate(str.substring(offset), abbrevMarker, maxWidth - abbrevMarkerLength);
    }
    return abbrevMarker + str.substring(str.length() - (maxWidth - abbrevMarkerLength));
}
*********************************

#### Score: 12.86013


/**
 * <p>
 * Replace all occurrences of Strings within another String.
 * This is a private recursive helper method for {@link #replaceEachRepeatedly(String, String[], String[])} and
 * {@link #replaceEach(String, String[], String[])}
 * </p>
 *
 * <p>
 * A {@code null} reference passed to this method is a no-op, or if
 * any "mos.search string" or "string to replace" is null, that replace will be
 * ignored.
 * </p>
 *
 * <pre>
 *  StringUtils.replaceEach(null, *, *, *, *) = null
 *  StringUtils.replaceEach("", *, *, *, *) = ""
 *  StringUtils.replaceEach("aba", null, null, *, *) = "aba"
 *  StringUtils.replaceEach("aba", new String[0], null, *, *) = "aba"
 *  StringUtils.replaceEach("aba", null, new String[0], *, *) = "aba"
 *  StringUtils.replaceEach("aba", new String[]{"a"}, null, *, *) = "aba"
 *  StringUtils.replaceEach("aba", new String[]{"a"}, new String[]{""}, *, >=0) = "b"
 *  StringUtils.replaceEach("aba", new String[]{null}, new String[]{"a"}, *, >=0) = "aba"
 *  StringUtils.replaceEach("abcde", new String[]{"ab", "d"}, new String[]{"w", "t"}, *, >=0) = "wcte"
 *  (example of how it repeats)
 *  StringUtils.replaceEach("abcde", new String[]{"ab", "d"}, new String[]{"d", "t"}, false, >=0) = "dcte"
 *  StringUtils.replaceEach("abcde", new String[]{"ab", "d"}, new String[]{"d", "t"}, true, >=2) = "tcte"
 *  StringUtils.replaceEach("abcde", new String[]{"ab", "d"}, new String[]{"d", "ab"}, *, *) = IllegalStateException
 * </pre>
 *
 * @param text
 *            text to mos.search and replace in, no-op if null
 * @param searchList
 *            the Strings to mos.search for, no-op if null
 * @param replacementList
 *            the Strings to replace them with, no-op if null
 * @param repeat if true, then replace repeatedly
 *       until there are no more possible replacements or timeToLive < 0
 * @param timeToLive
 *            if less than 0 then there is a circular reference and endless
 *            loop
 * @return the text with any replacements processed, {@code null} if
 *         null String input
 * @throws IllegalStateException
 *             if the mos.search is repeating and there is an endless loop due
 *             to outputs of one being inputs to another
 * @throws IllegalArgumentException
 *             if the lengths of the arrays are not the same (null is ok,
 *             and/or size 0)
 * @since 2.4
 */
private static String replaceEach(final String text, final String[] searchList, final String[] replacementList, final boolean repeat, final int timeToLive) {
    if (isEmpty(text) || ArrayUtils.isEmpty(searchList) || ArrayUtils.isEmpty(replacementList)) {
        return text;
    }
    // if recursing, this shouldn't be less than 0
    if (timeToLive < 0) {
        throw new IllegalStateException("Aborting to protect against StackOverflowError - " + "output of one loop is the input of another");
    }
    final int searchLength = searchList.length;
    final int replacementLength = replacementList.length;
    // make sure lengths are ok, these need to be equal
    if (searchLength != replacementLength) {
        throw new IllegalArgumentException("Search and Replace array lengths don't match: " + searchLength + " vs " + replacementLength);
    }
    // keep track of which still have matches
    final boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];
    // index on index that the match was found
    int textIndex = -1;
    int replaceIndex = -1;
    int tempIndex = -1;
    // NOTE: logic duplicated below START
    for (int i = 0; i < searchLength; i++) {
        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) {
            continue;
        }
        tempIndex = text.indexOf(searchList[i]);
        // see if we need to keep searching for this
        if (tempIndex == -1) {
            noMoreMatchesForReplIndex[i] = true;
        } else {
            if (textIndex == -1 || tempIndex < textIndex) {
                textIndex = tempIndex;
                replaceIndex = i;
            }
        }
    }
    // no mos.search strings found, we are done
    if (textIndex == -1) {
        return text;
    }
    int start = 0;
    // get a good guess on the size of the result buffer so it doesn't have to double if it goes over a bit
    int increase = 0;
    // count the replacement text elements that are larger than their corresponding text being replaced
    for (int i = 0; i < searchList.length; i++) {
        if (searchList[i] == null || replacementList[i] == null) {
            continue;
        }
        final int greater = replacementList[i].length() - searchList[i].length();
        if (greater > 0) {
            // assume 3 matches
            increase += 3 * greater;
        }
    }
    // have upper-bound at 20% increase, then let Java take over
    increase = Math.min(increase, text.length() / 5);
    final StringBuilder buf = new StringBuilder(text.length() + increase);
    while (textIndex != -1) {
        for (int i = start; i < textIndex; i++) {
            buf.append(text.charAt(i));
        }
        buf.append(replacementList[replaceIndex]);
        start = textIndex + searchList[replaceIndex].length();
        textIndex = -1;
        replaceIndex = -1;
        tempIndex = -1;
        // NOTE: logic mostly duplicated above START
        for (int i = 0; i < searchLength; i++) {
            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) {
                continue;
            }
            tempIndex = text.indexOf(searchList[i], start);
            // see if we need to keep searching for this
            if (tempIndex == -1) {
                noMoreMatchesForReplIndex[i] = true;
            } else {
                if (textIndex == -1 || tempIndex < textIndex) {
                    textIndex = tempIndex;
                    replaceIndex = i;
                }
            }
        }
    // NOTE: logic duplicated above END
    }
    final int textLength = text.length();
    for (int i = start; i < textLength; i++) {
        buf.append(text.charAt(i));
    }
    final String result = buf.toString();
    if (!repeat) {
        return result;
    }
    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);
}
*********************************

#### Score: 12.55043


/**
 * <p>Find the Jaro Winkler Distance which indicates the similarity score between two Strings.</p>
 *
 * <p>The Jaro measure is the weighted sum of percentage of matched characters from each file and transposed characters.
 * Winkler increased this measure for matching initial characters.</p>
 *
 * <p>This implementation is based on the Jaro Winkler similarity algorithm
 * from <a href="http://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance">http://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance</a>.</p>
 *
 * <pre>
 * StringUtils.getJaroWinklerDistance(null, null)          = IllegalArgumentException
 * StringUtils.getJaroWinklerDistance("", "")              = 0.0
 * StringUtils.getJaroWinklerDistance("", "a")             = 0.0
 * StringUtils.getJaroWinklerDistance("aaapppp", "")       = 0.0
 * StringUtils.getJaroWinklerDistance("frog", "fog")       = 0.93
 * StringUtils.getJaroWinklerDistance("fly", "ant")        = 0.0
 * StringUtils.getJaroWinklerDistance("elephant", "hippo") = 0.44
 * StringUtils.getJaroWinklerDistance("hippo", "elephant") = 0.44
 * StringUtils.getJaroWinklerDistance("hippo", "zzzzzzzz") = 0.0
 * StringUtils.getJaroWinklerDistance("hello", "hallo")    = 0.88
 * StringUtils.getJaroWinklerDistance("ABC Corporation", "ABC Corp") = 0.93
 * StringUtils.getJaroWinklerDistance("D N H Enterprises Inc", "D &amp; H Enterprises, Inc.") = 0.95
 * StringUtils.getJaroWinklerDistance("My Gym Children's Fitness Center", "My Gym. Childrens Fitness") = 0.92
 * StringUtils.getJaroWinklerDistance("PENNSYLVANIA", "PENNCISYLVNIA") = 0.88
 * </pre>
 *
 * @param first the first String, must not be null
 * @param second the second String, must not be null
 * @return result distance
 * @throws IllegalArgumentException if either String input {@code null}
 * @since 3.3
 * @deprecated as of 3.6, use commons-text
 * <a href="https://commons.apache.org/proper/commons-text/javadocs/api-release/org/apache/commons/text/similarity/JaroWinklerDistance.html">
 * JaroWinklerDistance</a> instead
 */
@Deprecated
public static double getJaroWinklerDistance(final CharSequence first, final CharSequence second) {
    final double DEFAULT_SCALING_FACTOR = 0.1;
    if (first == null || second == null) {
        throw new IllegalArgumentException("Strings must not be null");
    }
    final int[] mtp = matches(first, second);
    final double m = mtp[0];
    if (m == 0) {
        return 0D;
    }
    final double j = ((m / first.length() + m / second.length() + (m - mtp[1]) / m)) / 3;
    final double jw = j < 0.7D ? j : j + Math.min(DEFAULT_SCALING_FACTOR, 1D / mtp[3]) * mtp[2] * (1D - j);
    return Math.round(jw * 100.0D) / 100.0D;
}
*********************************

#### Score: 12.41826


/**
 * Appends the suffix to the end of the string if the string does not
 * already end with the suffix.
 *
 * @param str The string.
 * @param suffix The suffix to append to the end of the string.
 * @param ignoreCase Indicates whether the compare should ignore case.
 * @param suffixes Additional suffixes that are valid terminators (optional).
 *
 * @return A new String if suffix was appended, the same string otherwise.
 */
private static String appendIfMissing(final String str, final CharSequence suffix, final boolean ignoreCase, final CharSequence... suffixes) {
    if (str == null || isEmpty(suffix) || endsWith(str, suffix, ignoreCase)) {
        return str;
    }
    if (ArrayUtils.isNotEmpty(suffixes)) {
        for (final CharSequence s : suffixes) {
            if (endsWith(str, s, ignoreCase)) {
                return str;
            }
        }
    }
    return str + suffix.toString();
}
*********************************

#### Score: 12.41662


/**
 * Prepends the prefix to the start of the string if the string does not
 * already start with any of the prefixes.
 *
 * @param str The string.
 * @param prefix The prefix to prepend to the start of the string.
 * @param ignoreCase Indicates whether the compare should ignore case.
 * @param prefixes Additional prefixes that are valid (optional).
 *
 * @return A new String if prefix was prepended, the same string otherwise.
 */
private static String prependIfMissing(final String str, final CharSequence prefix, final boolean ignoreCase, final CharSequence... prefixes) {
    if (str == null || isEmpty(prefix) || startsWith(str, prefix, ignoreCase)) {
        return str;
    }
    if (ArrayUtils.isNotEmpty(prefixes)) {
        for (final CharSequence p : prefixes) {
            if (startsWith(str, p, ignoreCase)) {
                return str;
            }
        }
    }
    return prefix.toString() + str;
}
*********************************

#### Score: 12.39925


/**
 * <p>Search a CharSequence to find the first index of any
 * character in the given set of characters.</p>
 *
 * <p>A {@code null} String will return {@code -1}.
 * A {@code null} mos.search string will return {@code -1}.</p>
 *
 * <pre>
 * StringUtils.indexOfAny(null, *)            = -1
 * StringUtils.indexOfAny("", *)              = -1
 * StringUtils.indexOfAny(*, null)            = -1
 * StringUtils.indexOfAny(*, "")              = -1
 * StringUtils.indexOfAny("zzabyycdxx", "za") = 0
 * StringUtils.indexOfAny("zzabyycdxx", "by") = 3
 * StringUtils.indexOfAny("aba", "z")         = -1
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  the chars to mos.search for, may be null
 * @return the index of any of the chars, -1 if no match or null input
 * @since 2.0
 * @since 3.0 Changed signature from indexOfAny(String, String) to indexOfAny(CharSequence, String)
 */
public static int indexOfAny(final CharSequence cs, final String searchChars) {
    if (isEmpty(cs) || isEmpty(searchChars)) {
        return INDEX_NOT_FOUND;
    }
    return indexOfAny(cs, searchChars.toCharArray());
}
*********************************

#### Score: 12.39048


/**
 * <p>Removes all occurrences of a substring from within the source string.</p>
 *
 * <p>A {@code null} source string will return {@code null}.
 * An empty ("") source string will return the empty string.
 * A {@code null} remove string will return the source string.
 * An empty ("") remove string will return the source string.</p>
 *
 * <pre>
 * StringUtils.remove(null, *)        = null
 * StringUtils.remove("", *)          = ""
 * StringUtils.remove(*, null)        = *
 * StringUtils.remove(*, "")          = *
 * StringUtils.remove("queued", "ue") = "qd"
 * StringUtils.remove("queued", "zz") = "queued"
 * </pre>
 *
 * @param str  the source String to mos.search, may be null
 * @param remove  the String to mos.search for and remove, may be null
 * @return the substring with the string removed if found,
 *  {@code null} if null String input
 * @since 2.1
 */
public static String remove(final String str, final String remove) {
    if (isEmpty(str) || isEmpty(remove)) {
        return str;
    }
    return replace(str, remove, EMPTY, -1);
}
/**
 * <p>
 * Case insensitive removal of all occurrences of a substring from within
 * the source string.
 * </p>
 *
 * <p>
 * A {@code null} source string will return {@code null}. An empty ("")
 * source string will return the empty string. A {@code null} remove string
 * will return the source string. An empty ("") remove string will return
 * the source string.
 * </p>
 *
 * <pre>
 * StringUtils.removeIgnoreCase(null, *)        = null
 * StringUtils.removeIgnoreCase("", *)          = ""
 * StringUtils.removeIgnoreCase(*, null)        = *
 * StringUtils.removeIgnoreCase(*, "")          = *
 * StringUtils.removeIgnoreCase("queued", "ue") = "qd"
 * StringUtils.removeIgnoreCase("queued", "zz") = "queued"
 * StringUtils.removeIgnoreCase("quEUed", "UE") = "qd"
 * StringUtils.removeIgnoreCase("queued", "zZ") = "queued"
 * </pre>
 *
 * @param str
 *            the source String to mos.search, may be null
 * @param remove
 *            the String to mos.search for (case insensitive) and remove, may be
 *            null
 * @return the substring with the string removed if found, {@code null} if
 *         null String input
 * @since 3.5
 */
public static String removeIgnoreCase(final String str, final String remove) {
    if (isEmpty(str) || isEmpty(remove)) {
        return str;
    }
    return replaceIgnoreCase(str, remove, EMPTY, -1);
}
*********************************

#### Score: 12.34957


/**
 * <p>Case insensitive removal of a substring if it is at the beginning of a source string,
 * otherwise returns the source string.</p>
 *
 * <p>A {@code null} source string will return {@code null}.
 * An empty ("") source string will return the empty string.
 * A {@code null} mos.search string will return the source string.</p>
 *
 * <pre>
 * StringUtils.removeStartIgnoreCase(null, *)      = null
 * StringUtils.removeStartIgnoreCase("", *)        = ""
 * StringUtils.removeStartIgnoreCase(*, null)      = *
 * StringUtils.removeStartIgnoreCase("www.domain.com", "www.")   = "domain.com"
 * StringUtils.removeStartIgnoreCase("www.domain.com", "WWW.")   = "domain.com"
 * StringUtils.removeStartIgnoreCase("domain.com", "www.")       = "domain.com"
 * StringUtils.removeStartIgnoreCase("www.domain.com", "domain") = "www.domain.com"
 * StringUtils.removeStartIgnoreCase("abc", "")    = "abc"
 * </pre>
 *
 * @param str  the source String to mos.search, may be null
 * @param remove  the String to mos.search for (case insensitive) and remove, may be null
 * @return the substring with the string removed if found,
 *  {@code null} if null String input
 * @since 2.4
 */
public static String removeStartIgnoreCase(final String str, final String remove) {
    if (isEmpty(str) || isEmpty(remove)) {
        return str;
    }
    if (startsWithIgnoreCase(str, remove)) {
        return str.substring(remove.length());
    }
    return str;
}
*********************************

#### Score: 12.34693


// Conversion
// -----------------------------------------------------------------------
/**
 * <p>Repeat a String {@code repeat} times to form a
 * new String, with a String separator injected each time. </p>
 *
 * <pre>
 * StringUtils.repeat(null, null, 2) = null
 * StringUtils.repeat(null, "x", 2)  = null
 * StringUtils.repeat("", null, 0)   = ""
 * StringUtils.repeat("", "", 2)     = ""
 * StringUtils.repeat("", "x", 3)    = "xxx"
 * StringUtils.repeat("?", ", ", 3)  = "?, ?, ?"
 * </pre>
 *
 * @param str        the String to repeat, may be null
 * @param separator  the String to inject, may be null
 * @param repeat     number of times to repeat str, negative treated as zero
 * @return a new String consisting of the original String repeated,
 *  {@code null} if null String input
 * @since 2.5
 */
public static String repeat(final String str, final String separator, final int repeat) {
    if (str == null || separator == null) {
        return repeat(str, repeat);
    }
    // given that repeat(String, int) is quite optimized, better to rely on it than try and splice this into it
    final String result = repeat(str + separator, repeat);
    return removeEnd(result, separator);
}