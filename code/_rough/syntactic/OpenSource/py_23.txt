### Py functions

def __init__(*args, **kwds):
    """Create a new, empty Counter object.  And if given, count elements
    from an input iterable.  Or, initialize the count from another mapping
    of elements to their counts.

    >>> c = Counter()                           # a new, empty counter
    >>> c = Counter('gallahad')                 # a new counter from an iterable
    >>> c = Counter({'a': 4, 'b': 2})           # a new counter from a mapping
    >>> c = Counter(a=4, b=2)                   # a new counter from keyword args

    """
    if not args:
        raise TypeError(
            "descriptor '__init__' of 'Counter' object needs an argument")
    self = args[0]
    args = args[1:]
    if len(args) > 1:
        raise TypeError('expected at most 1 arguments, got %d' % len(args))
    super(Counter, self).__init__()
    self.update(*args, **kwds)

*********************************

#### Score: 29.81414


/**
 * Returns a string consisting of a specific number of concatenated copies of an input string. For
 * example, {@code repeat("hey", 3)} returns the string {@code "heyheyhey"}.
 *
 * @param string any non-null string
 * @param count the number of times to repeat it; a nonnegative integer
 * @return a string containing {@code string} repeated {@code count} times (the empty string if
 *     {@code count} is zero)
 * @throws IllegalArgumentException if {@code count} is negative
 */
public static String repeat(String string, int count) {
    // eager for GWT.
    checkNotNull(string);
    if (count <= 1) {
        checkArgument(count >= 0, "invalid count: %s", count);
        return (count == 0) ? "" : string;
    }
    // IF YOU MODIFY THE CODE HERE, you must update StringsRepeatBenchmark
    final int len = string.length();
    final long longSize = (long) len * (long) count;
    final int size = (int) longSize;
    if (size != longSize) {
        throw new ArrayIndexOutOfBoundsException("Required array size too large: " + longSize);
    }
    final char[] array = new char[size];
    string.getChars(0, len, array, 0);
    int n;
    for (n = len; n < size - n; n <<= 1) {
        System.arraycopy(array, 0, array, n, n);
    }
    System.arraycopy(array, 0, array, n, size - n);
    return new String(array);
}
*********************************

#### Score: 28.50745


/**
 * <p>Find the Jaro Winkler Distance which indicates the similarity score between two Strings.</p>
 *
 * <p>The Jaro measure is the weighted sum of percentage of matched characters from each file and transposed characters.
 * Winkler increased this measure for matching initial characters.</p>
 *
 * <p>This implementation is based on the Jaro Winkler similarity algorithm
 * from <a href="http://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance">http://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance</a>.</p>
 *
 * <pre>
 * StringUtils.getJaroWinklerDistance(null, null)          = IllegalArgumentException
 * StringUtils.getJaroWinklerDistance("", "")              = 0.0
 * StringUtils.getJaroWinklerDistance("", "a")             = 0.0
 * StringUtils.getJaroWinklerDistance("aaapppp", "")       = 0.0
 * StringUtils.getJaroWinklerDistance("frog", "fog")       = 0.93
 * StringUtils.getJaroWinklerDistance("fly", "ant")        = 0.0
 * StringUtils.getJaroWinklerDistance("elephant", "hippo") = 0.44
 * StringUtils.getJaroWinklerDistance("hippo", "elephant") = 0.44
 * StringUtils.getJaroWinklerDistance("hippo", "zzzzzzzz") = 0.0
 * StringUtils.getJaroWinklerDistance("hello", "hallo")    = 0.88
 * StringUtils.getJaroWinklerDistance("ABC Corporation", "ABC Corp") = 0.93
 * StringUtils.getJaroWinklerDistance("D N H Enterprises Inc", "D &amp; H Enterprises, Inc.") = 0.95
 * StringUtils.getJaroWinklerDistance("My Gym Children's Fitness Center", "My Gym. Childrens Fitness") = 0.92
 * StringUtils.getJaroWinklerDistance("PENNSYLVANIA", "PENNCISYLVNIA") = 0.88
 * </pre>
 *
 * @param first the first String, must not be null
 * @param second the second String, must not be null
 * @return result distance
 * @throws IllegalArgumentException if either String input {@code null}
 * @since 3.3
 * @deprecated as of 3.6, use commons-text
 * <a href="https://commons.apache.org/proper/commons-text/javadocs/api-release/org/apache/commons/text/similarity/JaroWinklerDistance.html">
 * JaroWinklerDistance</a> instead
 */
@Deprecated
public static double getJaroWinklerDistance(final CharSequence first, final CharSequence second) {
    final double DEFAULT_SCALING_FACTOR = 0.1;
    if (first == null || second == null) {
        throw new IllegalArgumentException("Strings must not be null");
    }
    final int[] mtp = matches(first, second);
    final double m = mtp[0];
    if (m == 0) {
        return 0D;
    }
    final double j = ((m / first.length() + m / second.length() + (m - mtp[1]) / m)) / 3;
    final double jw = j < 0.7D ? j : j + Math.min(DEFAULT_SCALING_FACTOR, 1D / mtp[3]) * mtp[2] * (1D - j);
    return Math.round(jw * 100.0D) / 100.0D;
}
*********************************

#### Score: 27.99632


/**
 * <p>Truncates a String. This will turn
 * "Now is the time for all good men" into "is the time for all".</p>
 *
 * <p>Works like {@code truncate(String, int)}, but allows you to specify
 * a "left edge" offset.
 *
 * <p>Specifically:</p>
 * <ul>
 *   <li>If {@code str} is less than {@code maxWidth} characters
 *       long, return it.</li>
 *   <li>Else truncate it to {@code substring(str, offset, maxWidth)}.</li>
 *   <li>If {@code maxWidth} is less than {@code 0}, throw an
 *       {@code IllegalArgumentException}.</li>
 *   <li>If {@code offset} is less than {@code 0}, throw an
 *       {@code IllegalArgumentException}.</li>
 *   <li>In no case will it return a String of length greater than
 *       {@code maxWidth}.</li>
 * </ul>
 *
 * <pre>
 * StringUtils.truncate(null, 0, 0) = null
 * StringUtils.truncate(null, 2, 4) = null
 * StringUtils.truncate("", 0, 10) = ""
 * StringUtils.truncate("", 2, 10) = ""
 * StringUtils.truncate("abcdefghij", 0, 3) = "abc"
 * StringUtils.truncate("abcdefghij", 5, 6) = "fghij"
 * StringUtils.truncate("raspberry peach", 10, 15) = "peach"
 * StringUtils.truncate("abcdefghijklmno", 0, 10) = "abcdefghij"
 * StringUtils.truncate("abcdefghijklmno", -1, 10) = throws an IllegalArgumentException
 * StringUtils.truncate("abcdefghijklmno", Integer.MIN_VALUE, 10) = throws an IllegalArgumentException
 * StringUtils.truncate("abcdefghijklmno", Integer.MIN_VALUE, Integer.MAX_VALUE) = throws an IllegalArgumentException
 * StringUtils.truncate("abcdefghijklmno", 0, Integer.MAX_VALUE) = "abcdefghijklmno"
 * StringUtils.truncate("abcdefghijklmno", 1, 10) = "bcdefghijk"
 * StringUtils.truncate("abcdefghijklmno", 2, 10) = "cdefghijkl"
 * StringUtils.truncate("abcdefghijklmno", 3, 10) = "defghijklm"
 * StringUtils.truncate("abcdefghijklmno", 4, 10) = "efghijklmn"
 * StringUtils.truncate("abcdefghijklmno", 5, 10) = "fghijklmno"
 * StringUtils.truncate("abcdefghijklmno", 5, 5) = "fghij"
 * StringUtils.truncate("abcdefghijklmno", 5, 3) = "fgh"
 * StringUtils.truncate("abcdefghijklmno", 10, 3) = "klm"
 * StringUtils.truncate("abcdefghijklmno", 10, Integer.MAX_VALUE) = "klmno"
 * StringUtils.truncate("abcdefghijklmno", 13, 1) = "n"
 * StringUtils.truncate("abcdefghijklmno", 13, Integer.MAX_VALUE) = "no"
 * StringUtils.truncate("abcdefghijklmno", 14, 1) = "o"
 * StringUtils.truncate("abcdefghijklmno", 14, Integer.MAX_VALUE) = "o"
 * StringUtils.truncate("abcdefghijklmno", 15, 1) = ""
 * StringUtils.truncate("abcdefghijklmno", 15, Integer.MAX_VALUE) = ""
 * StringUtils.truncate("abcdefghijklmno", Integer.MAX_VALUE, Integer.MAX_VALUE) = ""
 * StringUtils.truncate("abcdefghij", 3, -1) = throws an IllegalArgumentException
 * StringUtils.truncate("abcdefghij", -2, 4) = throws an IllegalArgumentException
 * </pre>
 *
 * @param str  the String to truncate, may be null
 * @param offset  left edge of source String
 * @param maxWidth  maximum length of result String, must be positive
 * @return truncated String, {@code null} if null String input
 * @throws IllegalArgumentException If {@code offset} or {@code maxWidth} is less than {@code 0}
 * @since 3.5
 */
public static String truncate(final String str, final int offset, final int maxWidth) {
    if (offset < 0) {
        throw new IllegalArgumentException("offset cannot be negative");
    }
    if (maxWidth < 0) {
        throw new IllegalArgumentException("maxWith cannot be negative");
    }
    if (str == null) {
        return null;
    }
    if (offset > str.length()) {
        return EMPTY;
    }
    if (str.length() > maxWidth) {
        final int ix = offset + maxWidth > str.length() ? str.length() : offset + maxWidth;
        return str.substring(offset, ix);
    }
    return str.substring(offset);
}
*********************************

#### Score: 27.64568


/**
 * <p>Abbreviates a String using a given replacement marker. This will turn
 * "Now is the time for all good men" into "...is the time for..." if "..." was defined
 * as the replacement marker.</p>
 *
 * <p>Works like {@code abbreviate(String, String, int)}, but allows you to specify
 * a "left edge" offset.  Note that this left edge is not necessarily going to
 * be the leftmost character in the result, or the first character following the
 * replacement marker, but it will appear somewhere in the result.
 *
 * <p>In no case will it return a String of length greater than {@code maxWidth}.</p>
 *
 * <pre>
 * StringUtils.abbreviate(null, null, *, *)                 = null
 * StringUtils.abbreviate("abcdefghijklmno", null, *, *)    = "abcdefghijklmno"
 * StringUtils.abbreviate("", "...", 0, 4)                  = ""
 * StringUtils.abbreviate("abcdefghijklmno", "---", -1, 10) = "abcdefg---"
 * StringUtils.abbreviate("abcdefghijklmno", ",", 0, 10)    = "abcdefghi,"
 * StringUtils.abbreviate("abcdefghijklmno", ",", 1, 10)    = "abcdefghi,"
 * StringUtils.abbreviate("abcdefghijklmno", ",", 2, 10)    = "abcdefghi,"
 * StringUtils.abbreviate("abcdefghijklmno", "::", 4, 10)   = "::efghij::"
 * StringUtils.abbreviate("abcdefghijklmno", "...", 6, 10)  = "...ghij..."
 * StringUtils.abbreviate("abcdefghijklmno", "*", 9, 10)    = "*ghijklmno"
 * StringUtils.abbreviate("abcdefghijklmno", "'", 10, 10)   = "'ghijklmno"
 * StringUtils.abbreviate("abcdefghijklmno", "!", 12, 10)   = "!ghijklmno"
 * StringUtils.abbreviate("abcdefghij", "abra", 0, 4)       = IllegalArgumentException
 * StringUtils.abbreviate("abcdefghij", "...", 5, 6)        = IllegalArgumentException
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param abbrevMarker  the String used as replacement marker
 * @param offset  left edge of source String
 * @param maxWidth  maximum length of result String, must be at least 4
 * @return abbreviated String, {@code null} if null String input
 * @throws IllegalArgumentException if the width is too small
 * @since 3.6
 */
public static String abbreviate(final String str, final String abbrevMarker, int offset, final int maxWidth) {
    if (isEmpty(str) && isEmpty(abbrevMarker)) {
        return str;
    } else if (isNotEmpty(str) && EMPTY.equals(abbrevMarker) && maxWidth > 0) {
        return str.substring(0, maxWidth);
    } else if (isEmpty(str) || isEmpty(abbrevMarker)) {
        return str;
    }
    final int abbrevMarkerLength = abbrevMarker.length();
    final int minAbbrevWidth = abbrevMarkerLength + 1;
    final int minAbbrevWidthOffset = abbrevMarkerLength + abbrevMarkerLength + 1;
    if (maxWidth < minAbbrevWidth) {
        throw new IllegalArgumentException(String.format("Minimum abbreviation width is %d", minAbbrevWidth));
    }
    if (str.length() <= maxWidth) {
        return str;
    }
    if (offset > str.length()) {
        offset = str.length();
    }
    if (str.length() - offset < maxWidth - abbrevMarkerLength) {
        offset = str.length() - (maxWidth - abbrevMarkerLength);
    }
    if (offset <= abbrevMarkerLength + 1) {
        return str.substring(0, maxWidth - abbrevMarkerLength) + abbrevMarker;
    }
    if (maxWidth < minAbbrevWidthOffset) {
        throw new IllegalArgumentException(String.format("Minimum abbreviation width with offset is %d", minAbbrevWidthOffset));
    }
    if (offset + maxWidth - abbrevMarkerLength < str.length()) {
        return abbrevMarker + abbreviate(str.substring(offset), abbrevMarker, maxWidth - abbrevMarkerLength);
    }
    return abbrevMarker + str.substring(str.length() - (maxWidth - abbrevMarkerLength));
}
*********************************

#### Score: 27.47127


/**
 * Returns the given {@code template} string with each occurrence of {@code "%s"} replaced with
 * the corresponding argument value from {@code args}; or, if the placeholder and argument counts
 * do not match, returns a best-effort form of that string. Will not throw an exception under
 * normal conditions.
 *
 * <p><b>Note:</b> For most string-formatting needs, use {@link String#format String.format},
 * {@link java.io.PrintWriter#format PrintWriter.format}, and related methods. These support the
 * full range of <a
 * href="https://docs.oracle.com/javase/9/docs/api/java/util/Formatter.html#syntax">format
 * specifiers</a>, and alert you to usage errors by throwing {@link
 * java.util.IllegalFormatException}.
 *
 * <p>In certain cases, such as outputting debugging information or constructing a message to be
 * used for another unchecked exception, an exception during string formatting would serve little
 * purpose except to supplant the real information you were trying to provide. These are the cases
 * this method is made for; it instead generates a best-effort string with all supplied argument
 * values present. This method is also useful in environments such as GWT where {@code
 * String.format} is not available. As an example, method implementations of the {@link
 * Preconditions} class use this formatter, for both of the reasons just discussed.
 *
 * <p><b>Warning:</b> Only the exact two-character placeholder sequence {@code "%s"} is
 * recognized.
 *
 * @param template a string containing zero or more {@code "%s"} placeholder sequences. {@code
 *     null} is treated as the four-character string {@code "null"}.
 * @param args the arguments to be substituted into the message template. The first argument
 *     specified is substituted for the first occurrence of {@code "%s"} in the template, and so
 *     forth. A {@code null} argument is converted to the four-character string {@code "null"};
 *     non-null values are converted to strings using {@link Object#toString()}.
 * @since 25.1
 */
// TODO(diamondm) consider using Arrays.toString() for array parameters
public static String lenientFormat(@Nullable String template, @Nullable Object@Nullable ... args) {
    // null -> "null"
    template = String.valueOf(template);
    if (args == null) {
        args = new Object[] { "(Object[])null" };
    } else {
        for (int i = 0; i < args.length; i++) {
            args[i] = lenientToString(args[i]);
        }
    }
    // start substituting the arguments into the '%s' placeholders
    StringBuilder builder = new StringBuilder(template.length() + 16 * args.length);
    int templateStart = 0;
    int i = 0;
    while (i < args.length) {
        int placeholderStart = template.indexOf("%s", templateStart);
        if (placeholderStart == -1) {
            break;
        }
        builder.append(template, templateStart, placeholderStart);
        builder.append(args[i++]);
        templateStart = placeholderStart + 2;
    }
    builder.append(template, templateStart, template.length());
    // if we run out of placeholders, append the extra args in square braces
    if (i < args.length) {
        builder.append(" [");
        builder.append(args[i++]);
        while (i < args.length) {
            builder.append(", ");
            builder.append(args[i++]);
        }
        builder.append(']');
    }
    return builder.toString();
}
*********************************

#### Score: 27.32172


/**
 * <p>
 * Replace all occurrences of Strings within another String.
 * This is a private recursive helper method for {@link #replaceEachRepeatedly(String, String[], String[])} and
 * {@link #replaceEach(String, String[], String[])}
 * </p>
 *
 * <p>
 * A {@code null} reference passed to this method is a no-op, or if
 * any "mos.search string" or "string to replace" is null, that replace will be
 * ignored.
 * </p>
 *
 * <pre>
 *  StringUtils.replaceEach(null, *, *, *, *) = null
 *  StringUtils.replaceEach("", *, *, *, *) = ""
 *  StringUtils.replaceEach("aba", null, null, *, *) = "aba"
 *  StringUtils.replaceEach("aba", new String[0], null, *, *) = "aba"
 *  StringUtils.replaceEach("aba", null, new String[0], *, *) = "aba"
 *  StringUtils.replaceEach("aba", new String[]{"a"}, null, *, *) = "aba"
 *  StringUtils.replaceEach("aba", new String[]{"a"}, new String[]{""}, *, >=0) = "b"
 *  StringUtils.replaceEach("aba", new String[]{null}, new String[]{"a"}, *, >=0) = "aba"
 *  StringUtils.replaceEach("abcde", new String[]{"ab", "d"}, new String[]{"w", "t"}, *, >=0) = "wcte"
 *  (example of how it repeats)
 *  StringUtils.replaceEach("abcde", new String[]{"ab", "d"}, new String[]{"d", "t"}, false, >=0) = "dcte"
 *  StringUtils.replaceEach("abcde", new String[]{"ab", "d"}, new String[]{"d", "t"}, true, >=2) = "tcte"
 *  StringUtils.replaceEach("abcde", new String[]{"ab", "d"}, new String[]{"d", "ab"}, *, *) = IllegalStateException
 * </pre>
 *
 * @param text
 *            text to mos.search and replace in, no-op if null
 * @param searchList
 *            the Strings to mos.search for, no-op if null
 * @param replacementList
 *            the Strings to replace them with, no-op if null
 * @param repeat if true, then replace repeatedly
 *       until there are no more possible replacements or timeToLive < 0
 * @param timeToLive
 *            if less than 0 then there is a circular reference and endless
 *            loop
 * @return the text with any replacements processed, {@code null} if
 *         null String input
 * @throws IllegalStateException
 *             if the mos.search is repeating and there is an endless loop due
 *             to outputs of one being inputs to another
 * @throws IllegalArgumentException
 *             if the lengths of the arrays are not the same (null is ok,
 *             and/or size 0)
 * @since 2.4
 */
private static String replaceEach(final String text, final String[] searchList, final String[] replacementList, final boolean repeat, final int timeToLive) {
    if (isEmpty(text) || ArrayUtils.isEmpty(searchList) || ArrayUtils.isEmpty(replacementList)) {
        return text;
    }
    // if recursing, this shouldn't be less than 0
    if (timeToLive < 0) {
        throw new IllegalStateException("Aborting to protect against StackOverflowError - " + "output of one loop is the input of another");
    }
    final int searchLength = searchList.length;
    final int replacementLength = replacementList.length;
    // make sure lengths are ok, these need to be equal
    if (searchLength != replacementLength) {
        throw new IllegalArgumentException("Search and Replace array lengths don't match: " + searchLength + " vs " + replacementLength);
    }
    // keep track of which still have matches
    final boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];
    // index on index that the match was found
    int textIndex = -1;
    int replaceIndex = -1;
    int tempIndex = -1;
    // NOTE: logic duplicated below START
    for (int i = 0; i < searchLength; i++) {
        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) {
            continue;
        }
        tempIndex = text.indexOf(searchList[i]);
        // see if we need to keep searching for this
        if (tempIndex == -1) {
            noMoreMatchesForReplIndex[i] = true;
        } else {
            if (textIndex == -1 || tempIndex < textIndex) {
                textIndex = tempIndex;
                replaceIndex = i;
            }
        }
    }
    // no mos.search strings found, we are done
    if (textIndex == -1) {
        return text;
    }
    int start = 0;
    // get a good guess on the size of the result buffer so it doesn't have to double if it goes over a bit
    int increase = 0;
    // count the replacement text elements that are larger than their corresponding text being replaced
    for (int i = 0; i < searchList.length; i++) {
        if (searchList[i] == null || replacementList[i] == null) {
            continue;
        }
        final int greater = replacementList[i].length() - searchList[i].length();
        if (greater > 0) {
            // assume 3 matches
            increase += 3 * greater;
        }
    }
    // have upper-bound at 20% increase, then let Java take over
    increase = Math.min(increase, text.length() / 5);
    final StringBuilder buf = new StringBuilder(text.length() + increase);
    while (textIndex != -1) {
        for (int i = start; i < textIndex; i++) {
            buf.append(text.charAt(i));
        }
        buf.append(replacementList[replaceIndex]);
        start = textIndex + searchList[replaceIndex].length();
        textIndex = -1;
        replaceIndex = -1;
        tempIndex = -1;
        // NOTE: logic mostly duplicated above START
        for (int i = 0; i < searchLength; i++) {
            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) {
                continue;
            }
            tempIndex = text.indexOf(searchList[i], start);
            // see if we need to keep searching for this
            if (tempIndex == -1) {
                noMoreMatchesForReplIndex[i] = true;
            } else {
                if (textIndex == -1 || tempIndex < textIndex) {
                    textIndex = tempIndex;
                    replaceIndex = i;
                }
            }
        }
    // NOTE: logic duplicated above END
    }
    final int textLength = text.length();
    for (int i = start; i < textLength; i++) {
        buf.append(text.charAt(i));
    }
    final String result = buf.toString();
    if (!repeat) {
        return result;
    }
    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);
}
*********************************

#### Score: 26.62600


/**
 * <p>Find the Fuzzy Distance which indicates the similarity score between two Strings.</p>
 *
 * <p>This string matching algorithm is similar to the algorithms of editors such as Sublime Text,
 * TextMate, Atom and others. One point is given for every matched character. Subsequent
 * matches yield two bonus points. A higher score indicates a higher similarity.</p>
 *
 * <pre>
 * StringUtils.getFuzzyDistance(null, null, null)                                    = IllegalArgumentException
 * StringUtils.getFuzzyDistance("", "", Locale.ENGLISH)                              = 0
 * StringUtils.getFuzzyDistance("Workshop", "b", Locale.ENGLISH)                     = 0
 * StringUtils.getFuzzyDistance("Room", "o", Locale.ENGLISH)                         = 1
 * StringUtils.getFuzzyDistance("Workshop", "w", Locale.ENGLISH)                     = 1
 * StringUtils.getFuzzyDistance("Workshop", "ws", Locale.ENGLISH)                    = 2
 * StringUtils.getFuzzyDistance("Workshop", "wo", Locale.ENGLISH)                    = 4
 * StringUtils.getFuzzyDistance("Apache Software Foundation", "asf", Locale.ENGLISH) = 3
 * </pre>
 *
 * @param term a full term that should be matched against, must not be null
 * @param query the query that will be matched against a term, must not be null
 * @param locale This string matching logic is case insensitive. A locale is necessary to normalize
 *  both Strings to lower case.
 * @return result score
 * @throws IllegalArgumentException if either String input {@code null} or Locale input {@code null}
 * @since 3.4
 * @deprecated as of 3.6, use commons-text
 * <a href="https://commons.apache.org/proper/commons-text/javadocs/api-release/org/apache/commons/text/similarity/FuzzyScore.html">
 * FuzzyScore</a> instead
 */
@Deprecated
public static int getFuzzyDistance(final CharSequence term, final CharSequence query, final Locale locale) {
    if (term == null || query == null) {
        throw new IllegalArgumentException("Strings must not be null");
    } else if (locale == null) {
        throw new IllegalArgumentException("Locale must not be null");
    }
    // fuzzy logic is case insensitive. We normalize the Strings to lower
    // case right from the start. Turning characters to lower case
    // via Character.toLowerCase(char) is unfortunately insufficient
    // as it does not accept a locale.
    final String termLowerCase = term.toString().toLowerCase(locale);
    final String queryLowerCase = query.toString().toLowerCase(locale);
    // the resulting score
    int score = 0;
    // the position in the term which will be scanned next for potential
    // query character matches
    int termIndex = 0;
    // index of the previously matched character in the term
    int previousMatchingCharacterIndex = Integer.MIN_VALUE;
    for (int queryIndex = 0; queryIndex < queryLowerCase.length(); queryIndex++) {
        final char queryChar = queryLowerCase.charAt(queryIndex);
        boolean termCharacterMatchFound = false;
        for (; termIndex < termLowerCase.length() && !termCharacterMatchFound; termIndex++) {
            final char termChar = termLowerCase.charAt(termIndex);
            if (queryChar == termChar) {
                // simple character matches result in one point
                score++;
                // the score.
                if (previousMatchingCharacterIndex + 1 == termIndex) {
                    score += 2;
                }
                previousMatchingCharacterIndex = termIndex;
                // we can leave the nested loop. Every character in the
                // query can match at most one character in the term.
                termCharacterMatchFound = true;
            }
        }
    }
    return score;
}
*********************************

#### Score: 23.08057


/**
 * <p>Find the Levenshtein distance between two Strings if it's less than or equal to a given
 * threshold.</p>
 *
 * <p>This is the number of changes needed to change one String into
 * another, where each change is a single character modification (deletion,
 * insertion or substitution).</p>
 *
 * <p>This implementation follows from Algorithms on Strings, Trees and Sequences by Dan Gusfield
 * and Chas Emerick's implementation of the Levenshtein distance algorithm from
 * <a href="http://www.merriampark.com/ld.htm">http://www.merriampark.com/ld.htm</a></p>
 *
 * <pre>
 * StringUtils.getLevenshteinDistance(null, *, *)             = IllegalArgumentException
 * StringUtils.getLevenshteinDistance(*, null, *)             = IllegalArgumentException
 * StringUtils.getLevenshteinDistance(*, *, -1)               = IllegalArgumentException
 * StringUtils.getLevenshteinDistance("", "", 0)              = 0
 * StringUtils.getLevenshteinDistance("aaapppp", "", 8)       = 7
 * StringUtils.getLevenshteinDistance("aaapppp", "", 7)       = 7
 * StringUtils.getLevenshteinDistance("aaapppp", "", 6))      = -1
 * StringUtils.getLevenshteinDistance("elephant", "hippo", 7) = 7
 * StringUtils.getLevenshteinDistance("elephant", "hippo", 6) = -1
 * StringUtils.getLevenshteinDistance("hippo", "elephant", 7) = 7
 * StringUtils.getLevenshteinDistance("hippo", "elephant", 6) = -1
 * </pre>
 *
 * @param s  the first String, must not be null
 * @param t  the second String, must not be null
 * @param threshold the target threshold, must not be negative
 * @return result distance, or {@code -1} if the distance would be greater than the threshold
 * @throws IllegalArgumentException if either String input {@code null} or negative threshold
 * @deprecated as of 3.6, use commons-text
 * <a href="https://commons.apache.org/proper/commons-text/javadocs/api-release/org/apache/commons/text/similarity/LevenshteinDistance.html">
 * LevenshteinDistance</a> instead
 */
@Deprecated
public static int getLevenshteinDistance(CharSequence s, CharSequence t, final int threshold) {
    if (s == null || t == null) {
        throw new IllegalArgumentException("Strings must not be null");
    }
    if (threshold < 0) {
        throw new IllegalArgumentException("Threshold must not be negative");
    }
    /*
        This implementation only computes the distance if it's less than or equal to the
        threshold value, returning -1 if it's greater.  The advantage is performance: unbounded
        distance is O(nm), but a bound of k allows us to reduce it to O(km) time by only
        computing a diagonal stripe of width 2k + 1 of the cost table.
        It is also possible to use this to compute the unbounded Levenshtein distance by starting
        the threshold at 1 and doubling each time until the distance is found; this is O(dm), where
        d is the distance.

        One subtlety comes from needing to ignore entries on the border of our stripe
        eg.
        p[] = |#|#|#|*
        d[] =  *|#|#|#|
        We must ignore the entry to the left of the leftmost member
        We must ignore the entry above the rightmost member

        Another subtlety comes from our stripe running off the matrix if the strings aren't
        of the same size.  Since string s is always swapped to be the shorter of the two,
        the stripe will always run off to the upper right instead of the lower left of the matrix.

        As a concrete example, suppose s is of length 5, t is of length 7, and our threshold is 1.
        In this case we're going to walk a stripe of length 3.  The matrix would look like so:

           1 2 3 4 5
        1 |#|#| | | |
        2 |#|#|#| | |
        3 | |#|#|#| |
        4 | | |#|#|#|
        5 | | | |#|#|
        6 | | | | |#|
        7 | | | | | |

        Note how the stripe leads off the table as there is no possible way to turn a string of length 5
        into one of length 7 in edit distance of 1.

        Additionally, this implementation decreases memory usage by using two
        single-dimensional arrays and swapping them back and forth instead of allocating
        an entire n by m matrix.  This requires a few minor changes, such as immediately returning
        when it's detected that the stripe has run off the matrix and initially filling the arrays with
        large values so that entries we don't compute are ignored.

        See Algorithms on Strings, Trees and Sequences by Dan Gusfield for some discussion.
         */
    // length of s
    int n = s.length();
    // length of t
    int m = t.length();
    // if one string is empty, the edit distance is necessarily the length of the other
    if (n == 0) {
        return m <= threshold ? m : -1;
    } else if (m == 0) {
        return n <= threshold ? n : -1;
    } else if (Math.abs(n - m) > threshold) {
        // no need to calculate the distance if the length difference is greater than the threshold
        return -1;
    }
    if (n > m) {
        // swap the two strings to consume less memory
        final CharSequence tmp = s;
        s = t;
        t = tmp;
        n = m;
        m = t.length();
    }
    // 'previous' cost array, horizontally
    int[] p = new int[n + 1];
    // cost array, horizontally
    int[] d = new int[n + 1];
    // placeholder to assist in swapping p and d
    int[] _d;
    // fill in starting table values
    final int boundary = Math.min(n, threshold) + 1;
    for (int i = 0; i < boundary; i++) {
        p[i] = i;
    }
    // these fills ensure that the value above the rightmost entry of our
    // stripe will be ignored in following loop iterations
    Arrays.fill(p, boundary, p.length, Integer.MAX_VALUE);
    Arrays.fill(d, Integer.MAX_VALUE);
    // iterates through t
    for (int j = 1; j <= m; j++) {
        // jth character of t
        final char t_j = t.charAt(j - 1);
        d[0] = j;
        // compute stripe indices, constrain to array size
        final int min = Math.max(1, j - threshold);
        final int max = j > Integer.MAX_VALUE - threshold ? n : Math.min(n, j + threshold);
        // the stripe may lead off of the table if s and t are of different sizes
        if (min > max) {
            return -1;
        }
        // ignore entry left of leftmost
        if (min > 1) {
            d[min - 1] = Integer.MAX_VALUE;
        }
        // iterates through [min, max] in s
        for (int i = min; i <= max; i++) {
            if (s.charAt(i - 1) == t_j) {
                // diagonally left and up
                d[i] = p[i - 1];
            } else {
                // 1 + minimum of cell to the left, to the top, diagonally left and up
                d[i] = 1 + Math.min(Math.min(d[i - 1], p[i]), p[i - 1]);
            }
        }
        // copy current distance counts to 'previous row' distance counts
        _d = p;
        p = d;
        d = _d;
    }
    // distance
    if (p[n] <= threshold) {
        return p[n];
    }
    return -1;
}
*********************************

#### Score: 22.62726


// Misc
// -----------------------------------------------------------------------
/**
 * <p>Find the Levenshtein distance between two Strings.</p>
 *
 * <p>This is the number of changes needed to change one String into
 * another, where each change is a single character modification (deletion,
 * insertion or substitution).</p>
 *
 * <p>The implementation uses a single-dimensional array of length s.length() + 1. See
 * <a href="http://blog.softwx.net/2014/12/optimizing-levenshtein-algorithm-in-c.html">
 * http://blog.softwx.net/2014/12/optimizing-levenshtein-algorithm-in-c.html</a> for details.</p>
 *
 * <pre>
 * StringUtils.getLevenshteinDistance(null, *)             = IllegalArgumentException
 * StringUtils.getLevenshteinDistance(*, null)             = IllegalArgumentException
 * StringUtils.getLevenshteinDistance("", "")              = 0
 * StringUtils.getLevenshteinDistance("", "a")             = 1
 * StringUtils.getLevenshteinDistance("aaapppp", "")       = 7
 * StringUtils.getLevenshteinDistance("frog", "fog")       = 1
 * StringUtils.getLevenshteinDistance("fly", "ant")        = 3
 * StringUtils.getLevenshteinDistance("elephant", "hippo") = 7
 * StringUtils.getLevenshteinDistance("hippo", "elephant") = 7
 * StringUtils.getLevenshteinDistance("hippo", "zzzzzzzz") = 8
 * StringUtils.getLevenshteinDistance("hello", "hallo")    = 1
 * </pre>
 *
 * @param s  the first String, must not be null
 * @param t  the second String, must not be null
 * @return result distance
 * @throws IllegalArgumentException if either String input {@code null}
 * @since 3.0 Changed signature from getLevenshteinDistance(String, String) to
 * getLevenshteinDistance(CharSequence, CharSequence)
 * @deprecated as of 3.6, use commons-text
 * <a href="https://commons.apache.org/proper/commons-text/javadocs/api-release/org/apache/commons/text/similarity/LevenshteinDistance.html">
 * LevenshteinDistance</a> instead
 */
@Deprecated
public static int getLevenshteinDistance(CharSequence s, CharSequence t) {
    if (s == null || t == null) {
        throw new IllegalArgumentException("Strings must not be null");
    }
    int n = s.length();
    int m = t.length();
    if (n == 0) {
        return m;
    } else if (m == 0) {
        return n;
    }
    if (n > m) {
        // swap the input strings to consume less memory
        final CharSequence tmp = s;
        s = t;
        t = tmp;
        n = m;
        m = t.length();
    }
    final int[] p = new int[n + 1];
    // indexes into strings s and t
    // iterates through s
    int i;
    // iterates through t
    int j;
    int upper_left;
    int upper;
    // jth character of t
    char t_j;
    int cost;
    for (i = 0; i <= n; i++) {
        p[i] = i;
    }
    for (j = 1; j <= m; j++) {
        upper_left = p[0];
        t_j = t.charAt(j - 1);
        p[0] = j;
        for (i = 1; i <= n; i++) {
            upper = p[i];
            cost = s.charAt(i - 1) == t_j ? 0 : 1;
            // minimum of cell to the left+1, to the top+1, diagonally left and up +cost
            p[i] = Math.min(Math.min(p[i - 1] + 1, p[i] + 1), upper_left + cost);
            upper_left = upper;
        }
    }
    return p[n];
}
*********************************

#### Score: 20.07398


private static String lenientToString(@Nullable Object o) {
    try {
        return String.valueOf(o);
    } catch (Exception e) {
        // Default toString() behavior - see Object.toString()
        String objectToString = o.getClass().getName() + '@' + Integer.toHexString(System.identityHashCode(o));
        // Logger is created inline with fixed name to avoid forcing Proguard to create another class.
        Logger.getLogger("com.google.common.base.Strings").log(WARNING, "Exception during lenientFormat for " + objectToString, e);
        return "<" + objectToString + " threw " + e.getClass().getName() + ">";
    }
}