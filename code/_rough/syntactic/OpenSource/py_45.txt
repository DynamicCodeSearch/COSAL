### Py functions

def __init__(cls, name, bases, dct):
    super(_TemplateMetaclass, cls).__init__(name, bases, dct)
    if 'pattern' in dct:
        pattern = cls.pattern
    else:
        pattern = _TemplateMetaclass.pattern % {'delim': _re.escape(cls.
            delimiter), 'id': cls.idpattern}
    cls.pattern = _re.compile(pattern, _re.IGNORECASE | _re.VERBOSE)

*********************************

#### Score: 35.84153


/**
 * <p>Removes diacritics (~= accents) from a string. The case will not be altered.</p>
 * <p>For instance, '&agrave;' will be replaced by 'a'.</p>
 * <p>Note that ligatures will be left as is.</p>
 *
 * <pre>
 * StringUtils.stripAccents(null)                = null
 * StringUtils.stripAccents("")                  = ""
 * StringUtils.stripAccents("control")           = "control"
 * StringUtils.stripAccents("&eacute;clair")     = "eclair"
 * </pre>
 *
 * @param input String to be stripped
 * @return input text with diacritics removed
 *
 * @since 3.0
 */
// See also Lucene's ASCIIFoldingFilter (Lucene 2.9) that replaces accented characters by their unaccented equivalent (and uncommitted bug fix: https://issues.apache.org/jira/browse/LUCENE-1343?focusedCommentId=12858907&page=com.atlassian.jira.plugin.system.issuetabpanels%3Acomment-tabpanel#action_12858907).
public static String stripAccents(final String input) {
    if (input == null) {
        return null;
    }
    // $NON-NLS-1$
    final Pattern pattern = Pattern.compile("\\p{InCombiningDiacriticalMarks}+");
    final StringBuilder decomposed = new StringBuilder(Normalizer.normalize(input, Normalizer.Form.NFD));
    convertRemainingAccentCharacters(decomposed);
    // Note that this doesn't correctly remove ligatures...
    return pattern.matcher(decomposed).replaceAll(EMPTY);
}
*********************************

#### Score: 34.74463


/**
 * <p>Compares all Strings in an array and returns the initial sequence of
 * characters that is common to all of them.</p>
 *
 * <p>For example,
 * <code>getCommonPrefix(new String[] {"i am a machine", "i am a robot"}) -&gt; "i am a "</code></p>
 *
 * <pre>
 * StringUtils.getCommonPrefix(null) = ""
 * StringUtils.getCommonPrefix(new String[] {}) = ""
 * StringUtils.getCommonPrefix(new String[] {"abc"}) = "abc"
 * StringUtils.getCommonPrefix(new String[] {null, null}) = ""
 * StringUtils.getCommonPrefix(new String[] {"", ""}) = ""
 * StringUtils.getCommonPrefix(new String[] {"", null}) = ""
 * StringUtils.getCommonPrefix(new String[] {"abc", null, null}) = ""
 * StringUtils.getCommonPrefix(new String[] {null, null, "abc"}) = ""
 * StringUtils.getCommonPrefix(new String[] {"", "abc"}) = ""
 * StringUtils.getCommonPrefix(new String[] {"abc", ""}) = ""
 * StringUtils.getCommonPrefix(new String[] {"abc", "abc"}) = "abc"
 * StringUtils.getCommonPrefix(new String[] {"abc", "a"}) = "a"
 * StringUtils.getCommonPrefix(new String[] {"ab", "abxyz"}) = "ab"
 * StringUtils.getCommonPrefix(new String[] {"abcde", "abxyz"}) = "ab"
 * StringUtils.getCommonPrefix(new String[] {"abcde", "xyz"}) = ""
 * StringUtils.getCommonPrefix(new String[] {"xyz", "abcde"}) = ""
 * StringUtils.getCommonPrefix(new String[] {"i am a machine", "i am a robot"}) = "i am a "
 * </pre>
 *
 * @param strs  array of String objects, entries may be null
 * @return the initial sequence of characters that are common to all Strings
 * in the array; empty String if the array is null, the elements are all null
 * or if there is no common prefix.
 * @since 2.4
 */
public static String getCommonPrefix(final String... strs) {
    if (ArrayUtils.isEmpty(strs)) {
        return EMPTY;
    }
    final int smallestIndexOfDiff = indexOfDifference(strs);
    if (smallestIndexOfDiff == INDEX_NOT_FOUND) {
        // all strings were identical
        if (strs[0] == null) {
            return EMPTY;
        }
        return strs[0];
    } else if (smallestIndexOfDiff == 0) {
        // there were no common initial characters
        return EMPTY;
    } else {
        // we found a common initial character sequence
        return strs[0].substring(0, smallestIndexOfDiff);
    }
}
*********************************

#### Score: 33.42002


// Chomping
// -----------------------------------------------------------------------
/**
 * <p>Removes one newline from end of a String if it's there,
 * otherwise leave it alone.  A newline is &quot;{@code \n}&quot;,
 * &quot;{@code \r}&quot;, or &quot;{@code \r\n}&quot;.</p>
 *
 * <p>NOTE: This method changed in 2.0.
 * It now more closely matches Perl chomp.</p>
 *
 * <pre>
 * StringUtils.chomp(null)          = null
 * StringUtils.chomp("")            = ""
 * StringUtils.chomp("abc \r")      = "abc "
 * StringUtils.chomp("abc\n")       = "abc"
 * StringUtils.chomp("abc\r\n")     = "abc"
 * StringUtils.chomp("abc\r\n\r\n") = "abc\r\n"
 * StringUtils.chomp("abc\n\r")     = "abc\n"
 * StringUtils.chomp("abc\n\rabc")  = "abc\n\rabc"
 * StringUtils.chomp("\r")          = ""
 * StringUtils.chomp("\n")          = ""
 * StringUtils.chomp("\r\n")        = ""
 * </pre>
 *
 * @param str  the String to chomp a newline from, may be null
 * @return String without newline, {@code null} if null String input
 */
public static String chomp(final String str) {
    if (isEmpty(str)) {
        return str;
    }
    if (str.length() == 1) {
        final char ch = str.charAt(0);
        if (ch == CharUtils.CR || ch == CharUtils.LF) {
            return EMPTY;
        }
        return str;
    }
    int lastIdx = str.length() - 1;
    final char last = str.charAt(lastIdx);
    if (last == CharUtils.LF) {
        if (str.charAt(lastIdx - 1) == CharUtils.CR) {
            lastIdx--;
        }
    } else if (last != CharUtils.CR) {
        lastIdx++;
    }
    return str.substring(0, lastIdx);
}
*********************************

#### Score: 33.36751


/**
 * <p>Search a CharSequence to find the first index of any
 * character not in the given set of characters.</p>
 *
 * <p>A {@code null} CharSequence will return {@code -1}.
 * A {@code null} or empty mos.search string will return {@code -1}.</p>
 *
 * <pre>
 * StringUtils.indexOfAnyBut(null, *)            = -1
 * StringUtils.indexOfAnyBut("", *)              = -1
 * StringUtils.indexOfAnyBut(*, null)            = -1
 * StringUtils.indexOfAnyBut(*, "")              = -1
 * StringUtils.indexOfAnyBut("zzabyycdxx", "za") = 3
 * StringUtils.indexOfAnyBut("zzabyycdxx", "")   = -1
 * StringUtils.indexOfAnyBut("aba", "ab")        = -1
 * </pre>
 *
 * @param seq  the CharSequence to check, may be null
 * @param searchChars  the chars to mos.search for, may be null
 * @return the index of any of the chars, -1 if no match or null input
 * @since 2.0
 * @since 3.0 Changed signature from indexOfAnyBut(String, String) to indexOfAnyBut(CharSequence, CharSequence)
 */
public static int indexOfAnyBut(final CharSequence seq, final CharSequence searchChars) {
    if (isEmpty(seq) || isEmpty(searchChars)) {
        return INDEX_NOT_FOUND;
    }
    final int strLen = seq.length();
    for (int i = 0; i < strLen; i++) {
        final char ch = seq.charAt(i);
        final boolean chFound = CharSequenceUtils.indexOf(searchChars, ch, 0) >= 0;
        if (i + 1 < strLen && Character.isHighSurrogate(ch)) {
            final char ch2 = seq.charAt(i + 1);
            if (chFound && CharSequenceUtils.indexOf(searchChars, ch2, 0) < 0) {
                return i;
            }
        } else {
            if (!chFound) {
                return i;
            }
        }
    }
    return INDEX_NOT_FOUND;
}
*********************************

#### Score: 32.83665


/**
 * <p>Compares all CharSequences in an array and returns the index at which the
 * CharSequences begin to differ.</p>
 *
 * <p>For example,
 * {@code indexOfDifference(new String[] {"i am a machine", "i am a robot"}) -> 7}</p>
 *
 * <pre>
 * StringUtils.indexOfDifference(null) = -1
 * StringUtils.indexOfDifference(new String[] {}) = -1
 * StringUtils.indexOfDifference(new String[] {"abc"}) = -1
 * StringUtils.indexOfDifference(new String[] {null, null}) = -1
 * StringUtils.indexOfDifference(new String[] {"", ""}) = -1
 * StringUtils.indexOfDifference(new String[] {"", null}) = 0
 * StringUtils.indexOfDifference(new String[] {"abc", null, null}) = 0
 * StringUtils.indexOfDifference(new String[] {null, null, "abc"}) = 0
 * StringUtils.indexOfDifference(new String[] {"", "abc"}) = 0
 * StringUtils.indexOfDifference(new String[] {"abc", ""}) = 0
 * StringUtils.indexOfDifference(new String[] {"abc", "abc"}) = -1
 * StringUtils.indexOfDifference(new String[] {"abc", "a"}) = 1
 * StringUtils.indexOfDifference(new String[] {"ab", "abxyz"}) = 2
 * StringUtils.indexOfDifference(new String[] {"abcde", "abxyz"}) = 2
 * StringUtils.indexOfDifference(new String[] {"abcde", "xyz"}) = 0
 * StringUtils.indexOfDifference(new String[] {"xyz", "abcde"}) = 0
 * StringUtils.indexOfDifference(new String[] {"i am a machine", "i am a robot"}) = 7
 * </pre>
 *
 * @param css  array of CharSequences, entries may be null
 * @return the index where the strings begin to differ; -1 if they are all equal
 * @since 2.4
 * @since 3.0 Changed signature from indexOfDifference(String...) to indexOfDifference(CharSequence...)
 */
public static int indexOfDifference(final CharSequence... css) {
    if (ArrayUtils.getLength(css) <= 1) {
        return INDEX_NOT_FOUND;
    }
    boolean anyStringNull = false;
    boolean allStringsNull = true;
    final int arrayLen = css.length;
    int shortestStrLen = Integer.MAX_VALUE;
    int longestStrLen = 0;
    // the bottom loop.
    for (final CharSequence cs : css) {
        if (cs == null) {
            anyStringNull = true;
            shortestStrLen = 0;
        } else {
            allStringsNull = false;
            shortestStrLen = Math.min(cs.length(), shortestStrLen);
            longestStrLen = Math.max(cs.length(), longestStrLen);
        }
    }
    // handle lists containing all nulls or all empty strings
    if (allStringsNull || longestStrLen == 0 && !anyStringNull) {
        return INDEX_NOT_FOUND;
    }
    // handle lists containing some nulls or some empty strings
    if (shortestStrLen == 0) {
        return 0;
    }
    // find the position with the first difference across all strings
    int firstDiff = -1;
    for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) {
        final char comparisonChar = css[0].charAt(stringPos);
        for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) {
            if (css[arrayPos].charAt(stringPos) != comparisonChar) {
                firstDiff = stringPos;
                break;
            }
        }
        if (firstDiff != -1) {
            break;
        }
    }
    if (firstDiff == -1 && shortestStrLen != longestStrLen) {
        // vary, so return the length of the shortest string.
        return shortestStrLen;
    }
    return firstDiff;
}
*********************************

#### Score: 32.27319


/**
 * <p>Abbreviates a String using a given replacement marker. This will turn
 * "Now is the time for all good men" into "...is the time for..." if "..." was defined
 * as the replacement marker.</p>
 *
 * <p>Works like {@code abbreviate(String, String, int)}, but allows you to specify
 * a "left edge" offset.  Note that this left edge is not necessarily going to
 * be the leftmost character in the result, or the first character following the
 * replacement marker, but it will appear somewhere in the result.
 *
 * <p>In no case will it return a String of length greater than {@code maxWidth}.</p>
 *
 * <pre>
 * StringUtils.abbreviate(null, null, *, *)                 = null
 * StringUtils.abbreviate("abcdefghijklmno", null, *, *)    = "abcdefghijklmno"
 * StringUtils.abbreviate("", "...", 0, 4)                  = ""
 * StringUtils.abbreviate("abcdefghijklmno", "---", -1, 10) = "abcdefg---"
 * StringUtils.abbreviate("abcdefghijklmno", ",", 0, 10)    = "abcdefghi,"
 * StringUtils.abbreviate("abcdefghijklmno", ",", 1, 10)    = "abcdefghi,"
 * StringUtils.abbreviate("abcdefghijklmno", ",", 2, 10)    = "abcdefghi,"
 * StringUtils.abbreviate("abcdefghijklmno", "::", 4, 10)   = "::efghij::"
 * StringUtils.abbreviate("abcdefghijklmno", "...", 6, 10)  = "...ghij..."
 * StringUtils.abbreviate("abcdefghijklmno", "*", 9, 10)    = "*ghijklmno"
 * StringUtils.abbreviate("abcdefghijklmno", "'", 10, 10)   = "'ghijklmno"
 * StringUtils.abbreviate("abcdefghijklmno", "!", 12, 10)   = "!ghijklmno"
 * StringUtils.abbreviate("abcdefghij", "abra", 0, 4)       = IllegalArgumentException
 * StringUtils.abbreviate("abcdefghij", "...", 5, 6)        = IllegalArgumentException
 * </pre>
 *
 * @param str  the String to check, may be null
 * @param abbrevMarker  the String used as replacement marker
 * @param offset  left edge of source String
 * @param maxWidth  maximum length of result String, must be at least 4
 * @return abbreviated String, {@code null} if null String input
 * @throws IllegalArgumentException if the width is too small
 * @since 3.6
 */
public static String abbreviate(final String str, final String abbrevMarker, int offset, final int maxWidth) {
    if (isEmpty(str) && isEmpty(abbrevMarker)) {
        return str;
    } else if (isNotEmpty(str) && EMPTY.equals(abbrevMarker) && maxWidth > 0) {
        return str.substring(0, maxWidth);
    } else if (isEmpty(str) || isEmpty(abbrevMarker)) {
        return str;
    }
    final int abbrevMarkerLength = abbrevMarker.length();
    final int minAbbrevWidth = abbrevMarkerLength + 1;
    final int minAbbrevWidthOffset = abbrevMarkerLength + abbrevMarkerLength + 1;
    if (maxWidth < minAbbrevWidth) {
        throw new IllegalArgumentException(String.format("Minimum abbreviation width is %d", minAbbrevWidth));
    }
    if (str.length() <= maxWidth) {
        return str;
    }
    if (offset > str.length()) {
        offset = str.length();
    }
    if (str.length() - offset < maxWidth - abbrevMarkerLength) {
        offset = str.length() - (maxWidth - abbrevMarkerLength);
    }
    if (offset <= abbrevMarkerLength + 1) {
        return str.substring(0, maxWidth - abbrevMarkerLength) + abbrevMarker;
    }
    if (maxWidth < minAbbrevWidthOffset) {
        throw new IllegalArgumentException(String.format("Minimum abbreviation width with offset is %d", minAbbrevWidthOffset));
    }
    if (offset + maxWidth - abbrevMarkerLength < str.length()) {
        return abbrevMarker + abbreviate(str.substring(offset), abbrevMarker, maxWidth - abbrevMarkerLength);
    }
    return abbrevMarker + str.substring(str.length() - (maxWidth - abbrevMarkerLength));
}
*********************************

#### Score: 32.21595


/**
 * Appends the suffix to the end of the string if the string does not
 * already end with the suffix.
 *
 * @param str The string.
 * @param suffix The suffix to append to the end of the string.
 * @param ignoreCase Indicates whether the compare should ignore case.
 * @param suffixes Additional suffixes that are valid terminators (optional).
 *
 * @return A new String if suffix was appended, the same string otherwise.
 */
private static String appendIfMissing(final String str, final CharSequence suffix, final boolean ignoreCase, final CharSequence... suffixes) {
    if (str == null || isEmpty(suffix) || endsWith(str, suffix, ignoreCase)) {
        return str;
    }
    if (ArrayUtils.isNotEmpty(suffixes)) {
        for (final CharSequence s : suffixes) {
            if (endsWith(str, s, ignoreCase)) {
                return str;
            }
        }
    }
    return str + suffix.toString();
}
*********************************

#### Score: 32.21328


/**
 * Prepends the prefix to the start of the string if the string does not
 * already start with any of the prefixes.
 *
 * @param str The string.
 * @param prefix The prefix to prepend to the start of the string.
 * @param ignoreCase Indicates whether the compare should ignore case.
 * @param prefixes Additional prefixes that are valid (optional).
 *
 * @return A new String if prefix was prepended, the same string otherwise.
 */
private static String prependIfMissing(final String str, final CharSequence prefix, final boolean ignoreCase, final CharSequence... prefixes) {
    if (str == null || isEmpty(prefix) || startsWith(str, prefix, ignoreCase)) {
        return str;
    }
    if (ArrayUtils.isNotEmpty(prefixes)) {
        for (final CharSequence p : prefixes) {
            if (startsWith(str, p, ignoreCase)) {
                return str;
            }
        }
    }
    return prefix.toString() + str;
}
*********************************

#### Score: 32.08190


/**
 * <p>Search a CharSequence to find the first index of any
 * character in the given set of characters.</p>
 *
 * <p>A {@code null} String will return {@code -1}.
 * A {@code null} mos.search string will return {@code -1}.</p>
 *
 * <pre>
 * StringUtils.indexOfAny(null, *)            = -1
 * StringUtils.indexOfAny("", *)              = -1
 * StringUtils.indexOfAny(*, null)            = -1
 * StringUtils.indexOfAny(*, "")              = -1
 * StringUtils.indexOfAny("zzabyycdxx", "za") = 0
 * StringUtils.indexOfAny("zzabyycdxx", "by") = 3
 * StringUtils.indexOfAny("aba", "z")         = -1
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  the chars to mos.search for, may be null
 * @return the index of any of the chars, -1 if no match or null input
 * @since 2.0
 * @since 3.0 Changed signature from indexOfAny(String, String) to indexOfAny(CharSequence, String)
 */
public static int indexOfAny(final CharSequence cs, final String searchChars) {
    if (isEmpty(cs) || isEmpty(searchChars)) {
        return INDEX_NOT_FOUND;
    }
    return indexOfAny(cs, searchChars.toCharArray());
}
*********************************

#### Score: 32.05565


/**
 * <p>Finds the n-th index within a String, handling {@code null}.
 * This method uses {@link String#indexOf(String)} if possible.</p>
 * <p>Note that matches may overlap<p>
 *
 * <p>A {@code null} CharSequence will return {@code -1}.</p>
 *
 * @param str  the CharSequence to check, may be null
 * @param searchStr  the CharSequence to find, may be null
 * @param ordinal  the n-th {@code searchStr} to find, overlapping matches are allowed.
 * @param lastIndex true if lastOrdinalIndexOf() otherwise false if ordinalIndexOf()
 * @return the n-th index of the mos.search CharSequence,
 *  {@code -1} ({@code INDEX_NOT_FOUND}) if no match or {@code null} string input
 */
// Shared code between ordinalIndexOf(String, String, int) and lastOrdinalIndexOf(String, String, int)
private static int ordinalIndexOf(final CharSequence str, final CharSequence searchStr, final int ordinal, final boolean lastIndex) {
    if (str == null || searchStr == null || ordinal <= 0) {
        return INDEX_NOT_FOUND;
    }
    if (searchStr.length() == 0) {
        return lastIndex ? str.length() : 0;
    }
    int found = 0;
    // set the initial index beyond the end of the string
    // this is to allow for the initial index decrement/increment
    int index = lastIndex ? str.length() : INDEX_NOT_FOUND;
    do {
        if (lastIndex) {
            // step backwards thru string
            index = CharSequenceUtils.lastIndexOf(str, searchStr, index - 1);
        } else {
            // step forwards through string
            index = CharSequenceUtils.indexOf(str, searchStr, index + 1);
        }
        if (index < 0) {
            return index;
        }
        found++;
    } while (found < ordinal);
    return index;
}