### Py functions

def __setitem__(self, key, value, dict_setitem=dict.__setitem__):
    """od.__setitem__(i, y) <==> od[i]=y"""
    if key not in self:
        root = self.__root
        last = root[0]
        last[1] = root[0] = self.__map[key] = [last, root, key]
    return dict_setitem(self, key, value)

*********************************

#### Score: 30.84756


/**
 * Returns a string consisting of a specific number of concatenated copies of an input string. For
 * example, {@code repeat("hey", 3)} returns the string {@code "heyheyhey"}.
 *
 * @param string any non-null string
 * @param count the number of times to repeat it; a nonnegative integer
 * @return a string containing {@code string} repeated {@code count} times (the empty string if
 *     {@code count} is zero)
 * @throws IllegalArgumentException if {@code count} is negative
 */
public static String repeat(String string, int count) {
    // eager for GWT.
    checkNotNull(string);
    if (count <= 1) {
        checkArgument(count >= 0, "invalid count: %s", count);
        return (count == 0) ? "" : string;
    }
    // IF YOU MODIFY THE CODE HERE, you must update StringsRepeatBenchmark
    final int len = string.length();
    final long longSize = (long) len * (long) count;
    final int size = (int) longSize;
    if (size != longSize) {
        throw new ArrayIndexOutOfBoundsException("Required array size too large: " + longSize);
    }
    final char[] array = new char[size];
    string.getChars(0, len, array, 0);
    int n;
    for (n = len; n < size - n; n <<= 1) {
        System.arraycopy(array, 0, array, n, n);
    }
    System.arraycopy(array, 0, array, n, size - n);
    return new String(array);
}
*********************************

#### Score: 30.61978


/**
 * <p>Find the Jaro Winkler Distance which indicates the similarity score between two Strings.</p>
 *
 * <p>The Jaro measure is the weighted sum of percentage of matched characters from each file and transposed characters.
 * Winkler increased this measure for matching initial characters.</p>
 *
 * <p>This implementation is based on the Jaro Winkler similarity algorithm
 * from <a href="http://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance">http://en.wikipedia.org/wiki/Jaro%E2%80%93Winkler_distance</a>.</p>
 *
 * <pre>
 * StringUtils.getJaroWinklerDistance(null, null)          = IllegalArgumentException
 * StringUtils.getJaroWinklerDistance("", "")              = 0.0
 * StringUtils.getJaroWinklerDistance("", "a")             = 0.0
 * StringUtils.getJaroWinklerDistance("aaapppp", "")       = 0.0
 * StringUtils.getJaroWinklerDistance("frog", "fog")       = 0.93
 * StringUtils.getJaroWinklerDistance("fly", "ant")        = 0.0
 * StringUtils.getJaroWinklerDistance("elephant", "hippo") = 0.44
 * StringUtils.getJaroWinklerDistance("hippo", "elephant") = 0.44
 * StringUtils.getJaroWinklerDistance("hippo", "zzzzzzzz") = 0.0
 * StringUtils.getJaroWinklerDistance("hello", "hallo")    = 0.88
 * StringUtils.getJaroWinklerDistance("ABC Corporation", "ABC Corp") = 0.93
 * StringUtils.getJaroWinklerDistance("D N H Enterprises Inc", "D &amp; H Enterprises, Inc.") = 0.95
 * StringUtils.getJaroWinklerDistance("My Gym Children's Fitness Center", "My Gym. Childrens Fitness") = 0.92
 * StringUtils.getJaroWinklerDistance("PENNSYLVANIA", "PENNCISYLVNIA") = 0.88
 * </pre>
 *
 * @param first the first String, must not be null
 * @param second the second String, must not be null
 * @return result distance
 * @throws IllegalArgumentException if either String input {@code null}
 * @since 3.3
 * @deprecated as of 3.6, use commons-text
 * <a href="https://commons.apache.org/proper/commons-text/javadocs/api-release/org/apache/commons/text/similarity/JaroWinklerDistance.html">
 * JaroWinklerDistance</a> instead
 */
@Deprecated
public static double getJaroWinklerDistance(final CharSequence first, final CharSequence second) {
    final double DEFAULT_SCALING_FACTOR = 0.1;
    if (first == null || second == null) {
        throw new IllegalArgumentException("Strings must not be null");
    }
    final int[] mtp = matches(first, second);
    final double m = mtp[0];
    if (m == 0) {
        return 0D;
    }
    final double j = ((m / first.length() + m / second.length() + (m - mtp[1]) / m)) / 3;
    final double jw = j < 0.7D ? j : j + Math.min(DEFAULT_SCALING_FACTOR, 1D / mtp[3]) * mtp[2] * (1D - j);
    return Math.round(jw * 100.0D) / 100.0D;
}
*********************************

#### Score: 30.39546


/**
 * <p>Find the Levenshtein distance between two Strings if it's less than or equal to a given
 * threshold.</p>
 *
 * <p>This is the number of changes needed to change one String into
 * another, where each change is a single character modification (deletion,
 * insertion or substitution).</p>
 *
 * <p>This implementation follows from Algorithms on Strings, Trees and Sequences by Dan Gusfield
 * and Chas Emerick's implementation of the Levenshtein distance algorithm from
 * <a href="http://www.merriampark.com/ld.htm">http://www.merriampark.com/ld.htm</a></p>
 *
 * <pre>
 * StringUtils.getLevenshteinDistance(null, *, *)             = IllegalArgumentException
 * StringUtils.getLevenshteinDistance(*, null, *)             = IllegalArgumentException
 * StringUtils.getLevenshteinDistance(*, *, -1)               = IllegalArgumentException
 * StringUtils.getLevenshteinDistance("", "", 0)              = 0
 * StringUtils.getLevenshteinDistance("aaapppp", "", 8)       = 7
 * StringUtils.getLevenshteinDistance("aaapppp", "", 7)       = 7
 * StringUtils.getLevenshteinDistance("aaapppp", "", 6))      = -1
 * StringUtils.getLevenshteinDistance("elephant", "hippo", 7) = 7
 * StringUtils.getLevenshteinDistance("elephant", "hippo", 6) = -1
 * StringUtils.getLevenshteinDistance("hippo", "elephant", 7) = 7
 * StringUtils.getLevenshteinDistance("hippo", "elephant", 6) = -1
 * </pre>
 *
 * @param s  the first String, must not be null
 * @param t  the second String, must not be null
 * @param threshold the target threshold, must not be negative
 * @return result distance, or {@code -1} if the distance would be greater than the threshold
 * @throws IllegalArgumentException if either String input {@code null} or negative threshold
 * @deprecated as of 3.6, use commons-text
 * <a href="https://commons.apache.org/proper/commons-text/javadocs/api-release/org/apache/commons/text/similarity/LevenshteinDistance.html">
 * LevenshteinDistance</a> instead
 */
@Deprecated
public static int getLevenshteinDistance(CharSequence s, CharSequence t, final int threshold) {
    if (s == null || t == null) {
        throw new IllegalArgumentException("Strings must not be null");
    }
    if (threshold < 0) {
        throw new IllegalArgumentException("Threshold must not be negative");
    }
    /*
        This implementation only computes the distance if it's less than or equal to the
        threshold value, returning -1 if it's greater.  The advantage is performance: unbounded
        distance is O(nm), but a bound of k allows us to reduce it to O(km) time by only
        computing a diagonal stripe of width 2k + 1 of the cost table.
        It is also possible to use this to compute the unbounded Levenshtein distance by starting
        the threshold at 1 and doubling each time until the distance is found; this is O(dm), where
        d is the distance.

        One subtlety comes from needing to ignore entries on the border of our stripe
        eg.
        p[] = |#|#|#|*
        d[] =  *|#|#|#|
        We must ignore the entry to the left of the leftmost member
        We must ignore the entry above the rightmost member

        Another subtlety comes from our stripe running off the matrix if the strings aren't
        of the same size.  Since string s is always swapped to be the shorter of the two,
        the stripe will always run off to the upper right instead of the lower left of the matrix.

        As a concrete example, suppose s is of length 5, t is of length 7, and our threshold is 1.
        In this case we're going to walk a stripe of length 3.  The matrix would look like so:

           1 2 3 4 5
        1 |#|#| | | |
        2 |#|#|#| | |
        3 | |#|#|#| |
        4 | | |#|#|#|
        5 | | | |#|#|
        6 | | | | |#|
        7 | | | | | |

        Note how the stripe leads off the table as there is no possible way to turn a string of length 5
        into one of length 7 in edit distance of 1.

        Additionally, this implementation decreases memory usage by using two
        single-dimensional arrays and swapping them back and forth instead of allocating
        an entire n by m matrix.  This requires a few minor changes, such as immediately returning
        when it's detected that the stripe has run off the matrix and initially filling the arrays with
        large values so that entries we don't compute are ignored.

        See Algorithms on Strings, Trees and Sequences by Dan Gusfield for some discussion.
         */
    // length of s
    int n = s.length();
    // length of t
    int m = t.length();
    // if one string is empty, the edit distance is necessarily the length of the other
    if (n == 0) {
        return m <= threshold ? m : -1;
    } else if (m == 0) {
        return n <= threshold ? n : -1;
    } else if (Math.abs(n - m) > threshold) {
        // no need to calculate the distance if the length difference is greater than the threshold
        return -1;
    }
    if (n > m) {
        // swap the two strings to consume less memory
        final CharSequence tmp = s;
        s = t;
        t = tmp;
        n = m;
        m = t.length();
    }
    // 'previous' cost array, horizontally
    int[] p = new int[n + 1];
    // cost array, horizontally
    int[] d = new int[n + 1];
    // placeholder to assist in swapping p and d
    int[] _d;
    // fill in starting table values
    final int boundary = Math.min(n, threshold) + 1;
    for (int i = 0; i < boundary; i++) {
        p[i] = i;
    }
    // these fills ensure that the value above the rightmost entry of our
    // stripe will be ignored in following loop iterations
    Arrays.fill(p, boundary, p.length, Integer.MAX_VALUE);
    Arrays.fill(d, Integer.MAX_VALUE);
    // iterates through t
    for (int j = 1; j <= m; j++) {
        // jth character of t
        final char t_j = t.charAt(j - 1);
        d[0] = j;
        // compute stripe indices, constrain to array size
        final int min = Math.max(1, j - threshold);
        final int max = j > Integer.MAX_VALUE - threshold ? n : Math.min(n, j + threshold);
        // the stripe may lead off of the table if s and t are of different sizes
        if (min > max) {
            return -1;
        }
        // ignore entry left of leftmost
        if (min > 1) {
            d[min - 1] = Integer.MAX_VALUE;
        }
        // iterates through [min, max] in s
        for (int i = min; i <= max; i++) {
            if (s.charAt(i - 1) == t_j) {
                // diagonally left and up
                d[i] = p[i - 1];
            } else {
                // 1 + minimum of cell to the left, to the top, diagonally left and up
                d[i] = 1 + Math.min(Math.min(d[i - 1], p[i]), p[i - 1]);
            }
        }
        // copy current distance counts to 'previous row' distance counts
        _d = p;
        p = d;
        d = _d;
    }
    // distance
    if (p[n] <= threshold) {
        return p[n];
    }
    return -1;
}
*********************************

#### Score: 30.29473


// Misc
// -----------------------------------------------------------------------
/**
 * <p>Find the Levenshtein distance between two Strings.</p>
 *
 * <p>This is the number of changes needed to change one String into
 * another, where each change is a single character modification (deletion,
 * insertion or substitution).</p>
 *
 * <p>The implementation uses a single-dimensional array of length s.length() + 1. See
 * <a href="http://blog.softwx.net/2014/12/optimizing-levenshtein-algorithm-in-c.html">
 * http://blog.softwx.net/2014/12/optimizing-levenshtein-algorithm-in-c.html</a> for details.</p>
 *
 * <pre>
 * StringUtils.getLevenshteinDistance(null, *)             = IllegalArgumentException
 * StringUtils.getLevenshteinDistance(*, null)             = IllegalArgumentException
 * StringUtils.getLevenshteinDistance("", "")              = 0
 * StringUtils.getLevenshteinDistance("", "a")             = 1
 * StringUtils.getLevenshteinDistance("aaapppp", "")       = 7
 * StringUtils.getLevenshteinDistance("frog", "fog")       = 1
 * StringUtils.getLevenshteinDistance("fly", "ant")        = 3
 * StringUtils.getLevenshteinDistance("elephant", "hippo") = 7
 * StringUtils.getLevenshteinDistance("hippo", "elephant") = 7
 * StringUtils.getLevenshteinDistance("hippo", "zzzzzzzz") = 8
 * StringUtils.getLevenshteinDistance("hello", "hallo")    = 1
 * </pre>
 *
 * @param s  the first String, must not be null
 * @param t  the second String, must not be null
 * @return result distance
 * @throws IllegalArgumentException if either String input {@code null}
 * @since 3.0 Changed signature from getLevenshteinDistance(String, String) to
 * getLevenshteinDistance(CharSequence, CharSequence)
 * @deprecated as of 3.6, use commons-text
 * <a href="https://commons.apache.org/proper/commons-text/javadocs/api-release/org/apache/commons/text/similarity/LevenshteinDistance.html">
 * LevenshteinDistance</a> instead
 */
@Deprecated
public static int getLevenshteinDistance(CharSequence s, CharSequence t) {
    if (s == null || t == null) {
        throw new IllegalArgumentException("Strings must not be null");
    }
    int n = s.length();
    int m = t.length();
    if (n == 0) {
        return m;
    } else if (m == 0) {
        return n;
    }
    if (n > m) {
        // swap the input strings to consume less memory
        final CharSequence tmp = s;
        s = t;
        t = tmp;
        n = m;
        m = t.length();
    }
    final int[] p = new int[n + 1];
    // indexes into strings s and t
    // iterates through s
    int i;
    // iterates through t
    int j;
    int upper_left;
    int upper;
    // jth character of t
    char t_j;
    int cost;
    for (i = 0; i <= n; i++) {
        p[i] = i;
    }
    for (j = 1; j <= m; j++) {
        upper_left = p[0];
        t_j = t.charAt(j - 1);
        p[0] = j;
        for (i = 1; i <= n; i++) {
            upper = p[i];
            cost = s.charAt(i - 1) == t_j ? 0 : 1;
            // minimum of cell to the left+1, to the top+1, diagonally left and up +cost
            p[i] = Math.min(Math.min(p[i - 1] + 1, p[i] + 1), upper_left + cost);
            upper_left = upper;
        }
    }
    return p[n];
}
*********************************

#### Score: 30.03864


/**
 * <p>
 * Replace all occurrences of Strings within another String.
 * This is a private recursive helper method for {@link #replaceEachRepeatedly(String, String[], String[])} and
 * {@link #replaceEach(String, String[], String[])}
 * </p>
 *
 * <p>
 * A {@code null} reference passed to this method is a no-op, or if
 * any "mos.search string" or "string to replace" is null, that replace will be
 * ignored.
 * </p>
 *
 * <pre>
 *  StringUtils.replaceEach(null, *, *, *, *) = null
 *  StringUtils.replaceEach("", *, *, *, *) = ""
 *  StringUtils.replaceEach("aba", null, null, *, *) = "aba"
 *  StringUtils.replaceEach("aba", new String[0], null, *, *) = "aba"
 *  StringUtils.replaceEach("aba", null, new String[0], *, *) = "aba"
 *  StringUtils.replaceEach("aba", new String[]{"a"}, null, *, *) = "aba"
 *  StringUtils.replaceEach("aba", new String[]{"a"}, new String[]{""}, *, >=0) = "b"
 *  StringUtils.replaceEach("aba", new String[]{null}, new String[]{"a"}, *, >=0) = "aba"
 *  StringUtils.replaceEach("abcde", new String[]{"ab", "d"}, new String[]{"w", "t"}, *, >=0) = "wcte"
 *  (example of how it repeats)
 *  StringUtils.replaceEach("abcde", new String[]{"ab", "d"}, new String[]{"d", "t"}, false, >=0) = "dcte"
 *  StringUtils.replaceEach("abcde", new String[]{"ab", "d"}, new String[]{"d", "t"}, true, >=2) = "tcte"
 *  StringUtils.replaceEach("abcde", new String[]{"ab", "d"}, new String[]{"d", "ab"}, *, *) = IllegalStateException
 * </pre>
 *
 * @param text
 *            text to mos.search and replace in, no-op if null
 * @param searchList
 *            the Strings to mos.search for, no-op if null
 * @param replacementList
 *            the Strings to replace them with, no-op if null
 * @param repeat if true, then replace repeatedly
 *       until there are no more possible replacements or timeToLive < 0
 * @param timeToLive
 *            if less than 0 then there is a circular reference and endless
 *            loop
 * @return the text with any replacements processed, {@code null} if
 *         null String input
 * @throws IllegalStateException
 *             if the mos.search is repeating and there is an endless loop due
 *             to outputs of one being inputs to another
 * @throws IllegalArgumentException
 *             if the lengths of the arrays are not the same (null is ok,
 *             and/or size 0)
 * @since 2.4
 */
private static String replaceEach(final String text, final String[] searchList, final String[] replacementList, final boolean repeat, final int timeToLive) {
    if (isEmpty(text) || ArrayUtils.isEmpty(searchList) || ArrayUtils.isEmpty(replacementList)) {
        return text;
    }
    // if recursing, this shouldn't be less than 0
    if (timeToLive < 0) {
        throw new IllegalStateException("Aborting to protect against StackOverflowError - " + "output of one loop is the input of another");
    }
    final int searchLength = searchList.length;
    final int replacementLength = replacementList.length;
    // make sure lengths are ok, these need to be equal
    if (searchLength != replacementLength) {
        throw new IllegalArgumentException("Search and Replace array lengths don't match: " + searchLength + " vs " + replacementLength);
    }
    // keep track of which still have matches
    final boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];
    // index on index that the match was found
    int textIndex = -1;
    int replaceIndex = -1;
    int tempIndex = -1;
    // NOTE: logic duplicated below START
    for (int i = 0; i < searchLength; i++) {
        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) {
            continue;
        }
        tempIndex = text.indexOf(searchList[i]);
        // see if we need to keep searching for this
        if (tempIndex == -1) {
            noMoreMatchesForReplIndex[i] = true;
        } else {
            if (textIndex == -1 || tempIndex < textIndex) {
                textIndex = tempIndex;
                replaceIndex = i;
            }
        }
    }
    // no mos.search strings found, we are done
    if (textIndex == -1) {
        return text;
    }
    int start = 0;
    // get a good guess on the size of the result buffer so it doesn't have to double if it goes over a bit
    int increase = 0;
    // count the replacement text elements that are larger than their corresponding text being replaced
    for (int i = 0; i < searchList.length; i++) {
        if (searchList[i] == null || replacementList[i] == null) {
            continue;
        }
        final int greater = replacementList[i].length() - searchList[i].length();
        if (greater > 0) {
            // assume 3 matches
            increase += 3 * greater;
        }
    }
    // have upper-bound at 20% increase, then let Java take over
    increase = Math.min(increase, text.length() / 5);
    final StringBuilder buf = new StringBuilder(text.length() + increase);
    while (textIndex != -1) {
        for (int i = start; i < textIndex; i++) {
            buf.append(text.charAt(i));
        }
        buf.append(replacementList[replaceIndex]);
        start = textIndex + searchList[replaceIndex].length();
        textIndex = -1;
        replaceIndex = -1;
        tempIndex = -1;
        // NOTE: logic mostly duplicated above START
        for (int i = 0; i < searchLength; i++) {
            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) {
                continue;
            }
            tempIndex = text.indexOf(searchList[i], start);
            // see if we need to keep searching for this
            if (tempIndex == -1) {
                noMoreMatchesForReplIndex[i] = true;
            } else {
                if (textIndex == -1 || tempIndex < textIndex) {
                    textIndex = tempIndex;
                    replaceIndex = i;
                }
            }
        }
    // NOTE: logic duplicated above END
    }
    final int textLength = text.length();
    for (int i = start; i < textLength; i++) {
        buf.append(text.charAt(i));
    }
    final String result = buf.toString();
    if (!repeat) {
        return result;
    }
    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);
}
*********************************

#### Score: 29.61241


/**
 * <p>Truncates a String. This will turn
 * "Now is the time for all good men" into "is the time for all".</p>
 *
 * <p>Works like {@code truncate(String, int)}, but allows you to specify
 * a "left edge" offset.
 *
 * <p>Specifically:</p>
 * <ul>
 *   <li>If {@code str} is less than {@code maxWidth} characters
 *       long, return it.</li>
 *   <li>Else truncate it to {@code substring(str, offset, maxWidth)}.</li>
 *   <li>If {@code maxWidth} is less than {@code 0}, throw an
 *       {@code IllegalArgumentException}.</li>
 *   <li>If {@code offset} is less than {@code 0}, throw an
 *       {@code IllegalArgumentException}.</li>
 *   <li>In no case will it return a String of length greater than
 *       {@code maxWidth}.</li>
 * </ul>
 *
 * <pre>
 * StringUtils.truncate(null, 0, 0) = null
 * StringUtils.truncate(null, 2, 4) = null
 * StringUtils.truncate("", 0, 10) = ""
 * StringUtils.truncate("", 2, 10) = ""
 * StringUtils.truncate("abcdefghij", 0, 3) = "abc"
 * StringUtils.truncate("abcdefghij", 5, 6) = "fghij"
 * StringUtils.truncate("raspberry peach", 10, 15) = "peach"
 * StringUtils.truncate("abcdefghijklmno", 0, 10) = "abcdefghij"
 * StringUtils.truncate("abcdefghijklmno", -1, 10) = throws an IllegalArgumentException
 * StringUtils.truncate("abcdefghijklmno", Integer.MIN_VALUE, 10) = throws an IllegalArgumentException
 * StringUtils.truncate("abcdefghijklmno", Integer.MIN_VALUE, Integer.MAX_VALUE) = throws an IllegalArgumentException
 * StringUtils.truncate("abcdefghijklmno", 0, Integer.MAX_VALUE) = "abcdefghijklmno"
 * StringUtils.truncate("abcdefghijklmno", 1, 10) = "bcdefghijk"
 * StringUtils.truncate("abcdefghijklmno", 2, 10) = "cdefghijkl"
 * StringUtils.truncate("abcdefghijklmno", 3, 10) = "defghijklm"
 * StringUtils.truncate("abcdefghijklmno", 4, 10) = "efghijklmn"
 * StringUtils.truncate("abcdefghijklmno", 5, 10) = "fghijklmno"
 * StringUtils.truncate("abcdefghijklmno", 5, 5) = "fghij"
 * StringUtils.truncate("abcdefghijklmno", 5, 3) = "fgh"
 * StringUtils.truncate("abcdefghijklmno", 10, 3) = "klm"
 * StringUtils.truncate("abcdefghijklmno", 10, Integer.MAX_VALUE) = "klmno"
 * StringUtils.truncate("abcdefghijklmno", 13, 1) = "n"
 * StringUtils.truncate("abcdefghijklmno", 13, Integer.MAX_VALUE) = "no"
 * StringUtils.truncate("abcdefghijklmno", 14, 1) = "o"
 * StringUtils.truncate("abcdefghijklmno", 14, Integer.MAX_VALUE) = "o"
 * StringUtils.truncate("abcdefghijklmno", 15, 1) = ""
 * StringUtils.truncate("abcdefghijklmno", 15, Integer.MAX_VALUE) = ""
 * StringUtils.truncate("abcdefghijklmno", Integer.MAX_VALUE, Integer.MAX_VALUE) = ""
 * StringUtils.truncate("abcdefghij", 3, -1) = throws an IllegalArgumentException
 * StringUtils.truncate("abcdefghij", -2, 4) = throws an IllegalArgumentException
 * </pre>
 *
 * @param str  the String to truncate, may be null
 * @param offset  left edge of source String
 * @param maxWidth  maximum length of result String, must be positive
 * @return truncated String, {@code null} if null String input
 * @throws IllegalArgumentException If {@code offset} or {@code maxWidth} is less than {@code 0}
 * @since 3.5
 */
public static String truncate(final String str, final int offset, final int maxWidth) {
    if (offset < 0) {
        throw new IllegalArgumentException("offset cannot be negative");
    }
    if (maxWidth < 0) {
        throw new IllegalArgumentException("maxWith cannot be negative");
    }
    if (str == null) {
        return null;
    }
    if (offset > str.length()) {
        return EMPTY;
    }
    if (str.length() > maxWidth) {
        final int ix = offset + maxWidth > str.length() ? str.length() : offset + maxWidth;
        return str.substring(offset, ix);
    }
    return str.substring(offset);
}
*********************************

#### Score: 29.42601


/**
 * <p>Compare two Strings lexicographically, ignoring case differences,
 * as per {@link String#compareToIgnoreCase(String)}, returning :</p>
 * <ul>
 *  <li>{@code int = 0}, if {@code str1} is equal to {@code str2} (or both {@code null})</li>
 *  <li>{@code int < 0}, if {@code str1} is less than {@code str2}</li>
 *  <li>{@code int > 0}, if {@code str1} is greater than {@code str2}</li>
 * </ul>
 *
 * <p>This is a {@code null} safe version of :</p>
 * <blockquote><pre>str1.compareToIgnoreCase(str2)</pre></blockquote>
 *
 * <p>{@code null} inputs are handled according to the {@code nullIsLess} parameter.
 * Two {@code null} references are considered equal.
 * Comparison is case insensitive.</p>
 *
 * <pre>
 * StringUtils.compareIgnoreCase(null, null, *)     = 0
 * StringUtils.compareIgnoreCase(null , "a", true)  &lt; 0
 * StringUtils.compareIgnoreCase(null , "a", false) &gt; 0
 * StringUtils.compareIgnoreCase("a", null, true)   &gt; 0
 * StringUtils.compareIgnoreCase("a", null, false)  &lt; 0
 * StringUtils.compareIgnoreCase("abc", "abc", *)   = 0
 * StringUtils.compareIgnoreCase("abc", "ABC", *)   = 0
 * StringUtils.compareIgnoreCase("a", "b", *)       &lt; 0
 * StringUtils.compareIgnoreCase("b", "a", *)       &gt; 0
 * StringUtils.compareIgnoreCase("a", "B", *)       &lt; 0
 * StringUtils.compareIgnoreCase("A", "b", *)       &lt; 0
 * StringUtils.compareIgnoreCase("ab", "abc", *)    &lt; 0
 * </pre>
 *
 * @see String#compareToIgnoreCase(String)
 * @param str1  the String to compare from
 * @param str2  the String to compare to
 * @param nullIsLess  whether consider {@code null} value less than non-{@code null} value
 * @return &lt; 0, 0, &gt; 0, if {@code str1} is respectively less, equal ou greater than {@code str2},
 *          ignoring case differences.
 * @since 3.5
 */
public static int compareIgnoreCase(final String str1, final String str2, final boolean nullIsLess) {
    if (str1 == str2) {
        return 0;
    }
    if (str1 == null) {
        return nullIsLess ? -1 : 1;
    }
    if (str2 == null) {
        return nullIsLess ? 1 : -1;
    }
    return str1.compareToIgnoreCase(str2);
}
*********************************

#### Score: 29.42601


/**
 * <p>Compare two Strings lexicographically, as per {@link String#compareTo(String)}, returning :</p>
 * <ul>
 *  <li>{@code int = 0}, if {@code str1} is equal to {@code str2} (or both {@code null})</li>
 *  <li>{@code int < 0}, if {@code str1} is less than {@code str2}</li>
 *  <li>{@code int > 0}, if {@code str1} is greater than {@code str2}</li>
 * </ul>
 *
 * <p>This is a {@code null} safe version of :</p>
 * <blockquote><pre>str1.compareTo(str2)</pre></blockquote>
 *
 * <p>{@code null} inputs are handled according to the {@code nullIsLess} parameter.
 * Two {@code null} references are considered equal.</p>
 *
 * <pre>
 * StringUtils.compare(null, null, *)     = 0
 * StringUtils.compare(null , "a", true)  &lt; 0
 * StringUtils.compare(null , "a", false) &gt; 0
 * StringUtils.compare("a", null, true)   &gt; 0
 * StringUtils.compare("a", null, false)  &lt; 0
 * StringUtils.compare("abc", "abc", *)   = 0
 * StringUtils.compare("a", "b", *)       &lt; 0
 * StringUtils.compare("b", "a", *)       &gt; 0
 * StringUtils.compare("a", "B", *)       &gt; 0
 * StringUtils.compare("ab", "abc", *)    &lt; 0
 * </pre>
 *
 * @see String#compareTo(String)
 * @param str1  the String to compare from
 * @param str2  the String to compare to
 * @param nullIsLess  whether consider {@code null} value less than non-{@code null} value
 * @return &lt; 0, 0, &gt; 0, if {@code str1} is respectively less, equal ou greater than {@code str2}
 * @since 3.5
 */
public static int compare(final String str1, final String str2, final boolean nullIsLess) {
    if (str1 == str2) {
        return 0;
    }
    if (str1 == null) {
        return nullIsLess ? -1 : 1;
    }
    if (str2 == null) {
        return nullIsLess ? 1 : -1;
    }
    return str1.compareTo(str2);
}
*********************************

#### Score: 29.41829


/**
 * <p>
 * Similar to <a
 * href="http://www.w3.org/TR/xpath/#function-normalize-space">http://www.w3.org/TR/xpath/#function-normalize
 * -space</a>
 * </p>
 * <p>
 * The function returns the argument string with whitespace normalized by using
 * <code>{@link #trim(String)}</code> to remove leading and trailing whitespace
 * and then replacing sequences of whitespace characters by a single space.
 * </p>
 * In XML Whitespace characters are the same as those allowed by the <a
 * href="http://www.w3.org/TR/REC-xml/#NT-S">S</a> production, which is S ::= (#x20 | #x9 | #xD | #xA)+
 * <p>
 * Java's regexp pattern \s defines whitespace as [ \t\n\x0B\f\r]
 *
 * <p>For reference:</p>
 * <ul>
 * <li>\x0B = vertical tab</li>
 * <li>\f = #xC = form feed</li>
 * <li>#x20 = space</li>
 * <li>#x9 = \t</li>
 * <li>#xA = \n</li>
 * <li>#xD = \r</li>
 * </ul>
 *
 * <p>
 * The difference is that Java's whitespace includes vertical tab and form feed, which this functional will also
 * normalize. Additionally <code>{@link #trim(String)}</code> removes control characters (char &lt;= 32) from both
 * ends of this String.
 * </p>
 *
 * @see Pattern
 * @see #trim(String)
 * @see <a
 *      href="http://www.w3.org/TR/xpath/#function-normalize-space">http://www.w3.org/TR/xpath/#function-normalize-space</a>
 * @param str the source String to normalize whitespaces from, may be null
 * @return the modified string with whitespace normalized, {@code null} if null String input
 *
 * @since 3.0
 */
public static String normalizeSpace(final String str) {
    // See https://github.com/librucha/commons-lang-normalizespaces-benchmark for performance test
    if (isEmpty(str)) {
        return str;
    }
    final int size = str.length();
    final char[] newChars = new char[size];
    int count = 0;
    int whitespacesCount = 0;
    boolean startWhitespaces = true;
    for (int i = 0; i < size; i++) {
        final char actualChar = str.charAt(i);
        final boolean isWhitespace = Character.isWhitespace(actualChar);
        if (isWhitespace) {
            if (whitespacesCount == 0 && !startWhitespaces) {
                newChars[count++] = SPACE.charAt(0);
            }
            whitespacesCount++;
        } else {
            startWhitespaces = false;
            newChars[count++] = (actualChar == 160 ? 32 : actualChar);
            whitespacesCount = 0;
        }
    }
    if (startWhitespaces) {
        return EMPTY;
    }
    return new String(newChars, 0, count - (whitespacesCount > 0 ? 1 : 0)).trim();
}
*********************************

#### Score: 29.37683


/**
 * <p>Compares all Strings in an array and returns the initial sequence of
 * characters that is common to all of them.</p>
 *
 * <p>For example,
 * <code>getCommonPrefix(new String[] {"i am a machine", "i am a robot"}) -&gt; "i am a "</code></p>
 *
 * <pre>
 * StringUtils.getCommonPrefix(null) = ""
 * StringUtils.getCommonPrefix(new String[] {}) = ""
 * StringUtils.getCommonPrefix(new String[] {"abc"}) = "abc"
 * StringUtils.getCommonPrefix(new String[] {null, null}) = ""
 * StringUtils.getCommonPrefix(new String[] {"", ""}) = ""
 * StringUtils.getCommonPrefix(new String[] {"", null}) = ""
 * StringUtils.getCommonPrefix(new String[] {"abc", null, null}) = ""
 * StringUtils.getCommonPrefix(new String[] {null, null, "abc"}) = ""
 * StringUtils.getCommonPrefix(new String[] {"", "abc"}) = ""
 * StringUtils.getCommonPrefix(new String[] {"abc", ""}) = ""
 * StringUtils.getCommonPrefix(new String[] {"abc", "abc"}) = "abc"
 * StringUtils.getCommonPrefix(new String[] {"abc", "a"}) = "a"
 * StringUtils.getCommonPrefix(new String[] {"ab", "abxyz"}) = "ab"
 * StringUtils.getCommonPrefix(new String[] {"abcde", "abxyz"}) = "ab"
 * StringUtils.getCommonPrefix(new String[] {"abcde", "xyz"}) = ""
 * StringUtils.getCommonPrefix(new String[] {"xyz", "abcde"}) = ""
 * StringUtils.getCommonPrefix(new String[] {"i am a machine", "i am a robot"}) = "i am a "
 * </pre>
 *
 * @param strs  array of String objects, entries may be null
 * @return the initial sequence of characters that are common to all Strings
 * in the array; empty String if the array is null, the elements are all null
 * or if there is no common prefix.
 * @since 2.4
 */
public static String getCommonPrefix(final String... strs) {
    if (ArrayUtils.isEmpty(strs)) {
        return EMPTY;
    }
    final int smallestIndexOfDiff = indexOfDifference(strs);
    if (smallestIndexOfDiff == INDEX_NOT_FOUND) {
        // all strings were identical
        if (strs[0] == null) {
            return EMPTY;
        }
        return strs[0];
    } else if (smallestIndexOfDiff == 0) {
        // there were no common initial characters
        return EMPTY;
    } else {
        // we found a common initial character sequence
        return strs[0].substring(0, smallestIndexOfDiff);
    }
}