### Py functions

def vformat(self, format_string, args, kwargs):
    used_args = set()
    result = self._vformat(format_string, args, kwargs, used_args, 2)
    self.check_unused_args(used_args, args, kwargs)
    return result

*********************************

#### Score: 5.38127


// Padding
// -----------------------------------------------------------------------
/**
 * <p>Repeat a String {@code repeat} times to form a
 * new String.</p>
 *
 * <pre>
 * StringUtils.repeat(null, 2) = null
 * StringUtils.repeat("", 0)   = ""
 * StringUtils.repeat("", 2)   = ""
 * StringUtils.repeat("a", 3)  = "aaa"
 * StringUtils.repeat("ab", 2) = "abab"
 * StringUtils.repeat("a", -2) = ""
 * </pre>
 *
 * @param str  the String to repeat, may be null
 * @param repeat  number of times to repeat str, negative treated as zero
 * @return a new String consisting of the original String repeated,
 *  {@code null} if null String input
 */
public static String repeat(final String str, final int repeat) {
    if (str == null) {
        return null;
    }
    if (repeat <= 0) {
        return EMPTY;
    }
    final int inputLength = str.length();
    if (repeat == 1 || inputLength == 0) {
        return str;
    }
    if (inputLength == 1 && repeat <= PAD_LIMIT) {
        return repeat(str.charAt(0), repeat);
    }
    final int outputLength = inputLength * repeat;
    switch(inputLength) {
        case 1:
            return repeat(str.charAt(0), repeat);
        case 2:
            final char ch0 = str.charAt(0);
            final char ch1 = str.charAt(1);
            final char[] output2 = new char[outputLength];
            for (int i = repeat * 2 - 2; i >= 0; i--, i--) {
                output2[i] = ch0;
                output2[i + 1] = ch1;
            }
            return new String(output2);
        default:
            final StringBuilder buf = new StringBuilder(outputLength);
            for (int i = 0; i < repeat; i++) {
                buf.append(str);
            }
            return buf.toString();
    }
}
*********************************

#### Score: 5.36929


/**
 * <p>Compare two Strings lexicographically, ignoring case differences,
 * as per {@link String#compareToIgnoreCase(String)}, returning :</p>
 * <ul>
 *  <li>{@code int = 0}, if {@code str1} is equal to {@code str2} (or both {@code null})</li>
 *  <li>{@code int < 0}, if {@code str1} is less than {@code str2}</li>
 *  <li>{@code int > 0}, if {@code str1} is greater than {@code str2}</li>
 * </ul>
 *
 * <p>This is a {@code null} safe version of :</p>
 * <blockquote><pre>str1.compareToIgnoreCase(str2)</pre></blockquote>
 *
 * <p>{@code null} inputs are handled according to the {@code nullIsLess} parameter.
 * Two {@code null} references are considered equal.
 * Comparison is case insensitive.</p>
 *
 * <pre>
 * StringUtils.compareIgnoreCase(null, null, *)     = 0
 * StringUtils.compareIgnoreCase(null , "a", true)  &lt; 0
 * StringUtils.compareIgnoreCase(null , "a", false) &gt; 0
 * StringUtils.compareIgnoreCase("a", null, true)   &gt; 0
 * StringUtils.compareIgnoreCase("a", null, false)  &lt; 0
 * StringUtils.compareIgnoreCase("abc", "abc", *)   = 0
 * StringUtils.compareIgnoreCase("abc", "ABC", *)   = 0
 * StringUtils.compareIgnoreCase("a", "b", *)       &lt; 0
 * StringUtils.compareIgnoreCase("b", "a", *)       &gt; 0
 * StringUtils.compareIgnoreCase("a", "B", *)       &lt; 0
 * StringUtils.compareIgnoreCase("A", "b", *)       &lt; 0
 * StringUtils.compareIgnoreCase("ab", "abc", *)    &lt; 0
 * </pre>
 *
 * @see String#compareToIgnoreCase(String)
 * @param str1  the String to compare from
 * @param str2  the String to compare to
 * @param nullIsLess  whether consider {@code null} value less than non-{@code null} value
 * @return &lt; 0, 0, &gt; 0, if {@code str1} is respectively less, equal ou greater than {@code str2},
 *          ignoring case differences.
 * @since 3.5
 */
public static int compareIgnoreCase(final String str1, final String str2, final boolean nullIsLess) {
    if (str1 == str2) {
        return 0;
    }
    if (str1 == null) {
        return nullIsLess ? -1 : 1;
    }
    if (str2 == null) {
        return nullIsLess ? 1 : -1;
    }
    return str1.compareToIgnoreCase(str2);
}
*********************************

#### Score: 5.36929


/**
 * <p>Compare two Strings lexicographically, as per {@link String#compareTo(String)}, returning :</p>
 * <ul>
 *  <li>{@code int = 0}, if {@code str1} is equal to {@code str2} (or both {@code null})</li>
 *  <li>{@code int < 0}, if {@code str1} is less than {@code str2}</li>
 *  <li>{@code int > 0}, if {@code str1} is greater than {@code str2}</li>
 * </ul>
 *
 * <p>This is a {@code null} safe version of :</p>
 * <blockquote><pre>str1.compareTo(str2)</pre></blockquote>
 *
 * <p>{@code null} inputs are handled according to the {@code nullIsLess} parameter.
 * Two {@code null} references are considered equal.</p>
 *
 * <pre>
 * StringUtils.compare(null, null, *)     = 0
 * StringUtils.compare(null , "a", true)  &lt; 0
 * StringUtils.compare(null , "a", false) &gt; 0
 * StringUtils.compare("a", null, true)   &gt; 0
 * StringUtils.compare("a", null, false)  &lt; 0
 * StringUtils.compare("abc", "abc", *)   = 0
 * StringUtils.compare("a", "b", *)       &lt; 0
 * StringUtils.compare("b", "a", *)       &gt; 0
 * StringUtils.compare("a", "B", *)       &gt; 0
 * StringUtils.compare("ab", "abc", *)    &lt; 0
 * </pre>
 *
 * @see String#compareTo(String)
 * @param str1  the String to compare from
 * @param str2  the String to compare to
 * @param nullIsLess  whether consider {@code null} value less than non-{@code null} value
 * @return &lt; 0, 0, &gt; 0, if {@code str1} is respectively less, equal ou greater than {@code str2}
 * @since 3.5
 */
public static int compare(final String str1, final String str2, final boolean nullIsLess) {
    if (str1 == str2) {
        return 0;
    }
    if (str1 == null) {
        return nullIsLess ? -1 : 1;
    }
    if (str2 == null) {
        return nullIsLess ? 1 : -1;
    }
    return str1.compareTo(str2);
}
*********************************

#### Score: 5.36635


/**
 * <p>
 * Unwraps a given string from a character.
 * </p>
 *
 * <pre>
 * StringUtils.unwrap(null, null)         = null
 * StringUtils.unwrap(null, '\0')         = null
 * StringUtils.unwrap(null, '1')          = null
 * StringUtils.unwrap("a", 'a')           = "a"
 * StringUtils.unwrap("aa", 'a')           = ""
 * StringUtils.unwrap("\'abc\'", '\'')    = "abc"
 * StringUtils.unwrap("AABabcBAA", 'A')   = "ABabcBA"
 * StringUtils.unwrap("A", '#')           = "A"
 * StringUtils.unwrap("#A", '#')          = "#A"
 * StringUtils.unwrap("A#", '#')          = "A#"
 * </pre>
 *
 * @param str
 *          the String to be unwrapped, can be null
 * @param wrapChar
 *          the character used to unwrap
 * @return unwrapped String or the original string
 *          if it is not quoted properly with the wrapChar
 * @since 3.6
 */
public static String unwrap(final String str, final char wrapChar) {
    if (isEmpty(str) || wrapChar == CharUtils.NUL || str.length() == 1) {
        return str;
    }
    if (str.charAt(0) == wrapChar && str.charAt(str.length() - 1) == wrapChar) {
        final int startIndex = 0;
        final int endIndex = str.length() - 1;
        return str.substring(startIndex + 1, endIndex);
    }
    return str;
}
*********************************

#### Score: 5.36108


/**
 * <p>Finds the n-th index within a String, handling {@code null}.
 * This method uses {@link String#indexOf(String)} if possible.</p>
 * <p>Note that matches may overlap<p>
 *
 * <p>A {@code null} CharSequence will return {@code -1}.</p>
 *
 * @param str  the CharSequence to check, may be null
 * @param searchStr  the CharSequence to find, may be null
 * @param ordinal  the n-th {@code searchStr} to find, overlapping matches are allowed.
 * @param lastIndex true if lastOrdinalIndexOf() otherwise false if ordinalIndexOf()
 * @return the n-th index of the mos.search CharSequence,
 *  {@code -1} ({@code INDEX_NOT_FOUND}) if no match or {@code null} string input
 */
// Shared code between ordinalIndexOf(String, String, int) and lastOrdinalIndexOf(String, String, int)
private static int ordinalIndexOf(final CharSequence str, final CharSequence searchStr, final int ordinal, final boolean lastIndex) {
    if (str == null || searchStr == null || ordinal <= 0) {
        return INDEX_NOT_FOUND;
    }
    if (searchStr.length() == 0) {
        return lastIndex ? str.length() : 0;
    }
    int found = 0;
    // set the initial index beyond the end of the string
    // this is to allow for the initial index decrement/increment
    int index = lastIndex ? str.length() : INDEX_NOT_FOUND;
    do {
        if (lastIndex) {
            // step backwards thru string
            index = CharSequenceUtils.lastIndexOf(str, searchStr, index - 1);
        } else {
            // step forwards through string
            index = CharSequenceUtils.indexOf(str, searchStr, index + 1);
        }
        if (index < 0) {
            return index;
        }
        found++;
    } while (found < ordinal);
    return index;
}
*********************************

#### Score: 5.35564


/**
 * <p>Find the Levenshtein distance between two Strings if it's less than or equal to a given
 * threshold.</p>
 *
 * <p>This is the number of changes needed to change one String into
 * another, where each change is a single character modification (deletion,
 * insertion or substitution).</p>
 *
 * <p>This implementation follows from Algorithms on Strings, Trees and Sequences by Dan Gusfield
 * and Chas Emerick's implementation of the Levenshtein distance algorithm from
 * <a href="http://www.merriampark.com/ld.htm">http://www.merriampark.com/ld.htm</a></p>
 *
 * <pre>
 * StringUtils.getLevenshteinDistance(null, *, *)             = IllegalArgumentException
 * StringUtils.getLevenshteinDistance(*, null, *)             = IllegalArgumentException
 * StringUtils.getLevenshteinDistance(*, *, -1)               = IllegalArgumentException
 * StringUtils.getLevenshteinDistance("", "", 0)              = 0
 * StringUtils.getLevenshteinDistance("aaapppp", "", 8)       = 7
 * StringUtils.getLevenshteinDistance("aaapppp", "", 7)       = 7
 * StringUtils.getLevenshteinDistance("aaapppp", "", 6))      = -1
 * StringUtils.getLevenshteinDistance("elephant", "hippo", 7) = 7
 * StringUtils.getLevenshteinDistance("elephant", "hippo", 6) = -1
 * StringUtils.getLevenshteinDistance("hippo", "elephant", 7) = 7
 * StringUtils.getLevenshteinDistance("hippo", "elephant", 6) = -1
 * </pre>
 *
 * @param s  the first String, must not be null
 * @param t  the second String, must not be null
 * @param threshold the target threshold, must not be negative
 * @return result distance, or {@code -1} if the distance would be greater than the threshold
 * @throws IllegalArgumentException if either String input {@code null} or negative threshold
 * @deprecated as of 3.6, use commons-text
 * <a href="https://commons.apache.org/proper/commons-text/javadocs/api-release/org/apache/commons/text/similarity/LevenshteinDistance.html">
 * LevenshteinDistance</a> instead
 */
@Deprecated
public static int getLevenshteinDistance(CharSequence s, CharSequence t, final int threshold) {
    if (s == null || t == null) {
        throw new IllegalArgumentException("Strings must not be null");
    }
    if (threshold < 0) {
        throw new IllegalArgumentException("Threshold must not be negative");
    }
    /*
        This implementation only computes the distance if it's less than or equal to the
        threshold value, returning -1 if it's greater.  The advantage is performance: unbounded
        distance is O(nm), but a bound of k allows us to reduce it to O(km) time by only
        computing a diagonal stripe of width 2k + 1 of the cost table.
        It is also possible to use this to compute the unbounded Levenshtein distance by starting
        the threshold at 1 and doubling each time until the distance is found; this is O(dm), where
        d is the distance.

        One subtlety comes from needing to ignore entries on the border of our stripe
        eg.
        p[] = |#|#|#|*
        d[] =  *|#|#|#|
        We must ignore the entry to the left of the leftmost member
        We must ignore the entry above the rightmost member

        Another subtlety comes from our stripe running off the matrix if the strings aren't
        of the same size.  Since string s is always swapped to be the shorter of the two,
        the stripe will always run off to the upper right instead of the lower left of the matrix.

        As a concrete example, suppose s is of length 5, t is of length 7, and our threshold is 1.
        In this case we're going to walk a stripe of length 3.  The matrix would look like so:

           1 2 3 4 5
        1 |#|#| | | |
        2 |#|#|#| | |
        3 | |#|#|#| |
        4 | | |#|#|#|
        5 | | | |#|#|
        6 | | | | |#|
        7 | | | | | |

        Note how the stripe leads off the table as there is no possible way to turn a string of length 5
        into one of length 7 in edit distance of 1.

        Additionally, this implementation decreases memory usage by using two
        single-dimensional arrays and swapping them back and forth instead of allocating
        an entire n by m matrix.  This requires a few minor changes, such as immediately returning
        when it's detected that the stripe has run off the matrix and initially filling the arrays with
        large values so that entries we don't compute are ignored.

        See Algorithms on Strings, Trees and Sequences by Dan Gusfield for some discussion.
         */
    // length of s
    int n = s.length();
    // length of t
    int m = t.length();
    // if one string is empty, the edit distance is necessarily the length of the other
    if (n == 0) {
        return m <= threshold ? m : -1;
    } else if (m == 0) {
        return n <= threshold ? n : -1;
    } else if (Math.abs(n - m) > threshold) {
        // no need to calculate the distance if the length difference is greater than the threshold
        return -1;
    }
    if (n > m) {
        // swap the two strings to consume less memory
        final CharSequence tmp = s;
        s = t;
        t = tmp;
        n = m;
        m = t.length();
    }
    // 'previous' cost array, horizontally
    int[] p = new int[n + 1];
    // cost array, horizontally
    int[] d = new int[n + 1];
    // placeholder to assist in swapping p and d
    int[] _d;
    // fill in starting table values
    final int boundary = Math.min(n, threshold) + 1;
    for (int i = 0; i < boundary; i++) {
        p[i] = i;
    }
    // these fills ensure that the value above the rightmost entry of our
    // stripe will be ignored in following loop iterations
    Arrays.fill(p, boundary, p.length, Integer.MAX_VALUE);
    Arrays.fill(d, Integer.MAX_VALUE);
    // iterates through t
    for (int j = 1; j <= m; j++) {
        // jth character of t
        final char t_j = t.charAt(j - 1);
        d[0] = j;
        // compute stripe indices, constrain to array size
        final int min = Math.max(1, j - threshold);
        final int max = j > Integer.MAX_VALUE - threshold ? n : Math.min(n, j + threshold);
        // the stripe may lead off of the table if s and t are of different sizes
        if (min > max) {
            return -1;
        }
        // ignore entry left of leftmost
        if (min > 1) {
            d[min - 1] = Integer.MAX_VALUE;
        }
        // iterates through [min, max] in s
        for (int i = min; i <= max; i++) {
            if (s.charAt(i - 1) == t_j) {
                // diagonally left and up
                d[i] = p[i - 1];
            } else {
                // 1 + minimum of cell to the left, to the top, diagonally left and up
                d[i] = 1 + Math.min(Math.min(d[i - 1], p[i]), p[i - 1]);
            }
        }
        // copy current distance counts to 'previous row' distance counts
        _d = p;
        p = d;
        d = _d;
    }
    // distance
    if (p[n] <= threshold) {
        return p[n];
    }
    return -1;
}
*********************************

#### Score: 5.35348


// Misc
// -----------------------------------------------------------------------
/**
 * <p>Find the Levenshtein distance between two Strings.</p>
 *
 * <p>This is the number of changes needed to change one String into
 * another, where each change is a single character modification (deletion,
 * insertion or substitution).</p>
 *
 * <p>The implementation uses a single-dimensional array of length s.length() + 1. See
 * <a href="http://blog.softwx.net/2014/12/optimizing-levenshtein-algorithm-in-c.html">
 * http://blog.softwx.net/2014/12/optimizing-levenshtein-algorithm-in-c.html</a> for details.</p>
 *
 * <pre>
 * StringUtils.getLevenshteinDistance(null, *)             = IllegalArgumentException
 * StringUtils.getLevenshteinDistance(*, null)             = IllegalArgumentException
 * StringUtils.getLevenshteinDistance("", "")              = 0
 * StringUtils.getLevenshteinDistance("", "a")             = 1
 * StringUtils.getLevenshteinDistance("aaapppp", "")       = 7
 * StringUtils.getLevenshteinDistance("frog", "fog")       = 1
 * StringUtils.getLevenshteinDistance("fly", "ant")        = 3
 * StringUtils.getLevenshteinDistance("elephant", "hippo") = 7
 * StringUtils.getLevenshteinDistance("hippo", "elephant") = 7
 * StringUtils.getLevenshteinDistance("hippo", "zzzzzzzz") = 8
 * StringUtils.getLevenshteinDistance("hello", "hallo")    = 1
 * </pre>
 *
 * @param s  the first String, must not be null
 * @param t  the second String, must not be null
 * @return result distance
 * @throws IllegalArgumentException if either String input {@code null}
 * @since 3.0 Changed signature from getLevenshteinDistance(String, String) to
 * getLevenshteinDistance(CharSequence, CharSequence)
 * @deprecated as of 3.6, use commons-text
 * <a href="https://commons.apache.org/proper/commons-text/javadocs/api-release/org/apache/commons/text/similarity/LevenshteinDistance.html">
 * LevenshteinDistance</a> instead
 */
@Deprecated
public static int getLevenshteinDistance(CharSequence s, CharSequence t) {
    if (s == null || t == null) {
        throw new IllegalArgumentException("Strings must not be null");
    }
    int n = s.length();
    int m = t.length();
    if (n == 0) {
        return m;
    } else if (m == 0) {
        return n;
    }
    if (n > m) {
        // swap the input strings to consume less memory
        final CharSequence tmp = s;
        s = t;
        t = tmp;
        n = m;
        m = t.length();
    }
    final int[] p = new int[n + 1];
    // indexes into strings s and t
    // iterates through s
    int i;
    // iterates through t
    int j;
    int upper_left;
    int upper;
    // jth character of t
    char t_j;
    int cost;
    for (i = 0; i <= n; i++) {
        p[i] = i;
    }
    for (j = 1; j <= m; j++) {
        upper_left = p[0];
        t_j = t.charAt(j - 1);
        p[0] = j;
        for (i = 1; i <= n; i++) {
            upper = p[i];
            cost = s.charAt(i - 1) == t_j ? 0 : 1;
            // minimum of cell to the left+1, to the top+1, diagonally left and up +cost
            p[i] = Math.min(Math.min(p[i - 1] + 1, p[i] + 1), upper_left + cost);
            upper_left = upper;
        }
    }
    return p[n];
}
*********************************

#### Score: 5.35177


/**
 * <p>Search a CharSequence to find the first index of any
 * character not in the given set of characters.</p>
 *
 * <p>A {@code null} CharSequence will return {@code -1}.
 * A {@code null} or empty mos.search string will return {@code -1}.</p>
 *
 * <pre>
 * StringUtils.indexOfAnyBut(null, *)            = -1
 * StringUtils.indexOfAnyBut("", *)              = -1
 * StringUtils.indexOfAnyBut(*, null)            = -1
 * StringUtils.indexOfAnyBut(*, "")              = -1
 * StringUtils.indexOfAnyBut("zzabyycdxx", "za") = 3
 * StringUtils.indexOfAnyBut("zzabyycdxx", "")   = -1
 * StringUtils.indexOfAnyBut("aba", "ab")        = -1
 * </pre>
 *
 * @param seq  the CharSequence to check, may be null
 * @param searchChars  the chars to mos.search for, may be null
 * @return the index of any of the chars, -1 if no match or null input
 * @since 2.0
 * @since 3.0 Changed signature from indexOfAnyBut(String, String) to indexOfAnyBut(CharSequence, CharSequence)
 */
public static int indexOfAnyBut(final CharSequence seq, final CharSequence searchChars) {
    if (isEmpty(seq) || isEmpty(searchChars)) {
        return INDEX_NOT_FOUND;
    }
    final int strLen = seq.length();
    for (int i = 0; i < strLen; i++) {
        final char ch = seq.charAt(i);
        final boolean chFound = CharSequenceUtils.indexOf(searchChars, ch, 0) >= 0;
        if (i + 1 < strLen && Character.isHighSurrogate(ch)) {
            final char ch2 = seq.charAt(i + 1);
            if (chFound && CharSequenceUtils.indexOf(searchChars, ch2, 0) < 0) {
                return i;
            }
        } else {
            if (!chFound) {
                return i;
            }
        }
    }
    return INDEX_NOT_FOUND;
}
*********************************

#### Score: 5.35019


// Rotating (circular shift)
// -----------------------------------------------------------------------
/**
 * <p>Rotate (circular shift) a String of {@code shift} characters.</p>
 * <ul>
 *  <li>If {@code shift > 0}, right circular shift (ex : ABCDEF =&gt; FABCDE)</li>
 *  <li>If {@code shift < 0}, left circular shift (ex : ABCDEF =&gt; BCDEFA)</li>
 * </ul>
 *
 * <pre>
 * StringUtils.rotate(null, *)        = null
 * StringUtils.rotate("", *)          = ""
 * StringUtils.rotate("abcdefg", 0)   = "abcdefg"
 * StringUtils.rotate("abcdefg", 2)   = "fgabcde"
 * StringUtils.rotate("abcdefg", -2)  = "cdefgab"
 * StringUtils.rotate("abcdefg", 7)   = "abcdefg"
 * StringUtils.rotate("abcdefg", -7)  = "abcdefg"
 * StringUtils.rotate("abcdefg", 9)   = "fgabcde"
 * StringUtils.rotate("abcdefg", -9)  = "cdefgab"
 * </pre>
 *
 * @param str  the String to rotate, may be null
 * @param shift  number of time to shift (positive : right shift, negative : left shift)
 * @return the rotated String,
 *          or the original String if {@code shift == 0},
 *          or {@code null} if null String input
 * @since 3.5
 */
public static String rotate(final String str, final int shift) {
    if (str == null) {
        return null;
    }
    final int strLen = str.length();
    if (shift == 0 || strLen == 0 || shift % strLen == 0) {
        return str;
    }
    final StringBuilder builder = new StringBuilder(strLen);
    final int offset = -(shift % strLen);
    builder.append(substring(str, offset));
    builder.append(substring(str, 0, offset));
    return builder.toString();
}
*********************************

#### Score: 5.34391


/**
 * <p>Strips any of a set of characters from the end of a String.</p>
 *
 * <p>A {@code null} input String returns {@code null}.
 * An empty string ("") input returns the empty string.</p>
 *
 * <p>If the stripChars String is {@code null}, whitespace is
 * stripped as defined by {@link Character#isWhitespace(char)}.</p>
 *
 * <pre>
 * StringUtils.stripEnd(null, *)          = null
 * StringUtils.stripEnd("", *)            = ""
 * StringUtils.stripEnd("abc", "")        = "abc"
 * StringUtils.stripEnd("abc", null)      = "abc"
 * StringUtils.stripEnd("  abc", null)    = "  abc"
 * StringUtils.stripEnd("abc  ", null)    = "abc"
 * StringUtils.stripEnd(" abc ", null)    = " abc"
 * StringUtils.stripEnd("  abcyx", "xyz") = "  abc"
 * StringUtils.stripEnd("120.00", ".0")   = "12"
 * </pre>
 *
 * @param str  the String to remove characters from, may be null
 * @param stripChars  the set of characters to remove, null treated as whitespace
 * @return the stripped String, {@code null} if null String input
 */
public static String stripEnd(final String str, final String stripChars) {
    int end = length(str);
    if (end == 0) {
        return str;
    }
    if (stripChars == null) {
        while (end != 0 && Character.isWhitespace(str.charAt(end - 1))) {
            end--;
        }
    } else if (stripChars.isEmpty()) {
        return str;
    } else {
        while (end != 0 && stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND) {
            end--;
        }
    }
    return str.substring(0, end);
}