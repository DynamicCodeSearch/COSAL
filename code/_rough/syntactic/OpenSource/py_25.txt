### Py functions

def most_common(self, n=None):
    """List the n most common elements and their counts from the most
    common to the least.  If n is None, then list all element counts.

    >>> Counter('abcdeabcdabcaba').most_common(3)
    [('a', 5), ('b', 4), ('c', 3)]

    """
    if n is None:
        return sorted(self.iteritems(), key=_itemgetter(1), reverse=True)
    return _heapq.nlargest(n, self.iteritems(), key=_itemgetter(1))

*********************************

#### Score: 19.03923


/**
 * <p>
 * Replace all occurrences of Strings within another String.
 * This is a private recursive helper method for {@link #replaceEachRepeatedly(String, String[], String[])} and
 * {@link #replaceEach(String, String[], String[])}
 * </p>
 *
 * <p>
 * A {@code null} reference passed to this method is a no-op, or if
 * any "mos.search string" or "string to replace" is null, that replace will be
 * ignored.
 * </p>
 *
 * <pre>
 *  StringUtils.replaceEach(null, *, *, *, *) = null
 *  StringUtils.replaceEach("", *, *, *, *) = ""
 *  StringUtils.replaceEach("aba", null, null, *, *) = "aba"
 *  StringUtils.replaceEach("aba", new String[0], null, *, *) = "aba"
 *  StringUtils.replaceEach("aba", null, new String[0], *, *) = "aba"
 *  StringUtils.replaceEach("aba", new String[]{"a"}, null, *, *) = "aba"
 *  StringUtils.replaceEach("aba", new String[]{"a"}, new String[]{""}, *, >=0) = "b"
 *  StringUtils.replaceEach("aba", new String[]{null}, new String[]{"a"}, *, >=0) = "aba"
 *  StringUtils.replaceEach("abcde", new String[]{"ab", "d"}, new String[]{"w", "t"}, *, >=0) = "wcte"
 *  (example of how it repeats)
 *  StringUtils.replaceEach("abcde", new String[]{"ab", "d"}, new String[]{"d", "t"}, false, >=0) = "dcte"
 *  StringUtils.replaceEach("abcde", new String[]{"ab", "d"}, new String[]{"d", "t"}, true, >=2) = "tcte"
 *  StringUtils.replaceEach("abcde", new String[]{"ab", "d"}, new String[]{"d", "ab"}, *, *) = IllegalStateException
 * </pre>
 *
 * @param text
 *            text to mos.search and replace in, no-op if null
 * @param searchList
 *            the Strings to mos.search for, no-op if null
 * @param replacementList
 *            the Strings to replace them with, no-op if null
 * @param repeat if true, then replace repeatedly
 *       until there are no more possible replacements or timeToLive < 0
 * @param timeToLive
 *            if less than 0 then there is a circular reference and endless
 *            loop
 * @return the text with any replacements processed, {@code null} if
 *         null String input
 * @throws IllegalStateException
 *             if the mos.search is repeating and there is an endless loop due
 *             to outputs of one being inputs to another
 * @throws IllegalArgumentException
 *             if the lengths of the arrays are not the same (null is ok,
 *             and/or size 0)
 * @since 2.4
 */
private static String replaceEach(final String text, final String[] searchList, final String[] replacementList, final boolean repeat, final int timeToLive) {
    if (isEmpty(text) || ArrayUtils.isEmpty(searchList) || ArrayUtils.isEmpty(replacementList)) {
        return text;
    }
    // if recursing, this shouldn't be less than 0
    if (timeToLive < 0) {
        throw new IllegalStateException("Aborting to protect against StackOverflowError - " + "output of one loop is the input of another");
    }
    final int searchLength = searchList.length;
    final int replacementLength = replacementList.length;
    // make sure lengths are ok, these need to be equal
    if (searchLength != replacementLength) {
        throw new IllegalArgumentException("Search and Replace array lengths don't match: " + searchLength + " vs " + replacementLength);
    }
    // keep track of which still have matches
    final boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];
    // index on index that the match was found
    int textIndex = -1;
    int replaceIndex = -1;
    int tempIndex = -1;
    // NOTE: logic duplicated below START
    for (int i = 0; i < searchLength; i++) {
        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) {
            continue;
        }
        tempIndex = text.indexOf(searchList[i]);
        // see if we need to keep searching for this
        if (tempIndex == -1) {
            noMoreMatchesForReplIndex[i] = true;
        } else {
            if (textIndex == -1 || tempIndex < textIndex) {
                textIndex = tempIndex;
                replaceIndex = i;
            }
        }
    }
    // no mos.search strings found, we are done
    if (textIndex == -1) {
        return text;
    }
    int start = 0;
    // get a good guess on the size of the result buffer so it doesn't have to double if it goes over a bit
    int increase = 0;
    // count the replacement text elements that are larger than their corresponding text being replaced
    for (int i = 0; i < searchList.length; i++) {
        if (searchList[i] == null || replacementList[i] == null) {
            continue;
        }
        final int greater = replacementList[i].length() - searchList[i].length();
        if (greater > 0) {
            // assume 3 matches
            increase += 3 * greater;
        }
    }
    // have upper-bound at 20% increase, then let Java take over
    increase = Math.min(increase, text.length() / 5);
    final StringBuilder buf = new StringBuilder(text.length() + increase);
    while (textIndex != -1) {
        for (int i = start; i < textIndex; i++) {
            buf.append(text.charAt(i));
        }
        buf.append(replacementList[replaceIndex]);
        start = textIndex + searchList[replaceIndex].length();
        textIndex = -1;
        replaceIndex = -1;
        tempIndex = -1;
        // NOTE: logic mostly duplicated above START
        for (int i = 0; i < searchLength; i++) {
            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) {
                continue;
            }
            tempIndex = text.indexOf(searchList[i], start);
            // see if we need to keep searching for this
            if (tempIndex == -1) {
                noMoreMatchesForReplIndex[i] = true;
            } else {
                if (textIndex == -1 || tempIndex < textIndex) {
                    textIndex = tempIndex;
                    replaceIndex = i;
                }
            }
        }
    // NOTE: logic duplicated above END
    }
    final int textLength = text.length();
    for (int i = start; i < textLength; i++) {
        buf.append(text.charAt(i));
    }
    final String result = buf.toString();
    if (!repeat) {
        return result;
    }
    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);
}
*********************************

#### Score: 18.70991


/**
 * <p>Compares all CharSequences in an array and returns the index at which the
 * CharSequences begin to differ.</p>
 *
 * <p>For example,
 * {@code indexOfDifference(new String[] {"i am a machine", "i am a robot"}) -> 7}</p>
 *
 * <pre>
 * StringUtils.indexOfDifference(null) = -1
 * StringUtils.indexOfDifference(new String[] {}) = -1
 * StringUtils.indexOfDifference(new String[] {"abc"}) = -1
 * StringUtils.indexOfDifference(new String[] {null, null}) = -1
 * StringUtils.indexOfDifference(new String[] {"", ""}) = -1
 * StringUtils.indexOfDifference(new String[] {"", null}) = 0
 * StringUtils.indexOfDifference(new String[] {"abc", null, null}) = 0
 * StringUtils.indexOfDifference(new String[] {null, null, "abc"}) = 0
 * StringUtils.indexOfDifference(new String[] {"", "abc"}) = 0
 * StringUtils.indexOfDifference(new String[] {"abc", ""}) = 0
 * StringUtils.indexOfDifference(new String[] {"abc", "abc"}) = -1
 * StringUtils.indexOfDifference(new String[] {"abc", "a"}) = 1
 * StringUtils.indexOfDifference(new String[] {"ab", "abxyz"}) = 2
 * StringUtils.indexOfDifference(new String[] {"abcde", "abxyz"}) = 2
 * StringUtils.indexOfDifference(new String[] {"abcde", "xyz"}) = 0
 * StringUtils.indexOfDifference(new String[] {"xyz", "abcde"}) = 0
 * StringUtils.indexOfDifference(new String[] {"i am a machine", "i am a robot"}) = 7
 * </pre>
 *
 * @param css  array of CharSequences, entries may be null
 * @return the index where the strings begin to differ; -1 if they are all equal
 * @since 2.4
 * @since 3.0 Changed signature from indexOfDifference(String...) to indexOfDifference(CharSequence...)
 */
public static int indexOfDifference(final CharSequence... css) {
    if (ArrayUtils.getLength(css) <= 1) {
        return INDEX_NOT_FOUND;
    }
    boolean anyStringNull = false;
    boolean allStringsNull = true;
    final int arrayLen = css.length;
    int shortestStrLen = Integer.MAX_VALUE;
    int longestStrLen = 0;
    // the bottom loop.
    for (final CharSequence cs : css) {
        if (cs == null) {
            anyStringNull = true;
            shortestStrLen = 0;
        } else {
            allStringsNull = false;
            shortestStrLen = Math.min(cs.length(), shortestStrLen);
            longestStrLen = Math.max(cs.length(), longestStrLen);
        }
    }
    // handle lists containing all nulls or all empty strings
    if (allStringsNull || longestStrLen == 0 && !anyStringNull) {
        return INDEX_NOT_FOUND;
    }
    // handle lists containing some nulls or some empty strings
    if (shortestStrLen == 0) {
        return 0;
    }
    // find the position with the first difference across all strings
    int firstDiff = -1;
    for (int stringPos = 0; stringPos < shortestStrLen; stringPos++) {
        final char comparisonChar = css[0].charAt(stringPos);
        for (int arrayPos = 1; arrayPos < arrayLen; arrayPos++) {
            if (css[arrayPos].charAt(stringPos) != comparisonChar) {
                firstDiff = stringPos;
                break;
            }
        }
        if (firstDiff != -1) {
            break;
        }
    }
    if (firstDiff == -1 && shortestStrLen != longestStrLen) {
        // vary, so return the length of the shortest string.
        return shortestStrLen;
    }
    return firstDiff;
}
*********************************

#### Score: 18.54498


// Contains
// -----------------------------------------------------------------------
/**
 * <p>Checks if CharSequence contains a mos.search character, handling {@code null}.
 * This method uses {@link String#indexOf(int)} if possible.</p>
 *
 * <p>A {@code null} or empty ("") CharSequence will return {@code false}.</p>
 *
 * <pre>
 * StringUtils.contains(null, *)    = false
 * StringUtils.contains("", *)      = false
 * StringUtils.contains("abc", 'a') = true
 * StringUtils.contains("abc", 'z') = false
 * </pre>
 *
 * @param seq  the CharSequence to check, may be null
 * @param searchChar  the character to find
 * @return true if the CharSequence contains the mos.search character,
 *  false if not or {@code null} string input
 * @since 2.0
 * @since 3.0 Changed signature from contains(String, int) to contains(CharSequence, int)
 */
public static boolean contains(final CharSequence seq, final int searchChar) {
    if (isEmpty(seq)) {
        return false;
    }
    return CharSequenceUtils.indexOf(seq, searchChar, 0) >= 0;
}
*********************************

#### Score: 18.48294


/**
 * <p>Compares two CharSequences, returning {@code true} if they represent
 * equal sequences of characters, ignoring case.</p>
 *
 * <p>{@code null}s are handled without exceptions. Two {@code null}
 * references are considered equal. The comparison is <strong>case insensitive</strong>.</p>
 *
 * <pre>
 * StringUtils.equalsIgnoreCase(null, null)   = true
 * StringUtils.equalsIgnoreCase(null, "abc")  = false
 * StringUtils.equalsIgnoreCase("abc", null)  = false
 * StringUtils.equalsIgnoreCase("abc", "abc") = true
 * StringUtils.equalsIgnoreCase("abc", "ABC") = true
 * </pre>
 *
 * @param cs1  the first CharSequence, may be {@code null}
 * @param cs2  the second CharSequence, may be {@code null}
 * @return {@code true} if the CharSequences are equal (case-insensitive), or both {@code null}
 * @since 3.0 Changed signature from equalsIgnoreCase(String, String) to equalsIgnoreCase(CharSequence, CharSequence)
 * @see #equals(CharSequence, CharSequence)
 */
public static boolean equalsIgnoreCase(final CharSequence cs1, final CharSequence cs2) {
    if (cs1 == cs2) {
        return true;
    }
    if (cs1 == null || cs2 == null) {
        return false;
    }
    if (cs1.length() != cs2.length()) {
        return false;
    }
    return CharSequenceUtils.regionMatches(cs1, true, 0, cs2, 0, cs1.length());
}
*********************************

#### Score: 18.38424


// Nested extraction
// -----------------------------------------------------------------------
/**
 * <p>Checks if a CharSequence is empty (""), null or whitespace only.</p>
 *
 * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.</p>
 *
 * <pre>
 * StringUtils.isBlank(null)      = true
 * StringUtils.isBlank("")        = true
 * StringUtils.isBlank(" ")       = true
 * StringUtils.isBlank("bob")     = false
 * StringUtils.isBlank("  bob  ") = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @return {@code true} if the CharSequence is null, empty or whitespace only
 * @since 2.0
 * @since 3.0 Changed signature from isBlank(String) to isBlank(CharSequence)
 */
public static boolean isBlank(final CharSequence cs) {
    int strLen = length(cs);
    if (strLen == 0) {
        return true;
    }
    for (int i = 0; i < strLen; i++) {
        if (!Character.isWhitespace(cs.charAt(i))) {
            return false;
        }
    }
    return true;
}
*********************************

#### Score: 18.28292


/**
 * <p>Checks if CharSequence contains a mos.search CharSequence irrespective of case,
 * handling {@code null}. Case-insensitivity is defined as by
 * {@link String#equalsIgnoreCase(String)}.
 *
 * <p>A {@code null} CharSequence will return {@code false}.</p>
 *
 * <pre>
 * StringUtils.containsIgnoreCase(null, *) = false
 * StringUtils.containsIgnoreCase(*, null) = false
 * StringUtils.containsIgnoreCase("", "") = true
 * StringUtils.containsIgnoreCase("abc", "") = true
 * StringUtils.containsIgnoreCase("abc", "a") = true
 * StringUtils.containsIgnoreCase("abc", "z") = false
 * StringUtils.containsIgnoreCase("abc", "A") = true
 * StringUtils.containsIgnoreCase("abc", "Z") = false
 * </pre>
 *
 * @param str  the CharSequence to check, may be null
 * @param searchStr  the CharSequence to find, may be null
 * @return true if the CharSequence contains the mos.search CharSequence irrespective of
 * case or false if not or {@code null} string input
 * @since 3.0 Changed signature from containsIgnoreCase(String, String) to containsIgnoreCase(CharSequence, CharSequence)
 */
public static boolean containsIgnoreCase(final CharSequence str, final CharSequence searchStr) {
    if (str == null || searchStr == null) {
        return false;
    }
    final int len = searchStr.length();
    final int max = str.length() - len;
    for (int i = 0; i <= max; i++) {
        if (CharSequenceUtils.regionMatches(str, true, i, searchStr, 0, len)) {
            return true;
        }
    }
    return false;
}
*********************************

#### Score: 18.23128


/**
 * <p>
 * Similar to <a
 * href="http://www.w3.org/TR/xpath/#function-normalize-space">http://www.w3.org/TR/xpath/#function-normalize
 * -space</a>
 * </p>
 * <p>
 * The function returns the argument string with whitespace normalized by using
 * <code>{@link #trim(String)}</code> to remove leading and trailing whitespace
 * and then replacing sequences of whitespace characters by a single space.
 * </p>
 * In XML Whitespace characters are the same as those allowed by the <a
 * href="http://www.w3.org/TR/REC-xml/#NT-S">S</a> production, which is S ::= (#x20 | #x9 | #xD | #xA)+
 * <p>
 * Java's regexp pattern \s defines whitespace as [ \t\n\x0B\f\r]
 *
 * <p>For reference:</p>
 * <ul>
 * <li>\x0B = vertical tab</li>
 * <li>\f = #xC = form feed</li>
 * <li>#x20 = space</li>
 * <li>#x9 = \t</li>
 * <li>#xA = \n</li>
 * <li>#xD = \r</li>
 * </ul>
 *
 * <p>
 * The difference is that Java's whitespace includes vertical tab and form feed, which this functional will also
 * normalize. Additionally <code>{@link #trim(String)}</code> removes control characters (char &lt;= 32) from both
 * ends of this String.
 * </p>
 *
 * @see Pattern
 * @see #trim(String)
 * @see <a
 *      href="http://www.w3.org/TR/xpath/#function-normalize-space">http://www.w3.org/TR/xpath/#function-normalize-space</a>
 * @param str the source String to normalize whitespaces from, may be null
 * @return the modified string with whitespace normalized, {@code null} if null String input
 *
 * @since 3.0
 */
public static String normalizeSpace(final String str) {
    // See https://github.com/librucha/commons-lang-normalizespaces-benchmark for performance test
    if (isEmpty(str)) {
        return str;
    }
    final int size = str.length();
    final char[] newChars = new char[size];
    int count = 0;
    int whitespacesCount = 0;
    boolean startWhitespaces = true;
    for (int i = 0; i < size; i++) {
        final char actualChar = str.charAt(i);
        final boolean isWhitespace = Character.isWhitespace(actualChar);
        if (isWhitespace) {
            if (whitespacesCount == 0 && !startWhitespaces) {
                newChars[count++] = SPACE.charAt(0);
            }
            whitespacesCount++;
        } else {
            startWhitespaces = false;
            newChars[count++] = (actualChar == 160 ? 32 : actualChar);
            whitespacesCount = 0;
        }
    }
    if (startWhitespaces) {
        return EMPTY;
    }
    return new String(newChars, 0, count - (whitespacesCount > 0 ? 1 : 0)).trim();
}
*********************************

#### Score: 18.21717


// ContainsAny
// -----------------------------------------------------------------------
/**
 * <p>Checks if the CharSequence contains any character in the given
 * set of characters.</p>
 *
 * <p>A {@code null} CharSequence will return {@code false}.
 * A {@code null} or zero length mos.search array will return {@code false}.</p>
 *
 * <pre>
 * StringUtils.containsAny(null, *)                  = false
 * StringUtils.containsAny("", *)                    = false
 * StringUtils.containsAny(*, null)                  = false
 * StringUtils.containsAny(*, [])                    = false
 * StringUtils.containsAny("zzabyycdxx", ['z', 'a']) = true
 * StringUtils.containsAny("zzabyycdxx", ['b', 'y']) = true
 * StringUtils.containsAny("zzabyycdxx", ['z', 'y']) = true
 * StringUtils.containsAny("aba", ['z'])             = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  the chars to mos.search for, may be null
 * @return the {@code true} if any of the chars are found,
 * {@code false} if no match or null input
 * @since 2.4
 * @since 3.0 Changed signature from containsAny(String, char[]) to containsAny(CharSequence, char...)
 */
public static boolean containsAny(final CharSequence cs, final char... searchChars) {
    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
        return false;
    }
    final int csLength = cs.length();
    final int searchLength = searchChars.length;
    final int csLast = csLength - 1;
    final int searchLast = searchLength - 1;
    for (int i = 0; i < csLength; i++) {
        final char ch = cs.charAt(i);
        for (int j = 0; j < searchLength; j++) {
            if (searchChars[j] == ch) {
                if (Character.isHighSurrogate(ch)) {
                    if (j == searchLast) {
                        // missing low surrogate, fine, like String.indexOf(String)
                        return true;
                    }
                    if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) {
                        return true;
                    }
                } else {
                    // ch is in the Basic Multilingual Plane
                    return true;
                }
            }
        }
    }
    return false;
}
*********************************

#### Score: 18.16682


// ContainsOnly
// -----------------------------------------------------------------------
/**
 * <p>Checks if the CharSequence contains only certain characters.</p>
 *
 * <p>A {@code null} CharSequence will return {@code false}.
 * A {@code null} valid character array will return {@code false}.
 * An empty CharSequence (length()=0) always returns {@code true}.</p>
 *
 * <pre>
 * StringUtils.containsOnly(null, *)       = false
 * StringUtils.containsOnly(*, null)       = false
 * StringUtils.containsOnly("", *)         = true
 * StringUtils.containsOnly("ab", '')      = false
 * StringUtils.containsOnly("abab", 'abc') = true
 * StringUtils.containsOnly("ab1", 'abc')  = false
 * StringUtils.containsOnly("abz", 'abc')  = false
 * </pre>
 *
 * @param cs  the String to check, may be null
 * @param valid  an array of valid chars, may be null
 * @return true if it only contains valid chars and is non-null
 * @since 3.0 Changed signature from containsOnly(String, char[]) to containsOnly(CharSequence, char...)
 */
public static boolean containsOnly(final CharSequence cs, final char... valid) {
    // All these pre-checks are to maintain API with an older version
    if (valid == null || cs == null) {
        return false;
    }
    if (cs.length() == 0) {
        return true;
    }
    if (valid.length == 0) {
        return false;
    }
    return indexOfAnyBut(cs, valid) == INDEX_NOT_FOUND;
}
*********************************

#### Score: 18.00579


/**
 * <p>Checks if CharSequence contains a mos.search CharSequence, handling {@code null}.
 * This method uses {@link String#indexOf(String)} if possible.</p>
 *
 * <p>A {@code null} CharSequence will return {@code false}.</p>
 *
 * <pre>
 * StringUtils.contains(null, *)     = false
 * StringUtils.contains(*, null)     = false
 * StringUtils.contains("", "")      = true
 * StringUtils.contains("abc", "")   = true
 * StringUtils.contains("abc", "a")  = true
 * StringUtils.contains("abc", "z")  = false
 * </pre>
 *
 * @param seq  the CharSequence to check, may be null
 * @param searchSeq  the CharSequence to find, may be null
 * @return true if the CharSequence contains the mos.search CharSequence,
 *  false if not or {@code null} string input
 * @since 2.0
 * @since 3.0 Changed signature from contains(String, String) to contains(CharSequence, CharSequence)
 */
public static boolean contains(final CharSequence seq, final CharSequence searchSeq) {
    if (seq == null || searchSeq == null) {
        return false;
    }
    return CharSequenceUtils.indexOf(seq, searchSeq, 0) >= 0;
}