### Py functions

def get_field(self, field_name, args, kwargs):
    first, rest = field_name._formatter_field_name_split()
    obj = self.get_value(first, args, kwargs)
    for is_attr, i in rest:
        if is_attr:
            obj = getattr(obj, i)
        else:
            obj = obj[i]
    return obj, first

*********************************

#### Score: 25.64504


/**
 * Performs the logic for the {@code splitByWholeSeparatorPreserveAllTokens} methods.
 *
 * @param str  the String to parse, may be {@code null}
 * @param separator  String containing the String to be used as a delimiter,
 *  {@code null} splits on whitespace
 * @param max  the maximum number of elements to include in the returned
 *  array. A zero or negative value implies no limit.
 * @param preserveAllTokens if {@code true}, adjacent separators are
 * treated as empty token separators; if {@code false}, adjacent
 * separators are treated as one separator.
 * @return an array of parsed Strings, {@code null} if null String input
 * @since 2.4
 */
private static String[] splitByWholeSeparatorWorker(final String str, final String separator, final int max, final boolean preserveAllTokens) {
    if (str == null) {
        return null;
    }
    final int len = str.length();
    if (len == 0) {
        return ArrayUtils.EMPTY_STRING_ARRAY;
    }
    if (separator == null || EMPTY.equals(separator)) {
        // Split on whitespace.
        return splitWorker(str, null, max, preserveAllTokens);
    }
    final int separatorLength = separator.length();
    final ArrayList<String> substrings = new ArrayList<>();
    int numberOfSubstrings = 0;
    int beg = 0;
    int end = 0;
    while (end < len) {
        end = str.indexOf(separator, beg);
        if (end > -1) {
            if (end > beg) {
                numberOfSubstrings += 1;
                if (numberOfSubstrings == max) {
                    end = len;
                    substrings.add(str.substring(beg));
                } else {
                    // The following is OK, because String.substring( beg, end ) excludes
                    // the character at the position 'end'.
                    substrings.add(str.substring(beg, end));
                    // Set the starting point for the next mos.search.
                    // The following is equivalent to beg = end + (separatorLength - 1) + 1,
                    // which is the right calculation:
                    beg = end + separatorLength;
                }
            } else {
                // We found a consecutive occurrence of the separator, so skip it.
                if (preserveAllTokens) {
                    numberOfSubstrings += 1;
                    if (numberOfSubstrings == max) {
                        end = len;
                        substrings.add(str.substring(beg));
                    } else {
                        substrings.add(EMPTY);
                    }
                }
                beg = end + separatorLength;
            }
        } else {
            // String.substring( beg ) goes from 'beg' to the end of the String.
            substrings.add(str.substring(beg));
            end = len;
        }
    }
    return substrings.toArray(new String[substrings.size()]);
}
*********************************

#### Score: 24.92432


/**
 * <p>Compares all Strings in an array and returns the initial sequence of
 * characters that is common to all of them.</p>
 *
 * <p>For example,
 * <code>getCommonPrefix(new String[] {"i am a machine", "i am a robot"}) -&gt; "i am a "</code></p>
 *
 * <pre>
 * StringUtils.getCommonPrefix(null) = ""
 * StringUtils.getCommonPrefix(new String[] {}) = ""
 * StringUtils.getCommonPrefix(new String[] {"abc"}) = "abc"
 * StringUtils.getCommonPrefix(new String[] {null, null}) = ""
 * StringUtils.getCommonPrefix(new String[] {"", ""}) = ""
 * StringUtils.getCommonPrefix(new String[] {"", null}) = ""
 * StringUtils.getCommonPrefix(new String[] {"abc", null, null}) = ""
 * StringUtils.getCommonPrefix(new String[] {null, null, "abc"}) = ""
 * StringUtils.getCommonPrefix(new String[] {"", "abc"}) = ""
 * StringUtils.getCommonPrefix(new String[] {"abc", ""}) = ""
 * StringUtils.getCommonPrefix(new String[] {"abc", "abc"}) = "abc"
 * StringUtils.getCommonPrefix(new String[] {"abc", "a"}) = "a"
 * StringUtils.getCommonPrefix(new String[] {"ab", "abxyz"}) = "ab"
 * StringUtils.getCommonPrefix(new String[] {"abcde", "abxyz"}) = "ab"
 * StringUtils.getCommonPrefix(new String[] {"abcde", "xyz"}) = ""
 * StringUtils.getCommonPrefix(new String[] {"xyz", "abcde"}) = ""
 * StringUtils.getCommonPrefix(new String[] {"i am a machine", "i am a robot"}) = "i am a "
 * </pre>
 *
 * @param strs  array of String objects, entries may be null
 * @return the initial sequence of characters that are common to all Strings
 * in the array; empty String if the array is null, the elements are all null
 * or if there is no common prefix.
 * @since 2.4
 */
public static String getCommonPrefix(final String... strs) {
    if (ArrayUtils.isEmpty(strs)) {
        return EMPTY;
    }
    final int smallestIndexOfDiff = indexOfDifference(strs);
    if (smallestIndexOfDiff == INDEX_NOT_FOUND) {
        // all strings were identical
        if (strs[0] == null) {
            return EMPTY;
        }
        return strs[0];
    } else if (smallestIndexOfDiff == 0) {
        // there were no common initial characters
        return EMPTY;
    } else {
        // we found a common initial character sequence
        return strs[0].substring(0, smallestIndexOfDiff);
    }
}
*********************************

#### Score: 24.23716


/**
 * <p>Strips any of a set of characters from the start of a String.</p>
 *
 * <p>A {@code null} input String returns {@code null}.
 * An empty string ("") input returns the empty string.</p>
 *
 * <p>If the stripChars String is {@code null}, whitespace is
 * stripped as defined by {@link Character#isWhitespace(char)}.</p>
 *
 * <pre>
 * StringUtils.stripStart(null, *)          = null
 * StringUtils.stripStart("", *)            = ""
 * StringUtils.stripStart("abc", "")        = "abc"
 * StringUtils.stripStart("abc", null)      = "abc"
 * StringUtils.stripStart("  abc", null)    = "abc"
 * StringUtils.stripStart("abc  ", null)    = "abc  "
 * StringUtils.stripStart(" abc ", null)    = "abc "
 * StringUtils.stripStart("yxabc  ", "xyz") = "abc  "
 * </pre>
 *
 * @param str  the String to remove characters from, may be null
 * @param stripChars  the characters to remove, null treated as whitespace
 * @return the stripped String, {@code null} if null String input
 */
public static String stripStart(final String str, final String stripChars) {
    int strLen = length(str);
    if (strLen == 0) {
        return str;
    }
    int start = 0;
    if (stripChars == null) {
        while (start != strLen && Character.isWhitespace(str.charAt(start))) {
            start++;
        }
    } else if (stripChars.isEmpty()) {
        return str;
    } else {
        while (start != strLen && stripChars.indexOf(str.charAt(start)) != INDEX_NOT_FOUND) {
            start++;
        }
    }
    return str.substring(start);
}
*********************************

#### Score: 23.99570


/**
 * <p>Strips any of a set of characters from the end of a String.</p>
 *
 * <p>A {@code null} input String returns {@code null}.
 * An empty string ("") input returns the empty string.</p>
 *
 * <p>If the stripChars String is {@code null}, whitespace is
 * stripped as defined by {@link Character#isWhitespace(char)}.</p>
 *
 * <pre>
 * StringUtils.stripEnd(null, *)          = null
 * StringUtils.stripEnd("", *)            = ""
 * StringUtils.stripEnd("abc", "")        = "abc"
 * StringUtils.stripEnd("abc", null)      = "abc"
 * StringUtils.stripEnd("  abc", null)    = "  abc"
 * StringUtils.stripEnd("abc  ", null)    = "abc"
 * StringUtils.stripEnd(" abc ", null)    = " abc"
 * StringUtils.stripEnd("  abcyx", "xyz") = "  abc"
 * StringUtils.stripEnd("120.00", ".0")   = "12"
 * </pre>
 *
 * @param str  the String to remove characters from, may be null
 * @param stripChars  the set of characters to remove, null treated as whitespace
 * @return the stripped String, {@code null} if null String input
 */
public static String stripEnd(final String str, final String stripChars) {
    int end = length(str);
    if (end == 0) {
        return str;
    }
    if (stripChars == null) {
        while (end != 0 && Character.isWhitespace(str.charAt(end - 1))) {
            end--;
        }
    } else if (stripChars.isEmpty()) {
        return str;
    } else {
        while (end != 0 && stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND) {
            end--;
        }
    }
    return str.substring(0, end);
}
*********************************

#### Score: 23.99201


/**
 * <p>Swaps the case of a String changing upper and title case to
 * lower case, and lower case to upper case.</p>
 *
 * <ul>
 *  <li>Upper case character converts to Lower case</li>
 *  <li>Title case character converts to Lower case</li>
 *  <li>Lower case character converts to Upper case</li>
 * </ul>
 *
 * <p>For a word based algorithm, see {@link org.apache.commons.lang3.text.WordUtils#swapCase(String)}.
 * A {@code null} input String returns {@code null}.</p>
 *
 * <pre>
 * StringUtils.swapCase(null)                 = null
 * StringUtils.swapCase("")                   = ""
 * StringUtils.swapCase("The dog has a BONE") = "tHE DOG HAS A bone"
 * </pre>
 *
 * <p>NOTE: This method changed in Lang version 2.0.
 * It no longer performs a word based algorithm.
 * If you only use ASCII, you will notice no change.
 * That functionality is available in org.apache.commons.lang3.text.WordUtils.</p>
 *
 * @param str  the String to swap case, may be null
 * @return the changed String, {@code null} if null String input
 */
public static String swapCase(final String str) {
    if (isEmpty(str)) {
        return str;
    }
    final int strLen = str.length();
    // cannot be longer than the char array
    final int[] newCodePoints = new int[strLen];
    int outOffset = 0;
    for (int i = 0; i < strLen; ) {
        final int oldCodepoint = str.codePointAt(i);
        final int newCodePoint;
        if (Character.isUpperCase(oldCodepoint)) {
            newCodePoint = Character.toLowerCase(oldCodepoint);
        } else if (Character.isTitleCase(oldCodepoint)) {
            newCodePoint = Character.toLowerCase(oldCodepoint);
        } else if (Character.isLowerCase(oldCodepoint)) {
            newCodePoint = Character.toUpperCase(oldCodepoint);
        } else {
            newCodePoint = oldCodepoint;
        }
        newCodePoints[outOffset++] = newCodePoint;
        i += Character.charCount(newCodePoint);
    }
    return new String(newCodePoints, 0, outOffset);
}
*********************************

#### Score: 23.64422


// IndexOfAnyBut chars
// -----------------------------------------------------------------------
/**
 * <p>Searches a CharSequence to find the first index of any
 * character not in the given set of characters.</p>
 *
 * <p>A {@code null} CharSequence will return {@code -1}.
 * A {@code null} or zero length mos.search array will return {@code -1}.</p>
 *
 * <pre>
 * StringUtils.indexOfAnyBut(null, *)                              = -1
 * StringUtils.indexOfAnyBut("", *)                                = -1
 * StringUtils.indexOfAnyBut(*, null)                              = -1
 * StringUtils.indexOfAnyBut(*, [])                                = -1
 * StringUtils.indexOfAnyBut("zzabyycdxx", new char[] {'z', 'a'} ) = 3
 * StringUtils.indexOfAnyBut("aba", new char[] {'z'} )             = 0
 * StringUtils.indexOfAnyBut("aba", new char[] {'a', 'b'} )        = -1
 *
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  the chars to mos.search for, may be null
 * @return the index of any of the chars, -1 if no match or null input
 * @since 2.0
 * @since 3.0 Changed signature from indexOfAnyBut(String, char[]) to indexOfAnyBut(CharSequence, char...)
 */
public static int indexOfAnyBut(final CharSequence cs, final char... searchChars) {
    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
        return INDEX_NOT_FOUND;
    }
    final int csLen = cs.length();
    final int csLast = csLen - 1;
    final int searchLen = searchChars.length;
    final int searchLast = searchLen - 1;
    outer: for (int i = 0; i < csLen; i++) {
        final char ch = cs.charAt(i);
        for (int j = 0; j < searchLen; j++) {
            if (searchChars[j] == ch) {
                if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) {
                    if (searchChars[j + 1] == cs.charAt(i + 1)) {
                        continue outer;
                    }
                } else {
                    continue outer;
                }
            }
        }
        return i;
    }
    return INDEX_NOT_FOUND;
}
*********************************

#### Score: 23.61129


// IndexOfAny chars
// -----------------------------------------------------------------------
/**
 * <p>Search a CharSequence to find the first index of any
 * character in the given set of characters.</p>
 *
 * <p>A {@code null} String will return {@code -1}.
 * A {@code null} or zero length mos.search array will return {@code -1}.</p>
 *
 * <pre>
 * StringUtils.indexOfAny(null, *)                  = -1
 * StringUtils.indexOfAny("", *)                    = -1
 * StringUtils.indexOfAny(*, null)                  = -1
 * StringUtils.indexOfAny(*, [])                    = -1
 * StringUtils.indexOfAny("zzabyycdxx", ['z', 'a']) = 0
 * StringUtils.indexOfAny("zzabyycdxx", ['b', 'y']) = 3
 * StringUtils.indexOfAny("aba", ['z'])             = -1
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  the chars to mos.search for, may be null
 * @return the index of any of the chars, -1 if no match or null input
 * @since 2.0
 * @since 3.0 Changed signature from indexOfAny(String, char[]) to indexOfAny(CharSequence, char...)
 */
public static int indexOfAny(final CharSequence cs, final char... searchChars) {
    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
        return INDEX_NOT_FOUND;
    }
    final int csLen = cs.length();
    final int csLast = csLen - 1;
    final int searchLen = searchChars.length;
    final int searchLast = searchLen - 1;
    for (int i = 0; i < csLen; i++) {
        final char ch = cs.charAt(i);
        for (int j = 0; j < searchLen; j++) {
            if (searchChars[j] == ch) {
                if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) {
                    // ch is a supplementary character
                    if (searchChars[j + 1] == cs.charAt(i + 1)) {
                        return i;
                    }
                } else {
                    return i;
                }
            }
        }
    }
    return INDEX_NOT_FOUND;
}
*********************************

#### Score: 23.38980


// ContainsAny
// -----------------------------------------------------------------------
/**
 * <p>Checks if the CharSequence contains any character in the given
 * set of characters.</p>
 *
 * <p>A {@code null} CharSequence will return {@code false}.
 * A {@code null} or zero length mos.search array will return {@code false}.</p>
 *
 * <pre>
 * StringUtils.containsAny(null, *)                  = false
 * StringUtils.containsAny("", *)                    = false
 * StringUtils.containsAny(*, null)                  = false
 * StringUtils.containsAny(*, [])                    = false
 * StringUtils.containsAny("zzabyycdxx", ['z', 'a']) = true
 * StringUtils.containsAny("zzabyycdxx", ['b', 'y']) = true
 * StringUtils.containsAny("zzabyycdxx", ['z', 'y']) = true
 * StringUtils.containsAny("aba", ['z'])             = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  the chars to mos.search for, may be null
 * @return the {@code true} if any of the chars are found,
 * {@code false} if no match or null input
 * @since 2.4
 * @since 3.0 Changed signature from containsAny(String, char[]) to containsAny(CharSequence, char...)
 */
public static boolean containsAny(final CharSequence cs, final char... searchChars) {
    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
        return false;
    }
    final int csLength = cs.length();
    final int searchLength = searchChars.length;
    final int csLast = csLength - 1;
    final int searchLast = searchLength - 1;
    for (int i = 0; i < csLength; i++) {
        final char ch = cs.charAt(i);
        for (int j = 0; j < searchLength; j++) {
            if (searchChars[j] == ch) {
                if (Character.isHighSurrogate(ch)) {
                    if (j == searchLast) {
                        // missing low surrogate, fine, like String.indexOf(String)
                        return true;
                    }
                    if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) {
                        return true;
                    }
                } else {
                    // ch is in the Basic Multilingual Plane
                    return true;
                }
            }
        }
    }
    return false;
}
*********************************

#### Score: 23.38828


// ContainsNone
// -----------------------------------------------------------------------
/**
 * <p>Checks that the CharSequence does not contain certain characters.</p>
 *
 * <p>A {@code null} CharSequence will return {@code true}.
 * A {@code null} invalid character array will return {@code true}.
 * An empty CharSequence (length()=0) always returns true.</p>
 *
 * <pre>
 * StringUtils.containsNone(null, *)       = true
 * StringUtils.containsNone(*, null)       = true
 * StringUtils.containsNone("", *)         = true
 * StringUtils.containsNone("ab", '')      = true
 * StringUtils.containsNone("abab", 'xyz') = true
 * StringUtils.containsNone("ab1", 'xyz')  = true
 * StringUtils.containsNone("abz", 'xyz')  = false
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  an array of invalid chars, may be null
 * @return true if it contains none of the invalid chars, or is null
 * @since 2.0
 * @since 3.0 Changed signature from containsNone(String, char[]) to containsNone(CharSequence, char...)
 */
public static boolean containsNone(final CharSequence cs, final char... searchChars) {
    if (cs == null || searchChars == null) {
        return true;
    }
    final int csLen = cs.length();
    final int csLast = csLen - 1;
    final int searchLen = searchChars.length;
    final int searchLast = searchLen - 1;
    for (int i = 0; i < csLen; i++) {
        final char ch = cs.charAt(i);
        for (int j = 0; j < searchLen; j++) {
            if (searchChars[j] == ch) {
                if (Character.isHighSurrogate(ch)) {
                    if (j == searchLast) {
                        // missing low surrogate, fine, like String.indexOf(String)
                        return false;
                    }
                    if (i < csLast && searchChars[j + 1] == cs.charAt(i + 1)) {
                        return false;
                    }
                } else {
                    // ch is in the Basic Multilingual Plane
                    return false;
                }
            }
        }
    }
    return true;
}
*********************************

#### Score: 23.14569


/**
 * <p>Right pad a String with a specified String.</p>
 *
 * <p>The String is padded to the size of {@code size}.</p>
 *
 * <pre>
 * StringUtils.rightPad(null, *, *)      = null
 * StringUtils.rightPad("", 3, "z")      = "zzz"
 * StringUtils.rightPad("bat", 3, "yz")  = "bat"
 * StringUtils.rightPad("bat", 5, "yz")  = "batyz"
 * StringUtils.rightPad("bat", 8, "yz")  = "batyzyzy"
 * StringUtils.rightPad("bat", 1, "yz")  = "bat"
 * StringUtils.rightPad("bat", -1, "yz") = "bat"
 * StringUtils.rightPad("bat", 5, null)  = "bat  "
 * StringUtils.rightPad("bat", 5, "")    = "bat  "
 * </pre>
 *
 * @param str  the String to pad out, may be null
 * @param size  the size to pad to
 * @param padStr  the String to pad with, null or empty treated as single space
 * @return right padded String or original String if no padding is necessary,
 *  {@code null} if null String input
 */
public static String rightPad(final String str, final int size, String padStr) {
    if (str == null) {
        return null;
    }
    if (isEmpty(padStr)) {
        padStr = SPACE;
    }
    final int padLen = padStr.length();
    final int strLen = str.length();
    final int pads = size - strLen;
    if (pads <= 0) {
        // returns original String when possible
        return str;
    }
    if (padLen == 1 && pads <= PAD_LIMIT) {
        return rightPad(str, size, padStr.charAt(0));
    }
    if (pads == padLen) {
        return str.concat(padStr);
    } else if (pads < padLen) {
        return str.concat(padStr.substring(0, pads));
    } else {
        final char[] padding = new char[pads];
        final char[] padChars = padStr.toCharArray();
        for (int i = 0; i < pads; i++) {
            padding[i] = padChars[i % padLen];
        }
        return str.concat(new String(padding));
    }
}