### Py functions

def _replace(self, _map=map, **kwds):
    return self._make(_map(kwds.get, ('x', 'y'), self))

*********************************

#### Score: 6.76267


/**
 * Appends the suffix to the end of the string if the string does not
 * already end with the suffix.
 *
 * @param str The string.
 * @param suffix The suffix to append to the end of the string.
 * @param ignoreCase Indicates whether the compare should ignore case.
 * @param suffixes Additional suffixes that are valid terminators (optional).
 *
 * @return A new String if suffix was appended, the same string otherwise.
 */
private static String appendIfMissing(final String str, final CharSequence suffix, final boolean ignoreCase, final CharSequence... suffixes) {
    if (str == null || isEmpty(suffix) || endsWith(str, suffix, ignoreCase)) {
        return str;
    }
    if (ArrayUtils.isNotEmpty(suffixes)) {
        for (final CharSequence s : suffixes) {
            if (endsWith(str, s, ignoreCase)) {
                return str;
            }
        }
    }
    return str + suffix.toString();
}
*********************************

#### Score: 6.76205


/**
 * Prepends the prefix to the start of the string if the string does not
 * already start with any of the prefixes.
 *
 * @param str The string.
 * @param prefix The prefix to prepend to the start of the string.
 * @param ignoreCase Indicates whether the compare should ignore case.
 * @param prefixes Additional prefixes that are valid (optional).
 *
 * @return A new String if prefix was prepended, the same string otherwise.
 */
private static String prependIfMissing(final String str, final CharSequence prefix, final boolean ignoreCase, final CharSequence... prefixes) {
    if (str == null || isEmpty(prefix) || startsWith(str, prefix, ignoreCase)) {
        return str;
    }
    if (ArrayUtils.isNotEmpty(prefixes)) {
        for (final CharSequence p : prefixes) {
            if (startsWith(str, p, ignoreCase)) {
                return str;
            }
        }
    }
    return prefix.toString() + str;
}
*********************************

#### Score: 6.75135


/**
 * <p>Removes all occurrences of a substring from within the source string.</p>
 *
 * <p>A {@code null} source string will return {@code null}.
 * An empty ("") source string will return the empty string.
 * A {@code null} remove string will return the source string.
 * An empty ("") remove string will return the source string.</p>
 *
 * <pre>
 * StringUtils.remove(null, *)        = null
 * StringUtils.remove("", *)          = ""
 * StringUtils.remove(*, null)        = *
 * StringUtils.remove(*, "")          = *
 * StringUtils.remove("queued", "ue") = "qd"
 * StringUtils.remove("queued", "zz") = "queued"
 * </pre>
 *
 * @param str  the source String to mos.search, may be null
 * @param remove  the String to mos.search for and remove, may be null
 * @return the substring with the string removed if found,
 *  {@code null} if null String input
 * @since 2.1
 */
public static String remove(final String str, final String remove) {
    if (isEmpty(str) || isEmpty(remove)) {
        return str;
    }
    return replace(str, remove, EMPTY, -1);
}
/**
 * <p>
 * Case insensitive removal of all occurrences of a substring from within
 * the source string.
 * </p>
 *
 * <p>
 * A {@code null} source string will return {@code null}. An empty ("")
 * source string will return the empty string. A {@code null} remove string
 * will return the source string. An empty ("") remove string will return
 * the source string.
 * </p>
 *
 * <pre>
 * StringUtils.removeIgnoreCase(null, *)        = null
 * StringUtils.removeIgnoreCase("", *)          = ""
 * StringUtils.removeIgnoreCase(*, null)        = *
 * StringUtils.removeIgnoreCase(*, "")          = *
 * StringUtils.removeIgnoreCase("queued", "ue") = "qd"
 * StringUtils.removeIgnoreCase("queued", "zz") = "queued"
 * StringUtils.removeIgnoreCase("quEUed", "UE") = "qd"
 * StringUtils.removeIgnoreCase("queued", "zZ") = "queued"
 * </pre>
 *
 * @param str
 *            the source String to mos.search, may be null
 * @param remove
 *            the String to mos.search for (case insensitive) and remove, may be
 *            null
 * @return the substring with the string removed if found, {@code null} if
 *         null String input
 * @since 3.5
 */
public static String removeIgnoreCase(final String str, final String remove) {
    if (isEmpty(str) || isEmpty(remove)) {
        return str;
    }
    return replaceIgnoreCase(str, remove, EMPTY, -1);
}
*********************************

#### Score: 6.74224


/**
 * <p>Search a CharSequence to find the first index of any
 * character in the given set of characters.</p>
 *
 * <p>A {@code null} String will return {@code -1}.
 * A {@code null} mos.search string will return {@code -1}.</p>
 *
 * <pre>
 * StringUtils.indexOfAny(null, *)            = -1
 * StringUtils.indexOfAny("", *)              = -1
 * StringUtils.indexOfAny(*, null)            = -1
 * StringUtils.indexOfAny(*, "")              = -1
 * StringUtils.indexOfAny("zzabyycdxx", "za") = 0
 * StringUtils.indexOfAny("zzabyycdxx", "by") = 3
 * StringUtils.indexOfAny("aba", "z")         = -1
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  the chars to mos.search for, may be null
 * @return the index of any of the chars, -1 if no match or null input
 * @since 2.0
 * @since 3.0 Changed signature from indexOfAny(String, String) to indexOfAny(CharSequence, String)
 */
public static int indexOfAny(final CharSequence cs, final String searchChars) {
    if (isEmpty(cs) || isEmpty(searchChars)) {
        return INDEX_NOT_FOUND;
    }
    return indexOfAny(cs, searchChars.toCharArray());
}
*********************************

#### Score: 6.73453


/**
 * <p>Case insensitive removal of a substring if it is at the beginning of a source string,
 * otherwise returns the source string.</p>
 *
 * <p>A {@code null} source string will return {@code null}.
 * An empty ("") source string will return the empty string.
 * A {@code null} mos.search string will return the source string.</p>
 *
 * <pre>
 * StringUtils.removeStartIgnoreCase(null, *)      = null
 * StringUtils.removeStartIgnoreCase("", *)        = ""
 * StringUtils.removeStartIgnoreCase(*, null)      = *
 * StringUtils.removeStartIgnoreCase("www.domain.com", "www.")   = "domain.com"
 * StringUtils.removeStartIgnoreCase("www.domain.com", "WWW.")   = "domain.com"
 * StringUtils.removeStartIgnoreCase("domain.com", "www.")       = "domain.com"
 * StringUtils.removeStartIgnoreCase("www.domain.com", "domain") = "www.domain.com"
 * StringUtils.removeStartIgnoreCase("abc", "")    = "abc"
 * </pre>
 *
 * @param str  the source String to mos.search, may be null
 * @param remove  the String to mos.search for (case insensitive) and remove, may be null
 * @return the substring with the string removed if found,
 *  {@code null} if null String input
 * @since 2.4
 */
public static String removeStartIgnoreCase(final String str, final String remove) {
    if (isEmpty(str) || isEmpty(remove)) {
        return str;
    }
    if (startsWithIgnoreCase(str, remove)) {
        return str.substring(remove.length());
    }
    return str;
}
*********************************

#### Score: 6.73113


/**
 * <p>Check if a CharSequence starts with any of the provided case-sensitive prefixes.</p>
 *
 * <pre>
 * StringUtils.startsWithAny(null, null)      = false
 * StringUtils.startsWithAny(null, new String[] {"abc"})  = false
 * StringUtils.startsWithAny("abcxyz", null)     = false
 * StringUtils.startsWithAny("abcxyz", new String[] {""}) = true
 * StringUtils.startsWithAny("abcxyz", new String[] {"abc"}) = true
 * StringUtils.startsWithAny("abcxyz", new String[] {null, "xyz", "abc"}) = true
 * StringUtils.startsWithAny("abcxyz", null, "xyz", "ABCX") = false
 * StringUtils.startsWithAny("ABCXYZ", null, "xyz", "abc") = false
 * </pre>
 *
 * @param sequence the CharSequence to check, may be null
 * @param searchStrings the case-sensitive CharSequence prefixes, may be empty or contain {@code null}
 * @see StringUtils#startsWith(CharSequence, CharSequence)
 * @return {@code true} if the input {@code sequence} is {@code null} AND no {@code searchStrings} are provided, or
 *   the input {@code sequence} begins with any of the provided case-sensitive {@code searchStrings}.
 * @since 2.5
 * @since 3.0 Changed signature from startsWithAny(String, String[]) to startsWithAny(CharSequence, CharSequence...)
 */
public static boolean startsWithAny(final CharSequence sequence, final CharSequence... searchStrings) {
    if (isEmpty(sequence) || ArrayUtils.isEmpty(searchStrings)) {
        return false;
    }
    for (final CharSequence searchString : searchStrings) {
        if (startsWith(sequence, searchString)) {
            return true;
        }
    }
    return false;
}
/**
 * <p>Check if a CharSequence ends with any of the provided case-sensitive suffixes.</p>
 *
 * <pre>
 * StringUtils.endsWithAny(null, null)      = false
 * StringUtils.endsWithAny(null, new String[] {"abc"})  = false
 * StringUtils.endsWithAny("abcxyz", null)     = false
 * StringUtils.endsWithAny("abcxyz", new String[] {""}) = true
 * StringUtils.endsWithAny("abcxyz", new String[] {"xyz"}) = true
 * StringUtils.endsWithAny("abcxyz", new String[] {null, "xyz", "abc"}) = true
 * StringUtils.endsWithAny("abcXYZ", "def", "XYZ") = true
 * StringUtils.endsWithAny("abcXYZ", "def", "xyz") = false
 * </pre>
 *
 * @param sequence  the CharSequence to check, may be null
 * @param searchStrings the case-sensitive CharSequences to find, may be empty or contain {@code null}
 * @see StringUtils#endsWith(CharSequence, CharSequence)
 * @return {@code true} if the input {@code sequence} is {@code null} AND no {@code searchStrings} are provided, or
 *   the input {@code sequence} ends in any of the provided case-sensitive {@code searchStrings}.
 * @since 3.0
 */
public static boolean endsWithAny(final CharSequence sequence, final CharSequence... searchStrings) {
    if (isEmpty(sequence) || ArrayUtils.isEmpty(searchStrings)) {
        return false;
    }
    for (final CharSequence searchString : searchStrings) {
        if (endsWith(sequence, searchString)) {
            return true;
        }
    }
    return false;
}
/**
 * <p>Checks if the CharSequence contains any of the CharSequences in the given array.</p>
 *
 * <p>
 * A {@code null} {@code cs} CharSequence will return {@code false}. A {@code null} or zero
 * length mos.search array will return {@code false}.
 * </p>
 *
 * <pre>
 * StringUtils.containsAny(null, *)            = false
 * StringUtils.containsAny("", *)              = false
 * StringUtils.containsAny(*, null)            = false
 * StringUtils.containsAny(*, [])              = false
 * StringUtils.containsAny("abcd", "ab", null) = true
 * StringUtils.containsAny("abcd", "ab", "cd") = true
 * StringUtils.containsAny("abc", "d", "abc")  = true
 * </pre>
 *
 * @param cs The CharSequence to check, may be null
 * @param searchCharSequences The array of CharSequences to mos.search for, may be null.
 * Individual CharSequences may be null as well.
 * @return {@code true} if any of the mos.search CharSequences are found, {@code false} otherwise
 * @since 3.4
 */
public static boolean containsAny(final CharSequence cs, final CharSequence... searchCharSequences) {
    if (isEmpty(cs) || ArrayUtils.isEmpty(searchCharSequences)) {
        return false;
    }
    for (final CharSequence searchCharSequence : searchCharSequences) {
        if (contains(cs, searchCharSequence)) {
            return true;
        }
    }
    return false;
}
*********************************

#### Score: 6.72758


/**
 * <p>Strips any of a set of characters from the start and end of a String.
 * This is similar to {@link String#trim()} but allows the characters
 * to be stripped to be controlled.</p>
 *
 * <p>A {@code null} input String returns {@code null}.
 * An empty string ("") input returns the empty string.</p>
 *
 * <p>If the stripChars String is {@code null}, whitespace is
 * stripped as defined by {@link Character#isWhitespace(char)}.
 * Alternatively use {@link #strip(String)}.</p>
 *
 * <pre>
 * StringUtils.strip(null, *)          = null
 * StringUtils.strip("", *)            = ""
 * StringUtils.strip("abc", null)      = "abc"
 * StringUtils.strip("  abc", null)    = "abc"
 * StringUtils.strip("abc  ", null)    = "abc"
 * StringUtils.strip(" abc ", null)    = "abc"
 * StringUtils.strip("  abcyx", "xyz") = "  abc"
 * </pre>
 *
 * @param str  the String to remove characters from, may be null
 * @param stripChars  the characters to remove, null treated as whitespace
 * @return the stripped String, {@code null} if null String input
 */
public static String strip(String str, final String stripChars) {
    if (isEmpty(str)) {
        return str;
    }
    str = stripStart(str, stripChars);
    return stripEnd(str, stripChars);
}
*********************************

#### Score: 6.72278


// Conversion
// -----------------------------------------------------------------------
/**
 * <p>Repeat a String {@code repeat} times to form a
 * new String, with a String separator injected each time. </p>
 *
 * <pre>
 * StringUtils.repeat(null, null, 2) = null
 * StringUtils.repeat(null, "x", 2)  = null
 * StringUtils.repeat("", null, 0)   = ""
 * StringUtils.repeat("", "", 2)     = ""
 * StringUtils.repeat("", "x", 3)    = "xxx"
 * StringUtils.repeat("?", ", ", 3)  = "?, ?, ?"
 * </pre>
 *
 * @param str        the String to repeat, may be null
 * @param separator  the String to inject, may be null
 * @param repeat     number of times to repeat str, negative treated as zero
 * @return a new String consisting of the original String repeated,
 *  {@code null} if null String input
 * @since 2.5
 */
public static String repeat(final String str, final String separator, final int repeat) {
    if (str == null || separator == null) {
        return repeat(str, repeat);
    }
    // given that repeat(String, int) is quite optimized, better to rely on it than try and splice this into it
    final String result = repeat(str + separator, repeat);
    return removeEnd(result, separator);
}
*********************************

#### Score: 6.70565


/**
 * <p>
 * Wraps a string with a char.
 * </p>
 *
 * <pre>
 * StringUtils.wrap(null, *)        = null
 * StringUtils.wrap("", *)          = ""
 * StringUtils.wrap("ab", '\0')     = "ab"
 * StringUtils.wrap("ab", 'x')      = "xabx"
 * StringUtils.wrap("ab", '\'')     = "'ab'"
 * StringUtils.wrap("\"ab\"", '\"') = "\"\"ab\"\""
 * </pre>
 *
 * @param str
 *            the string to be wrapped, may be {@code null}
 * @param wrapWith
 *            the char that will wrap {@code str}
 * @return the wrapped string, or {@code null} if {@code str==null}
 * @since 3.4
 */
public static String wrap(final String str, final char wrapWith) {
    if (isEmpty(str) || wrapWith == CharUtils.NUL) {
        return str;
    }
    return wrapWith + str + wrapWith;
}
*********************************

#### Score: 6.70356


// Chomping
// -----------------------------------------------------------------------
/**
 * <p>Removes one newline from end of a String if it's there,
 * otherwise leave it alone.  A newline is &quot;{@code \n}&quot;,
 * &quot;{@code \r}&quot;, or &quot;{@code \r\n}&quot;.</p>
 *
 * <p>NOTE: This method changed in 2.0.
 * It now more closely matches Perl chomp.</p>
 *
 * <pre>
 * StringUtils.chomp(null)          = null
 * StringUtils.chomp("")            = ""
 * StringUtils.chomp("abc \r")      = "abc "
 * StringUtils.chomp("abc\n")       = "abc"
 * StringUtils.chomp("abc\r\n")     = "abc"
 * StringUtils.chomp("abc\r\n\r\n") = "abc\r\n"
 * StringUtils.chomp("abc\n\r")     = "abc\n"
 * StringUtils.chomp("abc\n\rabc")  = "abc\n\rabc"
 * StringUtils.chomp("\r")          = ""
 * StringUtils.chomp("\n")          = ""
 * StringUtils.chomp("\r\n")        = ""
 * </pre>
 *
 * @param str  the String to chomp a newline from, may be null
 * @return String without newline, {@code null} if null String input
 */
public static String chomp(final String str) {
    if (isEmpty(str)) {
        return str;
    }
    if (str.length() == 1) {
        final char ch = str.charAt(0);
        if (ch == CharUtils.CR || ch == CharUtils.LF) {
            return EMPTY;
        }
        return str;
    }
    int lastIdx = str.length() - 1;
    final char last = str.charAt(lastIdx);
    if (last == CharUtils.LF) {
        if (str.charAt(lastIdx - 1) == CharUtils.CR) {
            lastIdx--;
        }
    } else if (last != CharUtils.CR) {
        lastIdx++;
    }
    return str.substring(0, lastIdx);
}