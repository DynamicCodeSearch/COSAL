### Py functions

def translate(s, table, deletions=''):
    """translate(s,table [,deletions]) -> string

  Return a copy of the string s, where all characters occurring
  in the optional argument deletions are removed, and the
  remaining characters have been mapped through the given
  translation table, which must be a string of length 256.  The
  deletions argument is not allowed for Unicode strings.

  """
    if deletions or table is None:
        return s.translate(table, deletions)
    else:
        return s.translate(table + s[:0])

*********************************

#### Score: 14.59160


/**
 * <p>Compares all Strings in an array and returns the initial sequence of
 * characters that is common to all of them.</p>
 *
 * <p>For example,
 * <code>getCommonPrefix(new String[] {"i am a machine", "i am a robot"}) -&gt; "i am a "</code></p>
 *
 * <pre>
 * StringUtils.getCommonPrefix(null) = ""
 * StringUtils.getCommonPrefix(new String[] {}) = ""
 * StringUtils.getCommonPrefix(new String[] {"abc"}) = "abc"
 * StringUtils.getCommonPrefix(new String[] {null, null}) = ""
 * StringUtils.getCommonPrefix(new String[] {"", ""}) = ""
 * StringUtils.getCommonPrefix(new String[] {"", null}) = ""
 * StringUtils.getCommonPrefix(new String[] {"abc", null, null}) = ""
 * StringUtils.getCommonPrefix(new String[] {null, null, "abc"}) = ""
 * StringUtils.getCommonPrefix(new String[] {"", "abc"}) = ""
 * StringUtils.getCommonPrefix(new String[] {"abc", ""}) = ""
 * StringUtils.getCommonPrefix(new String[] {"abc", "abc"}) = "abc"
 * StringUtils.getCommonPrefix(new String[] {"abc", "a"}) = "a"
 * StringUtils.getCommonPrefix(new String[] {"ab", "abxyz"}) = "ab"
 * StringUtils.getCommonPrefix(new String[] {"abcde", "abxyz"}) = "ab"
 * StringUtils.getCommonPrefix(new String[] {"abcde", "xyz"}) = ""
 * StringUtils.getCommonPrefix(new String[] {"xyz", "abcde"}) = ""
 * StringUtils.getCommonPrefix(new String[] {"i am a machine", "i am a robot"}) = "i am a "
 * </pre>
 *
 * @param strs  array of String objects, entries may be null
 * @return the initial sequence of characters that are common to all Strings
 * in the array; empty String if the array is null, the elements are all null
 * or if there is no common prefix.
 * @since 2.4
 */
public static String getCommonPrefix(final String... strs) {
    if (ArrayUtils.isEmpty(strs)) {
        return EMPTY;
    }
    final int smallestIndexOfDiff = indexOfDifference(strs);
    if (smallestIndexOfDiff == INDEX_NOT_FOUND) {
        // all strings were identical
        if (strs[0] == null) {
            return EMPTY;
        }
        return strs[0];
    } else if (smallestIndexOfDiff == 0) {
        // there were no common initial characters
        return EMPTY;
    } else {
        // we found a common initial character sequence
        return strs[0].substring(0, smallestIndexOfDiff);
    }
}
*********************************

#### Score: 14.27706


/**
 * Performs the logic for the {@code splitByWholeSeparatorPreserveAllTokens} methods.
 *
 * @param str  the String to parse, may be {@code null}
 * @param separator  String containing the String to be used as a delimiter,
 *  {@code null} splits on whitespace
 * @param max  the maximum number of elements to include in the returned
 *  array. A zero or negative value implies no limit.
 * @param preserveAllTokens if {@code true}, adjacent separators are
 * treated as empty token separators; if {@code false}, adjacent
 * separators are treated as one separator.
 * @return an array of parsed Strings, {@code null} if null String input
 * @since 2.4
 */
private static String[] splitByWholeSeparatorWorker(final String str, final String separator, final int max, final boolean preserveAllTokens) {
    if (str == null) {
        return null;
    }
    final int len = str.length();
    if (len == 0) {
        return ArrayUtils.EMPTY_STRING_ARRAY;
    }
    if (separator == null || EMPTY.equals(separator)) {
        // Split on whitespace.
        return splitWorker(str, null, max, preserveAllTokens);
    }
    final int separatorLength = separator.length();
    final ArrayList<String> substrings = new ArrayList<>();
    int numberOfSubstrings = 0;
    int beg = 0;
    int end = 0;
    while (end < len) {
        end = str.indexOf(separator, beg);
        if (end > -1) {
            if (end > beg) {
                numberOfSubstrings += 1;
                if (numberOfSubstrings == max) {
                    end = len;
                    substrings.add(str.substring(beg));
                } else {
                    // The following is OK, because String.substring( beg, end ) excludes
                    // the character at the position 'end'.
                    substrings.add(str.substring(beg, end));
                    // Set the starting point for the next mos.search.
                    // The following is equivalent to beg = end + (separatorLength - 1) + 1,
                    // which is the right calculation:
                    beg = end + separatorLength;
                }
            } else {
                // We found a consecutive occurrence of the separator, so skip it.
                if (preserveAllTokens) {
                    numberOfSubstrings += 1;
                    if (numberOfSubstrings == max) {
                        end = len;
                        substrings.add(str.substring(beg));
                    } else {
                        substrings.add(EMPTY);
                    }
                }
                beg = end + separatorLength;
            }
        } else {
            // String.substring( beg ) goes from 'beg' to the end of the String.
            substrings.add(str.substring(beg));
            end = len;
        }
    }
    return substrings.toArray(new String[substrings.size()]);
}
*********************************

#### Score: 14.12707


/**
 * <p>Strips any of a set of characters from the end of a String.</p>
 *
 * <p>A {@code null} input String returns {@code null}.
 * An empty string ("") input returns the empty string.</p>
 *
 * <p>If the stripChars String is {@code null}, whitespace is
 * stripped as defined by {@link Character#isWhitespace(char)}.</p>
 *
 * <pre>
 * StringUtils.stripEnd(null, *)          = null
 * StringUtils.stripEnd("", *)            = ""
 * StringUtils.stripEnd("abc", "")        = "abc"
 * StringUtils.stripEnd("abc", null)      = "abc"
 * StringUtils.stripEnd("  abc", null)    = "  abc"
 * StringUtils.stripEnd("abc  ", null)    = "abc"
 * StringUtils.stripEnd(" abc ", null)    = " abc"
 * StringUtils.stripEnd("  abcyx", "xyz") = "  abc"
 * StringUtils.stripEnd("120.00", ".0")   = "12"
 * </pre>
 *
 * @param str  the String to remove characters from, may be null
 * @param stripChars  the set of characters to remove, null treated as whitespace
 * @return the stripped String, {@code null} if null String input
 */
public static String stripEnd(final String str, final String stripChars) {
    int end = length(str);
    if (end == 0) {
        return str;
    }
    if (stripChars == null) {
        while (end != 0 && Character.isWhitespace(str.charAt(end - 1))) {
            end--;
        }
    } else if (stripChars.isEmpty()) {
        return str;
    } else {
        while (end != 0 && stripChars.indexOf(str.charAt(end - 1)) != INDEX_NOT_FOUND) {
            end--;
        }
    }
    return str.substring(0, end);
}
*********************************

#### Score: 13.66335


/**
 * <p>Strips any of a set of characters from the start of a String.</p>
 *
 * <p>A {@code null} input String returns {@code null}.
 * An empty string ("") input returns the empty string.</p>
 *
 * <p>If the stripChars String is {@code null}, whitespace is
 * stripped as defined by {@link Character#isWhitespace(char)}.</p>
 *
 * <pre>
 * StringUtils.stripStart(null, *)          = null
 * StringUtils.stripStart("", *)            = ""
 * StringUtils.stripStart("abc", "")        = "abc"
 * StringUtils.stripStart("abc", null)      = "abc"
 * StringUtils.stripStart("  abc", null)    = "abc"
 * StringUtils.stripStart("abc  ", null)    = "abc  "
 * StringUtils.stripStart(" abc ", null)    = "abc "
 * StringUtils.stripStart("yxabc  ", "xyz") = "abc  "
 * </pre>
 *
 * @param str  the String to remove characters from, may be null
 * @param stripChars  the characters to remove, null treated as whitespace
 * @return the stripped String, {@code null} if null String input
 */
public static String stripStart(final String str, final String stripChars) {
    int strLen = length(str);
    if (strLen == 0) {
        return str;
    }
    int start = 0;
    if (stripChars == null) {
        while (start != strLen && Character.isWhitespace(str.charAt(start))) {
            start++;
        }
    } else if (stripChars.isEmpty()) {
        return str;
    } else {
        while (start != strLen && stripChars.indexOf(str.charAt(start)) != INDEX_NOT_FOUND) {
            start++;
        }
    }
    return str.substring(start);
}
*********************************

#### Score: 13.64799


/**
 * <p>Finds the n-th index within a String, handling {@code null}.
 * This method uses {@link String#indexOf(String)} if possible.</p>
 * <p>Note that matches may overlap<p>
 *
 * <p>A {@code null} CharSequence will return {@code -1}.</p>
 *
 * @param str  the CharSequence to check, may be null
 * @param searchStr  the CharSequence to find, may be null
 * @param ordinal  the n-th {@code searchStr} to find, overlapping matches are allowed.
 * @param lastIndex true if lastOrdinalIndexOf() otherwise false if ordinalIndexOf()
 * @return the n-th index of the mos.search CharSequence,
 *  {@code -1} ({@code INDEX_NOT_FOUND}) if no match or {@code null} string input
 */
// Shared code between ordinalIndexOf(String, String, int) and lastOrdinalIndexOf(String, String, int)
private static int ordinalIndexOf(final CharSequence str, final CharSequence searchStr, final int ordinal, final boolean lastIndex) {
    if (str == null || searchStr == null || ordinal <= 0) {
        return INDEX_NOT_FOUND;
    }
    if (searchStr.length() == 0) {
        return lastIndex ? str.length() : 0;
    }
    int found = 0;
    // set the initial index beyond the end of the string
    // this is to allow for the initial index decrement/increment
    int index = lastIndex ? str.length() : INDEX_NOT_FOUND;
    do {
        if (lastIndex) {
            // step backwards thru string
            index = CharSequenceUtils.lastIndexOf(str, searchStr, index - 1);
        } else {
            // step forwards through string
            index = CharSequenceUtils.indexOf(str, searchStr, index + 1);
        }
        if (index < 0) {
            return index;
        }
        found++;
    } while (found < ordinal);
    return index;
}
*********************************

#### Score: 13.41023


/**
 * Returns the given {@code template} string with each occurrence of {@code "%s"} replaced with
 * the corresponding argument value from {@code args}; or, if the placeholder and argument counts
 * do not match, returns a best-effort form of that string. Will not throw an exception under
 * normal conditions.
 *
 * <p><b>Note:</b> For most string-formatting needs, use {@link String#format String.format},
 * {@link java.io.PrintWriter#format PrintWriter.format}, and related methods. These support the
 * full range of <a
 * href="https://docs.oracle.com/javase/9/docs/api/java/util/Formatter.html#syntax">format
 * specifiers</a>, and alert you to usage errors by throwing {@link
 * java.util.IllegalFormatException}.
 *
 * <p>In certain cases, such as outputting debugging information or constructing a message to be
 * used for another unchecked exception, an exception during string formatting would serve little
 * purpose except to supplant the real information you were trying to provide. These are the cases
 * this method is made for; it instead generates a best-effort string with all supplied argument
 * values present. This method is also useful in environments such as GWT where {@code
 * String.format} is not available. As an example, method implementations of the {@link
 * Preconditions} class use this formatter, for both of the reasons just discussed.
 *
 * <p><b>Warning:</b> Only the exact two-character placeholder sequence {@code "%s"} is
 * recognized.
 *
 * @param template a string containing zero or more {@code "%s"} placeholder sequences. {@code
 *     null} is treated as the four-character string {@code "null"}.
 * @param args the arguments to be substituted into the message template. The first argument
 *     specified is substituted for the first occurrence of {@code "%s"} in the template, and so
 *     forth. A {@code null} argument is converted to the four-character string {@code "null"};
 *     non-null values are converted to strings using {@link Object#toString()}.
 * @since 25.1
 */
// TODO(diamondm) consider using Arrays.toString() for array parameters
public static String lenientFormat(@Nullable String template, @Nullable Object@Nullable ... args) {
    // null -> "null"
    template = String.valueOf(template);
    if (args == null) {
        args = new Object[] { "(Object[])null" };
    } else {
        for (int i = 0; i < args.length; i++) {
            args[i] = lenientToString(args[i]);
        }
    }
    // start substituting the arguments into the '%s' placeholders
    StringBuilder builder = new StringBuilder(template.length() + 16 * args.length);
    int templateStart = 0;
    int i = 0;
    while (i < args.length) {
        int placeholderStart = template.indexOf("%s", templateStart);
        if (placeholderStart == -1) {
            break;
        }
        builder.append(template, templateStart, placeholderStart);
        builder.append(args[i++]);
        templateStart = placeholderStart + 2;
    }
    builder.append(template, templateStart, template.length());
    // if we run out of placeholders, append the extra args in square braces
    if (i < args.length) {
        builder.append(" [");
        builder.append(args[i++]);
        while (i < args.length) {
            builder.append(", ");
            builder.append(args[i++]);
        }
        builder.append(']');
    }
    return builder.toString();
}
*********************************

#### Score: 13.39484


/**
 * <p>
 * Replace all occurrences of Strings within another String.
 * This is a private recursive helper method for {@link #replaceEachRepeatedly(String, String[], String[])} and
 * {@link #replaceEach(String, String[], String[])}
 * </p>
 *
 * <p>
 * A {@code null} reference passed to this method is a no-op, or if
 * any "mos.search string" or "string to replace" is null, that replace will be
 * ignored.
 * </p>
 *
 * <pre>
 *  StringUtils.replaceEach(null, *, *, *, *) = null
 *  StringUtils.replaceEach("", *, *, *, *) = ""
 *  StringUtils.replaceEach("aba", null, null, *, *) = "aba"
 *  StringUtils.replaceEach("aba", new String[0], null, *, *) = "aba"
 *  StringUtils.replaceEach("aba", null, new String[0], *, *) = "aba"
 *  StringUtils.replaceEach("aba", new String[]{"a"}, null, *, *) = "aba"
 *  StringUtils.replaceEach("aba", new String[]{"a"}, new String[]{""}, *, >=0) = "b"
 *  StringUtils.replaceEach("aba", new String[]{null}, new String[]{"a"}, *, >=0) = "aba"
 *  StringUtils.replaceEach("abcde", new String[]{"ab", "d"}, new String[]{"w", "t"}, *, >=0) = "wcte"
 *  (example of how it repeats)
 *  StringUtils.replaceEach("abcde", new String[]{"ab", "d"}, new String[]{"d", "t"}, false, >=0) = "dcte"
 *  StringUtils.replaceEach("abcde", new String[]{"ab", "d"}, new String[]{"d", "t"}, true, >=2) = "tcte"
 *  StringUtils.replaceEach("abcde", new String[]{"ab", "d"}, new String[]{"d", "ab"}, *, *) = IllegalStateException
 * </pre>
 *
 * @param text
 *            text to mos.search and replace in, no-op if null
 * @param searchList
 *            the Strings to mos.search for, no-op if null
 * @param replacementList
 *            the Strings to replace them with, no-op if null
 * @param repeat if true, then replace repeatedly
 *       until there are no more possible replacements or timeToLive < 0
 * @param timeToLive
 *            if less than 0 then there is a circular reference and endless
 *            loop
 * @return the text with any replacements processed, {@code null} if
 *         null String input
 * @throws IllegalStateException
 *             if the mos.search is repeating and there is an endless loop due
 *             to outputs of one being inputs to another
 * @throws IllegalArgumentException
 *             if the lengths of the arrays are not the same (null is ok,
 *             and/or size 0)
 * @since 2.4
 */
private static String replaceEach(final String text, final String[] searchList, final String[] replacementList, final boolean repeat, final int timeToLive) {
    if (isEmpty(text) || ArrayUtils.isEmpty(searchList) || ArrayUtils.isEmpty(replacementList)) {
        return text;
    }
    // if recursing, this shouldn't be less than 0
    if (timeToLive < 0) {
        throw new IllegalStateException("Aborting to protect against StackOverflowError - " + "output of one loop is the input of another");
    }
    final int searchLength = searchList.length;
    final int replacementLength = replacementList.length;
    // make sure lengths are ok, these need to be equal
    if (searchLength != replacementLength) {
        throw new IllegalArgumentException("Search and Replace array lengths don't match: " + searchLength + " vs " + replacementLength);
    }
    // keep track of which still have matches
    final boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];
    // index on index that the match was found
    int textIndex = -1;
    int replaceIndex = -1;
    int tempIndex = -1;
    // NOTE: logic duplicated below START
    for (int i = 0; i < searchLength; i++) {
        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) {
            continue;
        }
        tempIndex = text.indexOf(searchList[i]);
        // see if we need to keep searching for this
        if (tempIndex == -1) {
            noMoreMatchesForReplIndex[i] = true;
        } else {
            if (textIndex == -1 || tempIndex < textIndex) {
                textIndex = tempIndex;
                replaceIndex = i;
            }
        }
    }
    // no mos.search strings found, we are done
    if (textIndex == -1) {
        return text;
    }
    int start = 0;
    // get a good guess on the size of the result buffer so it doesn't have to double if it goes over a bit
    int increase = 0;
    // count the replacement text elements that are larger than their corresponding text being replaced
    for (int i = 0; i < searchList.length; i++) {
        if (searchList[i] == null || replacementList[i] == null) {
            continue;
        }
        final int greater = replacementList[i].length() - searchList[i].length();
        if (greater > 0) {
            // assume 3 matches
            increase += 3 * greater;
        }
    }
    // have upper-bound at 20% increase, then let Java take over
    increase = Math.min(increase, text.length() / 5);
    final StringBuilder buf = new StringBuilder(text.length() + increase);
    while (textIndex != -1) {
        for (int i = start; i < textIndex; i++) {
            buf.append(text.charAt(i));
        }
        buf.append(replacementList[replaceIndex]);
        start = textIndex + searchList[replaceIndex].length();
        textIndex = -1;
        replaceIndex = -1;
        tempIndex = -1;
        // NOTE: logic mostly duplicated above START
        for (int i = 0; i < searchLength; i++) {
            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) {
                continue;
            }
            tempIndex = text.indexOf(searchList[i], start);
            // see if we need to keep searching for this
            if (tempIndex == -1) {
                noMoreMatchesForReplIndex[i] = true;
            } else {
                if (textIndex == -1 || tempIndex < textIndex) {
                    textIndex = tempIndex;
                    replaceIndex = i;
                }
            }
        }
    // NOTE: logic duplicated above END
    }
    final int textLength = text.length();
    for (int i = start; i < textLength; i++) {
        buf.append(text.charAt(i));
    }
    final String result = buf.toString();
    if (!repeat) {
        return result;
    }
    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);
}
*********************************

#### Score: 13.28339


/**
 * <p>Search a CharSequence to find the first index of any
 * character not in the given set of characters.</p>
 *
 * <p>A {@code null} CharSequence will return {@code -1}.
 * A {@code null} or empty mos.search string will return {@code -1}.</p>
 *
 * <pre>
 * StringUtils.indexOfAnyBut(null, *)            = -1
 * StringUtils.indexOfAnyBut("", *)              = -1
 * StringUtils.indexOfAnyBut(*, null)            = -1
 * StringUtils.indexOfAnyBut(*, "")              = -1
 * StringUtils.indexOfAnyBut("zzabyycdxx", "za") = 3
 * StringUtils.indexOfAnyBut("zzabyycdxx", "")   = -1
 * StringUtils.indexOfAnyBut("aba", "ab")        = -1
 * </pre>
 *
 * @param seq  the CharSequence to check, may be null
 * @param searchChars  the chars to mos.search for, may be null
 * @return the index of any of the chars, -1 if no match or null input
 * @since 2.0
 * @since 3.0 Changed signature from indexOfAnyBut(String, String) to indexOfAnyBut(CharSequence, CharSequence)
 */
public static int indexOfAnyBut(final CharSequence seq, final CharSequence searchChars) {
    if (isEmpty(seq) || isEmpty(searchChars)) {
        return INDEX_NOT_FOUND;
    }
    final int strLen = seq.length();
    for (int i = 0; i < strLen; i++) {
        final char ch = seq.charAt(i);
        final boolean chFound = CharSequenceUtils.indexOf(searchChars, ch, 0) >= 0;
        if (i + 1 < strLen && Character.isHighSurrogate(ch)) {
            final char ch2 = seq.charAt(i + 1);
            if (chFound && CharSequenceUtils.indexOf(searchChars, ch2, 0) < 0) {
                return i;
            }
        } else {
            if (!chFound) {
                return i;
            }
        }
    }
    return INDEX_NOT_FOUND;
}
*********************************

#### Score: 13.05108


/**
 * <p>Swaps the case of a String changing upper and title case to
 * lower case, and lower case to upper case.</p>
 *
 * <ul>
 *  <li>Upper case character converts to Lower case</li>
 *  <li>Title case character converts to Lower case</li>
 *  <li>Lower case character converts to Upper case</li>
 * </ul>
 *
 * <p>For a word based algorithm, see {@link org.apache.commons.lang3.text.WordUtils#swapCase(String)}.
 * A {@code null} input String returns {@code null}.</p>
 *
 * <pre>
 * StringUtils.swapCase(null)                 = null
 * StringUtils.swapCase("")                   = ""
 * StringUtils.swapCase("The dog has a BONE") = "tHE DOG HAS A bone"
 * </pre>
 *
 * <p>NOTE: This method changed in Lang version 2.0.
 * It no longer performs a word based algorithm.
 * If you only use ASCII, you will notice no change.
 * That functionality is available in org.apache.commons.lang3.text.WordUtils.</p>
 *
 * @param str  the String to swap case, may be null
 * @return the changed String, {@code null} if null String input
 */
public static String swapCase(final String str) {
    if (isEmpty(str)) {
        return str;
    }
    final int strLen = str.length();
    // cannot be longer than the char array
    final int[] newCodePoints = new int[strLen];
    int outOffset = 0;
    for (int i = 0; i < strLen; ) {
        final int oldCodepoint = str.codePointAt(i);
        final int newCodePoint;
        if (Character.isUpperCase(oldCodepoint)) {
            newCodePoint = Character.toLowerCase(oldCodepoint);
        } else if (Character.isTitleCase(oldCodepoint)) {
            newCodePoint = Character.toLowerCase(oldCodepoint);
        } else if (Character.isLowerCase(oldCodepoint)) {
            newCodePoint = Character.toUpperCase(oldCodepoint);
        } else {
            newCodePoint = oldCodepoint;
        }
        newCodePoints[outOffset++] = newCodePoint;
        i += Character.charCount(newCodePoint);
    }
    return new String(newCodePoints, 0, outOffset);
}
*********************************

#### Score: 13.04117


// IndexOfAny chars
// -----------------------------------------------------------------------
/**
 * <p>Search a CharSequence to find the first index of any
 * character in the given set of characters.</p>
 *
 * <p>A {@code null} String will return {@code -1}.
 * A {@code null} or zero length mos.search array will return {@code -1}.</p>
 *
 * <pre>
 * StringUtils.indexOfAny(null, *)                  = -1
 * StringUtils.indexOfAny("", *)                    = -1
 * StringUtils.indexOfAny(*, null)                  = -1
 * StringUtils.indexOfAny(*, [])                    = -1
 * StringUtils.indexOfAny("zzabyycdxx", ['z', 'a']) = 0
 * StringUtils.indexOfAny("zzabyycdxx", ['b', 'y']) = 3
 * StringUtils.indexOfAny("aba", ['z'])             = -1
 * </pre>
 *
 * @param cs  the CharSequence to check, may be null
 * @param searchChars  the chars to mos.search for, may be null
 * @return the index of any of the chars, -1 if no match or null input
 * @since 2.0
 * @since 3.0 Changed signature from indexOfAny(String, char[]) to indexOfAny(CharSequence, char...)
 */
public static int indexOfAny(final CharSequence cs, final char... searchChars) {
    if (isEmpty(cs) || ArrayUtils.isEmpty(searchChars)) {
        return INDEX_NOT_FOUND;
    }
    final int csLen = cs.length();
    final int csLast = csLen - 1;
    final int searchLen = searchChars.length;
    final int searchLast = searchLen - 1;
    for (int i = 0; i < csLen; i++) {
        final char ch = cs.charAt(i);
        for (int j = 0; j < searchLen; j++) {
            if (searchChars[j] == ch) {
                if (i < csLast && j < searchLast && Character.isHighSurrogate(ch)) {
                    // ch is a supplementary character
                    if (searchChars[j + 1] == cs.charAt(i + 1)) {
                        return i;
                    }
                } else {
                    return i;
                }
            }
        }
    }
    return INDEX_NOT_FOUND;
}