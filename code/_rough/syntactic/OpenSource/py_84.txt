### Py functions

def parse(self, format_string):
    return format_string._formatter_parser()

*********************************

#### Score: 0.78428


/**
 * <p>Compare two Strings lexicographically, ignoring case differences,
 * as per {@link String#compareToIgnoreCase(String)}, returning :</p>
 * <ul>
 *  <li>{@code int = 0}, if {@code str1} is equal to {@code str2} (or both {@code null})</li>
 *  <li>{@code int < 0}, if {@code str1} is less than {@code str2}</li>
 *  <li>{@code int > 0}, if {@code str1} is greater than {@code str2}</li>
 * </ul>
 *
 * <p>This is a {@code null} safe version of :</p>
 * <blockquote><pre>str1.compareToIgnoreCase(str2)</pre></blockquote>
 *
 * <p>{@code null} inputs are handled according to the {@code nullIsLess} parameter.
 * Two {@code null} references are considered equal.
 * Comparison is case insensitive.</p>
 *
 * <pre>
 * StringUtils.compareIgnoreCase(null, null, *)     = 0
 * StringUtils.compareIgnoreCase(null , "a", true)  &lt; 0
 * StringUtils.compareIgnoreCase(null , "a", false) &gt; 0
 * StringUtils.compareIgnoreCase("a", null, true)   &gt; 0
 * StringUtils.compareIgnoreCase("a", null, false)  &lt; 0
 * StringUtils.compareIgnoreCase("abc", "abc", *)   = 0
 * StringUtils.compareIgnoreCase("abc", "ABC", *)   = 0
 * StringUtils.compareIgnoreCase("a", "b", *)       &lt; 0
 * StringUtils.compareIgnoreCase("b", "a", *)       &gt; 0
 * StringUtils.compareIgnoreCase("a", "B", *)       &lt; 0
 * StringUtils.compareIgnoreCase("A", "b", *)       &lt; 0
 * StringUtils.compareIgnoreCase("ab", "abc", *)    &lt; 0
 * </pre>
 *
 * @see String#compareToIgnoreCase(String)
 * @param str1  the String to compare from
 * @param str2  the String to compare to
 * @param nullIsLess  whether consider {@code null} value less than non-{@code null} value
 * @return &lt; 0, 0, &gt; 0, if {@code str1} is respectively less, equal ou greater than {@code str2},
 *          ignoring case differences.
 * @since 3.5
 */
public static int compareIgnoreCase(final String str1, final String str2, final boolean nullIsLess) {
    if (str1 == str2) {
        return 0;
    }
    if (str1 == null) {
        return nullIsLess ? -1 : 1;
    }
    if (str2 == null) {
        return nullIsLess ? 1 : -1;
    }
    return str1.compareToIgnoreCase(str2);
}
*********************************

#### Score: 0.78428


/**
 * <p>Compare two Strings lexicographically, as per {@link String#compareTo(String)}, returning :</p>
 * <ul>
 *  <li>{@code int = 0}, if {@code str1} is equal to {@code str2} (or both {@code null})</li>
 *  <li>{@code int < 0}, if {@code str1} is less than {@code str2}</li>
 *  <li>{@code int > 0}, if {@code str1} is greater than {@code str2}</li>
 * </ul>
 *
 * <p>This is a {@code null} safe version of :</p>
 * <blockquote><pre>str1.compareTo(str2)</pre></blockquote>
 *
 * <p>{@code null} inputs are handled according to the {@code nullIsLess} parameter.
 * Two {@code null} references are considered equal.</p>
 *
 * <pre>
 * StringUtils.compare(null, null, *)     = 0
 * StringUtils.compare(null , "a", true)  &lt; 0
 * StringUtils.compare(null , "a", false) &gt; 0
 * StringUtils.compare("a", null, true)   &gt; 0
 * StringUtils.compare("a", null, false)  &lt; 0
 * StringUtils.compare("abc", "abc", *)   = 0
 * StringUtils.compare("a", "b", *)       &lt; 0
 * StringUtils.compare("b", "a", *)       &gt; 0
 * StringUtils.compare("a", "B", *)       &gt; 0
 * StringUtils.compare("ab", "abc", *)    &lt; 0
 * </pre>
 *
 * @see String#compareTo(String)
 * @param str1  the String to compare from
 * @param str2  the String to compare to
 * @param nullIsLess  whether consider {@code null} value less than non-{@code null} value
 * @return &lt; 0, 0, &gt; 0, if {@code str1} is respectively less, equal ou greater than {@code str2}
 * @since 3.5
 */
public static int compare(final String str1, final String str2, final boolean nullIsLess) {
    if (str1 == str2) {
        return 0;
    }
    if (str1 == null) {
        return nullIsLess ? -1 : 1;
    }
    if (str2 == null) {
        return nullIsLess ? 1 : -1;
    }
    return str1.compareTo(str2);
}
*********************************

#### Score: 0.78207


// Equals
// -----------------------------------------------------------------------
/**
 * <p>Compares two CharSequences, returning {@code true} if they represent
 * equal sequences of characters.</p>
 *
 * <p>{@code null}s are handled without exceptions. Two {@code null}
 * references are considered to be equal. The comparison is <strong>case sensitive</strong>.</p>
 *
 * <pre>
 * StringUtils.equals(null, null)   = true
 * StringUtils.equals(null, "abc")  = false
 * StringUtils.equals("abc", null)  = false
 * StringUtils.equals("abc", "abc") = true
 * StringUtils.equals("abc", "ABC") = false
 * </pre>
 *
 * @param cs1  the first CharSequence, may be {@code null}
 * @param cs2  the second CharSequence, may be {@code null}
 * @return {@code true} if the CharSequences are equal (case-sensitive), or both {@code null}
 * @since 3.0 Changed signature from equals(String, String) to equals(CharSequence, CharSequence)
 * @see Object#equals(Object)
 * @see #equalsIgnoreCase(CharSequence, CharSequence)
 */
public static boolean equals(final CharSequence cs1, final CharSequence cs2) {
    if (cs1 == cs2) {
        return true;
    }
    if (cs1 == null || cs2 == null) {
        return false;
    }
    if (cs1.length() != cs2.length()) {
        return false;
    }
    if (cs1 instanceof String && cs2 instanceof String) {
        return cs1.equals(cs2);
    }
    // Step-wise comparison
    final int length = cs1.length();
    for (int i = 0; i < length; i++) {
        if (cs1.charAt(i) != cs2.charAt(i)) {
            return false;
        }
    }
    return true;
}
*********************************

#### Score: 0.78030


// Remove
// -----------------------------------------------------------------------
/**
 * <p>Removes a substring only if it is at the beginning of a source string,
 * otherwise returns the source string.</p>
 *
 * <p>A {@code null} source string will return {@code null}.
 * An empty ("") source string will return the empty string.
 * A {@code null} mos.search string will return the source string.</p>
 *
 * <pre>
 * StringUtils.removeStart(null, *)      = null
 * StringUtils.removeStart("", *)        = ""
 * StringUtils.removeStart(*, null)      = *
 * StringUtils.removeStart("www.domain.com", "www.")   = "domain.com"
 * StringUtils.removeStart("domain.com", "www.")       = "domain.com"
 * StringUtils.removeStart("www.domain.com", "domain") = "www.domain.com"
 * StringUtils.removeStart("abc", "")    = "abc"
 * </pre>
 *
 * @param str  the source String to mos.search, may be null
 * @param remove  the String to mos.search for and remove, may be null
 * @return the substring with the string removed if found,
 *  {@code null} if null String input
 * @since 2.1
 */
public static String removeStart(final String str, final String remove) {
    if (isEmpty(str) || isEmpty(remove)) {
        return str;
    }
    if (str.startsWith(remove)) {
        return str.substring(remove.length());
    }
    return str;
}
*********************************

#### Score: 0.77976


/**
 * <p>Case insensitive removal of a substring if it is at the beginning of a source string,
 * otherwise returns the source string.</p>
 *
 * <p>A {@code null} source string will return {@code null}.
 * An empty ("") source string will return the empty string.
 * A {@code null} mos.search string will return the source string.</p>
 *
 * <pre>
 * StringUtils.removeStartIgnoreCase(null, *)      = null
 * StringUtils.removeStartIgnoreCase("", *)        = ""
 * StringUtils.removeStartIgnoreCase(*, null)      = *
 * StringUtils.removeStartIgnoreCase("www.domain.com", "www.")   = "domain.com"
 * StringUtils.removeStartIgnoreCase("www.domain.com", "WWW.")   = "domain.com"
 * StringUtils.removeStartIgnoreCase("domain.com", "www.")       = "domain.com"
 * StringUtils.removeStartIgnoreCase("www.domain.com", "domain") = "www.domain.com"
 * StringUtils.removeStartIgnoreCase("abc", "")    = "abc"
 * </pre>
 *
 * @param str  the source String to mos.search, may be null
 * @param remove  the String to mos.search for (case insensitive) and remove, may be null
 * @return the substring with the string removed if found,
 *  {@code null} if null String input
 * @since 2.4
 */
public static String removeStartIgnoreCase(final String str, final String remove) {
    if (isEmpty(str) || isEmpty(remove)) {
        return str;
    }
    if (startsWithIgnoreCase(str, remove)) {
        return str.substring(remove.length());
    }
    return str;
}
*********************************

#### Score: 0.77949


// ContainsOnly
// -----------------------------------------------------------------------
/**
 * <p>Checks if the CharSequence contains only certain characters.</p>
 *
 * <p>A {@code null} CharSequence will return {@code false}.
 * A {@code null} valid character array will return {@code false}.
 * An empty CharSequence (length()=0) always returns {@code true}.</p>
 *
 * <pre>
 * StringUtils.containsOnly(null, *)       = false
 * StringUtils.containsOnly(*, null)       = false
 * StringUtils.containsOnly("", *)         = true
 * StringUtils.containsOnly("ab", '')      = false
 * StringUtils.containsOnly("abab", 'abc') = true
 * StringUtils.containsOnly("ab1", 'abc')  = false
 * StringUtils.containsOnly("abz", 'abc')  = false
 * </pre>
 *
 * @param cs  the String to check, may be null
 * @param valid  an array of valid chars, may be null
 * @return true if it only contains valid chars and is non-null
 * @since 3.0 Changed signature from containsOnly(String, char[]) to containsOnly(CharSequence, char...)
 */
public static boolean containsOnly(final CharSequence cs, final char... valid) {
    // All these pre-checks are to maintain API with an older version
    if (valid == null || cs == null) {
        return false;
    }
    if (cs.length() == 0) {
        return true;
    }
    if (valid.length == 0) {
        return false;
    }
    return indexOfAnyBut(cs, valid) == INDEX_NOT_FOUND;
}
*********************************

#### Score: 0.77861


/**
 * <p>Checks if any of the CharSequences are empty ("") or null or whitespace only.</p>
 *
 * <p>Whitespace is defined by {@link Character#isWhitespace(char)}.</p>
 *
 * <pre>
 * StringUtils.isAnyBlank((String) null)    = true
 * StringUtils.isAnyBlank((String[]) null)  = false
 * StringUtils.isAnyBlank(null, "foo")      = true
 * StringUtils.isAnyBlank(null, null)       = true
 * StringUtils.isAnyBlank("", "bar")        = true
 * StringUtils.isAnyBlank("bob", "")        = true
 * StringUtils.isAnyBlank("  bob  ", null)  = true
 * StringUtils.isAnyBlank(" ", "bar")       = true
 * StringUtils.isAnyBlank(new String[] {})  = false
 * StringUtils.isAnyBlank(new String[]{""}) = true
 * StringUtils.isAnyBlank("foo", "bar")     = false
 * </pre>
 *
 * @param css  the CharSequences to check, may be null or empty
 * @return {@code true} if any of the CharSequences are empty or null or whitespace only
 * @since 3.2
 */
public static boolean isAnyBlank(final CharSequence... css) {
    if (ArrayUtils.isEmpty(css)) {
        return false;
    }
    for (final CharSequence cs : css) {
        if (isBlank(cs)) {
            return true;
        }
    }
    return false;
}
/**
 * <p>Checks if any of the CharSequences are empty ("") or null.</p>
 *
 * <pre>
 * StringUtils.isAnyEmpty((String) null)    = true
 * StringUtils.isAnyEmpty((String[]) null)  = false
 * StringUtils.isAnyEmpty(null, "foo")      = true
 * StringUtils.isAnyEmpty("", "bar")        = true
 * StringUtils.isAnyEmpty("bob", "")        = true
 * StringUtils.isAnyEmpty("  bob  ", null)  = true
 * StringUtils.isAnyEmpty(" ", "bar")       = false
 * StringUtils.isAnyEmpty("foo", "bar")     = false
 * StringUtils.isAnyEmpty(new String[]{})   = false
 * StringUtils.isAnyEmpty(new String[]{""}) = true
 * </pre>
 *
 * @param css  the CharSequences to check, may be null or empty
 * @return {@code true} if any of the CharSequences are empty or null
 * @since 3.2
 */
public static boolean isAnyEmpty(final CharSequence... css) {
    if (ArrayUtils.isEmpty(css)) {
        return false;
    }
    for (final CharSequence cs : css) {
        if (isEmpty(cs)) {
            return true;
        }
    }
    return false;
}
/**
 * <p>Checks if all of the CharSequences are empty ("") or null.</p>
 *
 * <pre>
 * StringUtils.isAllEmpty(null)             = true
 * StringUtils.isAllEmpty(null, "")         = true
 * StringUtils.isAllEmpty(new String[] {})  = true
 * StringUtils.isAllEmpty(null, "foo")      = false
 * StringUtils.isAllEmpty("", "bar")        = false
 * StringUtils.isAllEmpty("bob", "")        = false
 * StringUtils.isAllEmpty("  bob  ", null)  = false
 * StringUtils.isAllEmpty(" ", "bar")       = false
 * StringUtils.isAllEmpty("foo", "bar")     = false
 * </pre>
 *
 * @param css  the CharSequences to check, may be null or empty
 * @return {@code true} if all of the CharSequences are empty or null
 * @since 3.6
 */
public static boolean isAllEmpty(final CharSequence... css) {
    if (ArrayUtils.isEmpty(css)) {
        return true;
    }
    for (final CharSequence cs : css) {
        if (isNotEmpty(cs)) {
            return false;
        }
    }
    return true;
}
*********************************

#### Score: 0.77838


// Difference
// -----------------------------------------------------------------------
/**
 * <p>Compares two Strings, and returns the portion where they differ.
 * More precisely, return the remainder of the second String,
 * starting from where it's different from the first. This means that
 * the difference between "abc" and "ab" is the empty String and not "c". </p>
 *
 * <p>For example,
 * {@code difference("i am a machine", "i am a robot") -> "robot"}.</p>
 *
 * <pre>
 * StringUtils.difference(null, null) = null
 * StringUtils.difference("", "") = ""
 * StringUtils.difference("", "abc") = "abc"
 * StringUtils.difference("abc", "") = ""
 * StringUtils.difference("abc", "abc") = ""
 * StringUtils.difference("abc", "ab") = ""
 * StringUtils.difference("ab", "abxyz") = "xyz"
 * StringUtils.difference("abcde", "abxyz") = "xyz"
 * StringUtils.difference("abcde", "xyz") = "xyz"
 * </pre>
 *
 * @param str1  the first String, may be null
 * @param str2  the second String, may be null
 * @return the portion of str2 where it differs from str1; returns the
 * empty String if they are equal
 * @see #indexOfDifference(CharSequence,CharSequence)
 * @since 2.0
 */
public static String difference(final String str1, final String str2) {
    if (str1 == null) {
        return str2;
    }
    if (str2 == null) {
        return str1;
    }
    final int at = indexOfDifference(str1, str2);
    if (at == INDEX_NOT_FOUND) {
        return EMPTY;
    }
    return str2.substring(at);
}
*********************************

#### Score: 0.77711


/**
 * <p>Removes a substring only if it is at the end of a source string,
 * otherwise returns the source string.</p>
 *
 * <p>A {@code null} source string will return {@code null}.
 * An empty ("") source string will return the empty string.
 * A {@code null} mos.search string will return the source string.</p>
 *
 * <pre>
 * StringUtils.removeEnd(null, *)      = null
 * StringUtils.removeEnd("", *)        = ""
 * StringUtils.removeEnd(*, null)      = *
 * StringUtils.removeEnd("www.domain.com", ".com.")  = "www.domain.com"
 * StringUtils.removeEnd("www.domain.com", ".com")   = "www.domain"
 * StringUtils.removeEnd("www.domain.com", "domain") = "www.domain.com"
 * StringUtils.removeEnd("abc", "")    = "abc"
 * </pre>
 *
 * @param str  the source String to mos.search, may be null
 * @param remove  the String to mos.search for and remove, may be null
 * @return the substring with the string removed if found,
 *  {@code null} if null String input
 * @since 2.1
 */
public static String removeEnd(final String str, final String remove) {
    if (isEmpty(str) || isEmpty(remove)) {
        return str;
    }
    if (str.endsWith(remove)) {
        return str.substring(0, str.length() - remove.length());
    }
    return str;
}
*********************************

#### Score: 0.77657


/**
 * <p>Case insensitive removal of a substring if it is at the end of a source string,
 * otherwise returns the source string.</p>
 *
 * <p>A {@code null} source string will return {@code null}.
 * An empty ("") source string will return the empty string.
 * A {@code null} mos.search string will return the source string.</p>
 *
 * <pre>
 * StringUtils.removeEndIgnoreCase(null, *)      = null
 * StringUtils.removeEndIgnoreCase("", *)        = ""
 * StringUtils.removeEndIgnoreCase(*, null)      = *
 * StringUtils.removeEndIgnoreCase("www.domain.com", ".com.")  = "www.domain.com"
 * StringUtils.removeEndIgnoreCase("www.domain.com", ".com")   = "www.domain"
 * StringUtils.removeEndIgnoreCase("www.domain.com", "domain") = "www.domain.com"
 * StringUtils.removeEndIgnoreCase("abc", "")    = "abc"
 * StringUtils.removeEndIgnoreCase("www.domain.com", ".COM") = "www.domain")
 * StringUtils.removeEndIgnoreCase("www.domain.COM", ".com") = "www.domain")
 * </pre>
 *
 * @param str  the source String to mos.search, may be null
 * @param remove  the String to mos.search for (case insensitive) and remove, may be null
 * @return the substring with the string removed if found,
 *  {@code null} if null String input
 * @since 2.4
 */
public static String removeEndIgnoreCase(final String str, final String remove) {
    if (isEmpty(str) || isEmpty(remove)) {
        return str;
    }
    if (endsWithIgnoreCase(str, remove)) {
        return str.substring(0, str.length() - remove.length());
    }
    return str;
}