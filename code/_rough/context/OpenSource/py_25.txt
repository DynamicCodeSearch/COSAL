### Py Tokens: gallahad, elements, object, argument, len, update, another, input, initialize, mapping, given, super, counts, iterable, count, needs, typeerror, keyword, create, counter, new, descriptor, arguments, error, expected, got, type, empty 

### Py functions

def __init__(*args, **kwds):

  if not args:
    raise TypeError("descriptor '__init__' of 'Counter' object "
                    "needs an argument")
  self = args[0]
  args = args[1:]
  if len(args) > 1:
    raise TypeError('expected at most 1 arguments, got %d' % len(args))
  super(Counter, self).__init__()
  self.update(*args, **kwds)
*********************************

#### Score: 11.33145


#### Java Tokens: exception, argument, eager, gwt, large:, integer, repeated, required, empty, zero, number, copies, checkargument, len, longsize, hey, large, containing, count, index, heyheyhey, check, illegal, benchmark, input, system, null, size, invalid, bounds, returns, must, illegalargumentexception, getchars, code, string, stringsrepeatbenchmark, checknotnull, count:, update, arrayindexoutofboundsexception, non, example, times, negative, concatenated, strings, array, param, arraycopy, repeat, get, length, nonnegative, specific, non-null, consisting, modify, chars 


public static String repeat(String string, int count) {
    
    checkNotNull(string);
    if (count <= 1) {
        checkArgument(count >= 0, "invalid count: %s", count);
        return (count == 0) ? "" : string;
    }
    
    final int len = string.length();
    final long longSize = (long) len * (long) count;
    final int size = (int) longSize;
    if (size != longSize) {
        throw new ArrayIndexOutOfBoundsException("Required array size too large: " + longSize);
    }
    final char[] array = new char[size];
    string.getChars(0, len, array, 0);
    int n;
    for (n = len; n < size - n; n <<= 1) {
        System.arraycopy(array, 0, array, n, n);
    }
    System.arraycopy(array, 0, array, n, size - n);
    return new String(array);
}
*********************************

#### Score: 10.58832


#### Java Tokens: joins, providing, code, string, added, use, provided, values, link, iterable, empty, iterator, see, character, param, utils, delimiter, join, together, treated, may, containing, joined, list, separator, stringutils, single, input, examples, elements, object, since 


public static String join(final Iterable<?> iterable, final String separator) {
    if (iterable == null) {
        return null;
    }
    return join(iterable.iterator(), separator);
}
*********************************

#### Score: 10.01620


#### Java Tokens: joins, providing, code, string, added, use, provided, objects, values, link, iterable, empty, iterator, see, character, strings, param, utils, delimiter, iteration, represented, join, together, may, within, containing, joined, list, separator, stringutils, single, input, null, examples, elements, object, since 


public static String join(final Iterable<?> iterable, final char separator) {
    if (iterable == null) {
        return null;
    }
    return join(iterable.iterator(), separator);
}
*********************************

#### Score: 9.51939


#### Java Tokens: occurrences, code, string, counts, appears, isempty, abba, charsequence, empty, number, times, faster, tochararray, would, param, array, utils, generate, charat, given, pre, may, could, count, length, garbage, also, check, many, matches, look, str, stringutils, call, sequence, input, char, ups, returns, countmatches, since 


public static int countMatches(final CharSequence str, final char ch) {
    if (isEmpty(str)) {
        return 0;
    }
    int count = 0;
    
    for (int i = 0; i < str.length(); i++) {
        if (ch == str.charAt(i)) {
            count++;
        }
    }
    return count;
}
*********************************

#### Score: 9.22693


#### Java Tokens: exception, com, code, string, nullable, log, valueof, logger, another, integer, tohexstring, lenient, proguard, default, see, common, strings, identity, get, warning, create, hex, lenientformat, behavior, value, class, threw, getclass, identityhashcode, created, format, google, getlogger, getname, forcing, system, lenienttostring, inline, name, com.google.common.base.strings, fixed, avoid, objecttostring, tostring, hash, object, base 

private static String lenientToString(@Nullable Object o) {
    try {
        return String.valueOf(o);
    } catch (Exception e) {
        
        String objectToString = o.getClass().getName() + '@' + Integer.toHexString(System.identityHashCode(o));
        
        Logger.getLogger("com.google.common.base.Strings").log(WARNING, "Exception during lenientFormat for " + objectToString, e);
        return "<" + objectToString + " threw " + e.getClass().getName() + ">";
    }
}
*********************************

#### Score: 8.63317


#### Java Tokens: exception, occurrences, repeats, stack, mostly, objects, upper, arrayutils, wcte, isempty, illegalstateexception, output, mos, java, utils, tcte, let, text, state, greater, replaceeach, dcte, still, goal, sure, method, index, circular, no-op, matches, input, size, guess, replacementlist, math, arrays, recursing, larger, illegalargumentexception, another, requests, recursive, example, result, search, see, min, found, strings, mos.search, get, builder, repl, protect, stackoverflowerror, nomorematchesforreplindex, aba, within, textlength, one, replaced, possible, stringutils, searchlength, buf, textindex, elements, logic, stringbuilder, outputs, argument, tempindex, inputs, replace, good, empty, reference, overflow, helper, major, loop, find, repeating, match:, replaceindex, create, replacements, buffer, ignored, repeatedly, pre, need, count, less, list, illegal, done, take, measure, replaceeachrepeatedly, keep, creates, know, timetolive, assume, replacement, since, next, note, replacementlength, code, string, searching, link, mchyzer, endless, upper-bound, error, duplicated, array, param, repeat, end, passed, track, make, live, charat, temp, abcde, bound, length, match, start, aborting, increase, earliest, equal, processed, performance, searchlist, lengths, due, corresponding, harness, time, indexof, tostring, append 


private static String replaceEach(final String text, final String[] searchList, final String[] replacementList, final boolean repeat, final int timeToLive) {
    if (isEmpty(text) || ArrayUtils.isEmpty(searchList) || ArrayUtils.isEmpty(replacementList)) {
        return text;
    }
    
    if (timeToLive < 0) {
        throw new IllegalStateException("Aborting to protect against StackOverflowError - " + "output of one loop is the input of another");
    }
    final int searchLength = searchList.length;
    final int replacementLength = replacementList.length;
    
    if (searchLength != replacementLength) {
        throw new IllegalArgumentException("Search and Replace array lengths don't match: " + searchLength + " vs " + replacementLength);
    }
    
    final boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];
    
    int textIndex = -1;
    int replaceIndex = -1;
    int tempIndex = -1;
    
    for (int i = 0; i < searchLength; i++) {
        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) {
            continue;
        }
        tempIndex = text.indexOf(searchList[i]);
        
        if (tempIndex == -1) {
            noMoreMatchesForReplIndex[i] = true;
        } else {
            if (textIndex == -1 || tempIndex < textIndex) {
                textIndex = tempIndex;
                replaceIndex = i;
            }
        }
    }
    
    if (textIndex == -1) {
        return text;
    }
    int start = 0;
    
    int increase = 0;
    
    for (int i = 0; i < searchList.length; i++) {
        if (searchList[i] == null || replacementList[i] == null) {
            continue;
        }
        final int greater = replacementList[i].length() - searchList[i].length();
        if (greater > 0) {
            
            increase += 3 * greater;
        }
    }
    
    increase = Math.min(increase, text.length() / 5);
    final StringBuilder buf = new StringBuilder(text.length() + increase);
    while (textIndex != -1) {
        for (int i = start; i < textIndex; i++) {
            buf.append(text.charAt(i));
        }
        buf.append(replacementList[replaceIndex]);
        start = textIndex + searchList[replaceIndex].length();
        textIndex = -1;
        replaceIndex = -1;
        tempIndex = -1;
        
        for (int i = 0; i < searchLength; i++) {
            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) {
                continue;
            }
            tempIndex = text.indexOf(searchList[i], start);
            
            if (tempIndex == -1) {
                noMoreMatchesForReplIndex[i] = true;
            } else {
                if (textIndex == -1 || tempIndex < textIndex) {
                    textIndex = tempIndex;
                    replaceIndex = i;
                }
            }
        }
    
    }
    final int textLength = text.length();
    for (int i = start; i < textLength; i++) {
        buf.append(text.charAt(i));
    }
    final String result = buf.toString();
    if (!repeat) {
        return result;
    }
    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);
}
*********************************

#### Score: 7.91455


#### Java Tokens: joins, exception, noofitems, added, use, equally, objects, b--c, empty, number, character, len, utils, delimiter, roughly, exclusive, represented, join, treated, given, pre, containing, newstringbuilder, index, list, separator, input, entries, endindex, null, stop, bounds, items, object, joining, code, string, nof, firststring, provided, values, arrayindexoutofboundsexception, a--b--c, strings, nofstrings, array, param, builder, end, together, ,,a, abc, may, within, joined, start, length, ife, stringutils, single, buf, startindex, assuming, elements, stringbuilder, tostring, append, first 


public static String join(final Object[] array, String separator, final int startIndex, final int endIndex) {
    if (array == null) {
        return null;
    }
    if (separator == null) {
        separator = EMPTY;
    }
    
    
    final int noOfItems = endIndex - startIndex;
    if (noOfItems <= 0) {
        return EMPTY;
    }
    final StringBuilder buf = newStringBuilder(noOfItems);
    if (array[startIndex] != null) {
        buf.append(array[startIndex]);
    }
    for (int i = startIndex + 1; i < endIndex; i++) {
        buf.append(separator);
        if (array[i] != null) {
            buf.append(array[i]);
        }
    }
    return buf.toString();
}
*********************************

#### Score: 7.55687


#### Java Tokens: larger, occurrences, sub, code, string, signature, counts, appears, isempty, abba, charsequence, substring, empty, number, times, either, found, param, utils, charsequenceutils, pre, may, index_not_found, count, length, index, check, many, matches, str, stringutils, sequence, input, char, xxx, returns, idx, indexof, countmatches, since, changed 




public static int countMatches(final CharSequence str, final CharSequence sub) {
    if (isEmpty(str) || isEmpty(sub)) {
        return 0;
    }
    int count = 0;
    int idx = 0;
    while ((idx = CharSequenceUtils.indexOf(str, sub, idx)) != INDEX_NOT_FOUND) {
        count++;
        idx += sub.length();
    }
    return count;
}
*********************************

#### Score: 7.37630


#### Java Tokens: template, string, nullable, valueof, placeholders, run, lenient, braces, strings, extra, builder, lenientformat, placeholder, value, (object[])null, placeholderstart, format, length, start, index, substituting, args, square, lenienttostring, templatestart, arguments, stringbuilder, indexof, tostring, append, object 



public static String lenientFormat(@Nullable String template, @Nullable Object@Nullable ... args) {
    
    template = String.valueOf(template);
    if (args == null) {
        args = new Object[] { "(Object[])null" };
    } else {
        for (int i = 0; i < args.length; i++) {
            args[i] = lenientToString(args[i]);
        }
    }
    
    StringBuilder builder = new StringBuilder(template.length() + 16 * args.length);
    int templateStart = 0;
    int i = 0;
    while (i < args.length) {
        int placeholderStart = template.indexOf("%s", templateStart);
        if (placeholderStart == -1) {
            break;
        }
        builder.append(template, templateStart, placeholderStart);
        builder.append(args[i++]);
        templateStart = placeholderStart + 2;
    }
    builder.append(template, templateStart, template.length());
    
    if (i < args.length) {
        builder.append(" [");
        builder.append(args[i++]);
        while (i < args.length) {
            builder.append(", ");
            builder.append(args[i++]);
        }
        builder.append(']');
    }
    return builder.toString();
}
*********************************

#### Score: 7.19367


#### Java Tokens: joins, ;;a, noofitems, added, use, objects, empty, character, utils, delimiter, exclusive, represented, join, pre, pass, containing, past, newstringbuilder, index, list, separator, input, endindex, null, stop, items, object, since, joining, a;b;c, code, string, provided, values, error, strings, array, param, builder, end, together, abc, may, within, joined, start, stringutils, single, buf, startindex, elements, stringbuilder, tostring, append, first 


public static String join(final Object[] array, final char separator, final int startIndex, final int endIndex) {
    if (array == null) {
        return null;
    }
    final int noOfItems = endIndex - startIndex;
    if (noOfItems <= 0) {
        return EMPTY;
    }
    final StringBuilder buf = newStringBuilder(noOfItems);
    if (array[startIndex] != null) {
        buf.append(array[startIndex]);
    }
    for (int i = startIndex + 1; i < endIndex; i++) {
        buf.append(separator);
        if (array[i] != null) {
            buf.append(array[i]);
        }
    }
    return buf.toString();
}