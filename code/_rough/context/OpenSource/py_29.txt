### Py Tokens: count, use, one, fromkeys, undefined, means, equivalent, counter, counters, element, setting, error, instead, notimplementederror, implemented, method, iterable, greater 

### Py functions

@classmethod
def fromkeys(cls, iterable, v=None):


  raise NotImplementedError(
    'Counter.fromkeys() is undefined.  Use Counter(iterable) instead.')
*********************************

#### Score: 10.33962


#### Java Tokens: n-th, abababab, empty, mos, finds, utils, find, implemented, ordinalindexof, pre, method, last, index_not_found, index, check, matches, aabaabaa, abab, str, sequence, never, input, overlap, position, ababab, starting, since, changed, note, code, string, signature, link, immediately, charsequence, substring, lastordinalindexof, search, found, unless, param, successful, means, aba, may, within, one, match, possible, incrementing, stringutils, searchstr, char, handling, uses, returned, indexof, ordinal, incremented 


public static int ordinalIndexOf(final CharSequence str, final CharSequence searchStr, final int ordinal) {
    return ordinalIndexOf(str, searchStr, ordinal, false);
}
*********************************

#### Score: 9.59641


#### Java Tokens: use, used, empty, zero, character, utils, exclusive, avoiding, starts, greater, counting, based, pre, negatives, specify, count, positions, handle, check, exceptions, str, input, left, zero-based, position, relative, next, code, string, beginning, back, substring, specified, remember, characters, negative, param, ends, get, end, means, abc, may, start, length, many, gets, strictly, stringutils, offsets, returned 


public static String substring(final String str, int start, int end) {
    if (str == null) {
        return null;
    }
    
    if (end < 0) {
        
        end = str.length() + end;
    }
    if (start < 0) {
        
        start = str.length() + start;
    }
    
    if (end > str.length()) {
        end = str.length();
    }
    
    if (start > end) {
        return EMPTY;
    }
    if (start < 0) {
        start = 0;
    }
    if (end < 0) {
        end = 0;
    }
    return str.substring(start, end);
}
*********************************

#### Score: 7.25324


#### Java Tokens: code, string, back, used, substring, specified, empty, remember, characters, negative, param, utils, get, end, avoiding, means, pre, abc, may, negatives, last, start, length, count, handle, many, gets, exceptions, str, stringutils, input, position 




public static String substring(final String str, int start) {
    if (str == null) {
        return null;
    }
    
    if (start < 0) {
        
        start = str.length() + start;
    }
    if (start < 0) {
        start = 0;
    }
    if (start > str.length()) {
        return EMPTY;
    }
    return str.substring(start);
}
*********************************

#### Score: 7.08237


#### Java Tokens: code, {@link, emptytonull, nullable, string, references, use, methods, converting, upper, link, {@code, isempty, platform, null},, empty, reference, either, strings, param, #emptytonull}., consider, case, direction, given, method, isnullorempty, like, check, instead, null, normalizing, stringisnullorempty, nulltoempty, returns, touppercase 


public static boolean isNullOrEmpty(@Nullable String string) {
    return Platform.stringIsNullOrEmpty(string);
}
*********************************

#### Score: 6.52252


#### Java Tokens: note, code, string, use, deprecated, foo, link, endswith, remove, substring, without, bar, foobar, trailing, feature, param, utils, ends, end, baz, perl, substringbeforelast, behavior, lang, pre, closely, method, previous, last, may, chomp, instead, separator, version, matches, str, stringutils, input, removed, foooo, removeend, uses, removes, changed 


@Deprecated
public static String chomp(final String str, final String separator) {
    return removeEnd(str, separator);
}
*********************************

#### Score: 6.10643


#### Java Tokens: n-th, note, code, string, signature, link, lastordinalindexof, charsequence, substring, mos, search, found, finds, param, utils, find, implemented, ordinalindexof, pre, last, method, may, within, index_not_found, match, index, check, aabaabaa, str, stringutils, sequence, input, searchstr, char, handling, uses, lastindexof, ordinal, since, changed 


public static int lastOrdinalIndexOf(final CharSequence str, final CharSequence searchStr, final int ordinal) {
    return ordinalIndexOf(str, searchStr, ordinal, true);
}
*********************************

#### Score: 5.97046


#### Java Tokens: exception, occurrences, repeats, stack, mostly, objects, upper, arrayutils, wcte, isempty, illegalstateexception, output, mos, java, utils, tcte, let, text, state, greater, replaceeach, dcte, still, goal, sure, method, index, circular, no-op, matches, input, size, guess, replacementlist, math, arrays, recursing, larger, illegalargumentexception, another, requests, recursive, example, result, search, see, min, found, strings, mos.search, get, builder, repl, protect, stackoverflowerror, nomorematchesforreplindex, aba, within, textlength, one, replaced, possible, stringutils, searchlength, buf, textindex, elements, logic, stringbuilder, outputs, argument, tempindex, inputs, replace, good, empty, reference, overflow, helper, major, loop, find, repeating, match:, replaceindex, create, replacements, buffer, ignored, repeatedly, pre, need, count, less, list, illegal, done, take, measure, replaceeachrepeatedly, keep, creates, know, timetolive, assume, replacement, since, next, note, replacementlength, code, string, searching, link, mchyzer, endless, upper-bound, error, duplicated, array, param, repeat, end, passed, track, make, live, charat, temp, abcde, bound, length, match, start, aborting, increase, earliest, equal, processed, performance, searchlist, lengths, due, corresponding, harness, time, indexof, tostring, append 


private static String replaceEach(final String text, final String[] searchList, final String[] replacementList, final boolean repeat, final int timeToLive) {
    if (isEmpty(text) || ArrayUtils.isEmpty(searchList) || ArrayUtils.isEmpty(replacementList)) {
        return text;
    }
    
    if (timeToLive < 0) {
        throw new IllegalStateException("Aborting to protect against StackOverflowError - " + "output of one loop is the input of another");
    }
    final int searchLength = searchList.length;
    final int replacementLength = replacementList.length;
    
    if (searchLength != replacementLength) {
        throw new IllegalArgumentException("Search and Replace array lengths don't match: " + searchLength + " vs " + replacementLength);
    }
    
    final boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];
    
    int textIndex = -1;
    int replaceIndex = -1;
    int tempIndex = -1;
    
    for (int i = 0; i < searchLength; i++) {
        if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) {
            continue;
        }
        tempIndex = text.indexOf(searchList[i]);
        
        if (tempIndex == -1) {
            noMoreMatchesForReplIndex[i] = true;
        } else {
            if (textIndex == -1 || tempIndex < textIndex) {
                textIndex = tempIndex;
                replaceIndex = i;
            }
        }
    }
    
    if (textIndex == -1) {
        return text;
    }
    int start = 0;
    
    int increase = 0;
    
    for (int i = 0; i < searchList.length; i++) {
        if (searchList[i] == null || replacementList[i] == null) {
            continue;
        }
        final int greater = replacementList[i].length() - searchList[i].length();
        if (greater > 0) {
            
            increase += 3 * greater;
        }
    }
    
    increase = Math.min(increase, text.length() / 5);
    final StringBuilder buf = new StringBuilder(text.length() + increase);
    while (textIndex != -1) {
        for (int i = start; i < textIndex; i++) {
            buf.append(text.charAt(i));
        }
        buf.append(replacementList[replaceIndex]);
        start = textIndex + searchList[replaceIndex].length();
        textIndex = -1;
        replaceIndex = -1;
        tempIndex = -1;
        
        for (int i = 0; i < searchLength; i++) {
            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || searchList[i].isEmpty() || replacementList[i] == null) {
                continue;
            }
            tempIndex = text.indexOf(searchList[i], start);
            
            if (tempIndex == -1) {
                noMoreMatchesForReplIndex[i] = true;
            } else {
                if (textIndex == -1 || tempIndex < textIndex) {
                    textIndex = tempIndex;
                    replaceIndex = i;
                }
            }
        }
    
    }
    final int textLength = text.length();
    for (int i = start; i < textLength; i++) {
        buf.append(text.charAt(i));
    }
    final String result = buf.toString();
    if (!repeat) {
        return result;
    }
    return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);
}
*********************************

#### Score: 5.94958


#### Java Tokens: joins, providing, code, string, added, use, provided, values, link, iterable, empty, iterator, see, character, param, utils, delimiter, join, together, treated, may, containing, joined, list, separator, stringutils, single, input, examples, elements, object, since 


public static String join(final Iterable<?> iterable, final String separator) {
    if (iterable == null) {
        return null;
    }
    return join(iterable.iterator(), separator);
}
*********************************

#### Score: 5.89216


#### Java Tokens: standard, performs, separate, use, arrayutils, space, empty_string_array, empty, zero, number, character, split, sizeplus, len, utils, limit, worker, add, treated, last, isspace, index, stringtokenizer, preserve, list, separator, plus, str, input, size, null, parsed, iswhitespace, code, string, separatorchars, methods, direct, optimise, substring, jdk1, lastmatch, negative, strings, splitworker, array, param, preservealltokens, tokens, value, charat, sep, include, means, may, max, one, quicker, length, start, match, adjacent, also, arraylist, parse, splitpreservealltokens, token, tokenizer, stringutils, jdk, performance, tuned, toarray, elements, maximum, uses, logic, whitespace, implies, indexof, separators, chars, sizeplus1 


private static String[] splitWorker(final String str, final String separatorChars, final int max, final boolean preserveAllTokens) {
    if (str == null) {
        return null;
    }
    final int len = str.length();
    if (len == 0) {
        return ArrayUtils.EMPTY_STRING_ARRAY;
    }
    final List<String> list = new ArrayList<>();
    int sizePlus1 = 1;
    int i = 0, start = 0;
    boolean match = false;
    boolean lastMatch = false;
    if (separatorChars == null) {
        
        while (i < len) {
            if (Character.isWhitespace(str.charAt(i))) {
                if (match || preserveAllTokens) {
                    lastMatch = true;
                    if (sizePlus1++ == max) {
                        i = len;
                        lastMatch = false;
                    }
                    list.add(str.substring(start, i));
                    match = false;
                }
                start = ++i;
                continue;
            }
            lastMatch = false;
            match = true;
            i++;
        }
    } else if (separatorChars.length() == 1) {
        
        final char sep = separatorChars.charAt(0);
        while (i < len) {
            if (str.charAt(i) == sep) {
                if (match || preserveAllTokens) {
                    lastMatch = true;
                    if (sizePlus1++ == max) {
                        i = len;
                        lastMatch = false;
                    }
                    list.add(str.substring(start, i));
                    match = false;
                }
                start = ++i;
                continue;
            }
            lastMatch = false;
            match = true;
            i++;
        }
    } else {
        
        while (i < len) {
            if (separatorChars.indexOf(str.charAt(i)) >= 0) {
                if (match || preserveAllTokens) {
                    lastMatch = true;
                    if (sizePlus1++ == max) {
                        i = len;
                        lastMatch = false;
                    }
                    list.add(str.substring(start, i));
                    match = false;
                }
                start = ++i;
                continue;
            }
            lastMatch = false;
            match = true;
            i++;
        }
    }
    if (match || preserveAllTokens && lastMatch) {
        list.add(str.substring(start, i));
    }
    return list.toArray(new String[list.size()]);
}
*********************************

#### Score: 5.63542


#### Java Tokens: joins, providing, code, string, added, use, provided, objects, values, link, iterable, empty, iterator, see, character, strings, param, utils, delimiter, iteration, represented, join, together, may, within, containing, joined, list, separator, stringutils, single, input, null, examples, elements, object, since 


public static String join(final Iterable<?> iterable, final char separator) {
    if (iterable == null) {
        return null;
    }
    return join(iterable.iterator(), separator);
}