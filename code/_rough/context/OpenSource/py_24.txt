### Py Tokens: accessible, named, verbose, point, syntaxerror, option, plain, number, environments, replace, globals, names, enumerate, keywords, ordered, message, isinstance, fieldtemplate, iskeyword, basestring, typeerror, isalnum, also, fmt, support, add, start, duplicate, setting, dict, bypass, fielddefs, classtemplate, type, valueerror, arguments, startswith, jython, string, tuple, python, classdefinition, repr, fieldnames, cannot, underscore, ironpython, syntax, unpack, must, execute, main, join, name, keyword, fields, instantiate, underscores, value, work, typename, doc, either, str, contain, property, attributeerror, reprfmt, rename, set, ordereddict, namedtuple, defined, attribute, frame, module, encountered, alphanumeric, list, num, result, numfields, arg, isdigit, seen, arglist, targets, fill, index, needs, error, format, namespace, subclass, positional, field, valid, automatically, split, template, new, get, reprtemplate, defs, map, pickling, temporary, indexable, dictionary, getframe, docstring, utilities, len, like, sys, step, regular, user, characters, variable, validate, generate, definition, convert, asdict, created, tracing, greater, example, iron, fglobals, returns, strings, itemgetter 

### Py functions

def namedtuple(typename, field_names, verbose=False, rename=False):




  if isinstance(field_names, basestring):
    field_names = field_names.replace(',', ' ').split()
  field_names = map(str, field_names)
  typename = str(typename)
  if rename:
    seen = set()
    for index, name in enumerate(field_names):
      if (not all(c.isalnum() or c=='_' for c in name)
              or _iskeyword(name)
              or not name
              or name[0].isdigit()
              or name.startswith('_')
              or name in seen):
        field_names[index] = '_%d' % index
      seen.add(name)
  for name in [typename] + field_names:
    if type(name) != str:
      raise TypeError('Type names and field names must be strings')
    if not all(c.isalnum() or c=='_' for c in name):
      raise ValueError('Type names and field names can only contain '
                       'alphanumeric characters and underscores: %r' % name)
    if _iskeyword(name):
      raise ValueError('Type names and field names cannot be a '
                       'keyword: %r' % name)
    if name[0].isdigit():
      raise ValueError('Type names and field names cannot start with '
                       'a number: %r' % name)
  seen = set()
  for name in field_names:
    if name.startswith('_') and not rename:
      raise ValueError('Field names cannot start with an underscore: '
                       '%r' % name)
    if name in seen:
      raise ValueError('Encountered duplicate field name: %r' % name)
    seen.add(name)


  class_definition = _class_template.format(
    typename = typename,
    field_names = tuple(field_names),
    num_fields = len(field_names),
    arg_list = repr(tuple(field_names)).replace("'", "")[1:-1],
    repr_fmt = ', '.join(_repr_template.format(name=name)
                         for name in field_names),
    field_defs = '\n'.join(_field_template.format(index=index, name=name)
                           for index, name in enumerate(field_names))
  )
  if verbose:
    print class_definition



  namespace = dict(_itemgetter=_itemgetter, __name__='namedtuple_%s' % typename,
                   OrderedDict=OrderedDict, _property=property, _tuple=tuple)
  try:
    exec class_definition in namespace
  except SyntaxError as e:
    raise SyntaxError(e.message + ':\n' + class_definition)
  result = namespace[typename]





  try:
    result.__module__ = _sys._getframe(1).f_globals.get('__name__', '__main__')
  except (AttributeError, ValueError):
    pass

  return result
*********************************

#### Score: 20.50576


#### Java Tokens: exception, leading, sign, integer, isempty, empty, numberformatexception, parseint, 12-3, number, character, either, u0967u0968u0969, utils, isdigit, generate, digit, still, pre, method, test, format, check, sequence, 12.3, contains, 123, checks, +123, outside, unicode, returns, parsed, decimal, since, changed, allow, note, code, string, signature, numeric, range, respectively, non, charsequence, point, long, negative, passes, param, value, charat, isnumeric, may, parselong, length, also, positive, parse, int, stringutils, -123, non-null, char, digits, ab2c 


public static boolean isNumeric(final CharSequence cs) {
    if (isEmpty(cs)) {
        return false;
    }
    final int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if (!Character.isDigit(cs.charAt(i))) {
            return false;
        }
    }
    return true;
}
*********************************

#### Score: 18.17547


#### Java Tokens: template, string, nullable, valueof, placeholders, run, lenient, braces, strings, extra, builder, lenientformat, placeholder, value, (object[])null, placeholderstart, format, length, start, index, substituting, args, square, lenienttostring, templatestart, arguments, stringbuilder, indexof, tostring, append, object 



public static String lenientFormat(@Nullable String template, @Nullable Object@Nullable ... args) {
    
    template = String.valueOf(template);
    if (args == null) {
        args = new Object[] { "(Object[])null" };
    } else {
        for (int i = 0; i < args.length; i++) {
            args[i] = lenientToString(args[i]);
        }
    }
    
    StringBuilder builder = new StringBuilder(template.length() + 16 * args.length);
    int templateStart = 0;
    int i = 0;
    while (i < args.length) {
        int placeholderStart = template.indexOf("%s", templateStart);
        if (placeholderStart == -1) {
            break;
        }
        builder.append(template, templateStart, placeholderStart);
        builder.append(args[i++]);
        templateStart = placeholderStart + 2;
    }
    builder.append(template, templateStart, template.length());
    
    if (i < args.length) {
        builder.append(" [");
        builder.append(args[i++]);
        while (i < args.length) {
            builder.append(", ");
            builder.append(args[i++]);
        }
        builder.append(']');
    }
    return builder.toString();
}
*********************************

#### Score: 16.18846


#### Java Tokens: standard, performs, separate, use, arrayutils, space, empty_string_array, empty, zero, number, character, split, sizeplus, len, utils, limit, worker, add, treated, last, isspace, index, stringtokenizer, preserve, list, separator, plus, str, input, size, null, parsed, iswhitespace, code, string, separatorchars, methods, direct, optimise, substring, jdk1, lastmatch, negative, strings, splitworker, array, param, preservealltokens, tokens, value, charat, sep, include, means, may, max, one, quicker, length, start, match, adjacent, also, arraylist, parse, splitpreservealltokens, token, tokenizer, stringutils, jdk, performance, tuned, toarray, elements, maximum, uses, logic, whitespace, implies, indexof, separators, chars, sizeplus1 


private static String[] splitWorker(final String str, final String separatorChars, final int max, final boolean preserveAllTokens) {
    if (str == null) {
        return null;
    }
    final int len = str.length();
    if (len == 0) {
        return ArrayUtils.EMPTY_STRING_ARRAY;
    }
    final List<String> list = new ArrayList<>();
    int sizePlus1 = 1;
    int i = 0, start = 0;
    boolean match = false;
    boolean lastMatch = false;
    if (separatorChars == null) {
        
        while (i < len) {
            if (Character.isWhitespace(str.charAt(i))) {
                if (match || preserveAllTokens) {
                    lastMatch = true;
                    if (sizePlus1++ == max) {
                        i = len;
                        lastMatch = false;
                    }
                    list.add(str.substring(start, i));
                    match = false;
                }
                start = ++i;
                continue;
            }
            lastMatch = false;
            match = true;
            i++;
        }
    } else if (separatorChars.length() == 1) {
        
        final char sep = separatorChars.charAt(0);
        while (i < len) {
            if (str.charAt(i) == sep) {
                if (match || preserveAllTokens) {
                    lastMatch = true;
                    if (sizePlus1++ == max) {
                        i = len;
                        lastMatch = false;
                    }
                    list.add(str.substring(start, i));
                    match = false;
                }
                start = ++i;
                continue;
            }
            lastMatch = false;
            match = true;
            i++;
        }
    } else {
        
        while (i < len) {
            if (separatorChars.indexOf(str.charAt(i)) >= 0) {
                if (match || preserveAllTokens) {
                    lastMatch = true;
                    if (sizePlus1++ == max) {
                        i = len;
                        lastMatch = false;
                    }
                    list.add(str.substring(start, i));
                    match = false;
                }
                start = ++i;
                continue;
            }
            lastMatch = false;
            match = true;
            i++;
        }
    }
    if (match || preserveAllTokens && lastMatch) {
        list.add(str.substring(start, i));
    }
    return list.toArray(new String[list.size()]);
}
*********************************

#### Score: 16.15432


#### Java Tokens: calculation, performs, equivalent, splits, excludes, beg, arrayutils, whole, used, substrings, splitbywholeseparatorpreservealltokens, empty_string_array, empty, zero, mos, number, character, split, separatorlength, len, utils, delimiter, limit, numberofsubstrings, worker, add, treated, containing, goes, index, preserve, list, splitbywholeseparatorworker, separator, str, input, size, following, parsed, position, starting, since, next, code, string, methods, skip, occurrence, substring, point, negative, search, found, strings, array, splitworker, param, preservealltokens, tokens, end, value, include, set, may, max, one, length, adjacent, arraylist, parse, right, consecutive, token, stringutils, equals, toarray, elements, maximum, logic, whitespace, returned, implies, indexof, separators 


private static String[] splitByWholeSeparatorWorker(final String str, final String separator, final int max, final boolean preserveAllTokens) {
    if (str == null) {
        return null;
    }
    final int len = str.length();
    if (len == 0) {
        return ArrayUtils.EMPTY_STRING_ARRAY;
    }
    if (separator == null || EMPTY.equals(separator)) {
        
        return splitWorker(str, null, max, preserveAllTokens);
    }
    final int separatorLength = separator.length();
    final ArrayList<String> substrings = new ArrayList<>();
    int numberOfSubstrings = 0;
    int beg = 0;
    int end = 0;
    while (end < len) {
        end = str.indexOf(separator, beg);
        if (end > -1) {
            if (end > beg) {
                numberOfSubstrings += 1;
                if (numberOfSubstrings == max) {
                    end = len;
                    substrings.add(str.substring(beg));
                } else {
                    
                    
                    substrings.add(str.substring(beg, end));
                    
                    
                    
                    beg = end + separatorLength;
                }
            } else {
                
                if (preserveAllTokens) {
                    numberOfSubstrings += 1;
                    if (numberOfSubstrings == max) {
                        end = len;
                        substrings.add(str.substring(beg));
                    } else {
                        substrings.add(EMPTY);
                    }
                }
                beg = end + separatorLength;
            }
        } else {
            
            substrings.add(str.substring(beg));
            end = len;
        }
    }
    return substrings.toArray(new String[substrings.size()]);
}
*********************************

#### Score: 15.32389


#### Java Tokens: exception, com, code, string, nullable, log, valueof, logger, another, integer, tohexstring, lenient, proguard, default, see, common, strings, identity, get, warning, create, hex, lenientformat, behavior, value, class, threw, getclass, identityhashcode, created, format, google, getlogger, getname, forcing, system, lenienttostring, inline, name, com.google.common.base.strings, fixed, avoid, objecttostring, tostring, hash, object, base 

private static String lenientToString(@Nullable Object o) {
    try {
        return String.valueOf(o);
    } catch (Exception e) {
        
        String objectToString = o.getClass().getName() + '@' + Integer.toHexString(System.identityHashCode(o));
        
        Logger.getLogger("com.google.common.base.Strings").log(WARNING, "Exception during lenientFormat for " + objectToString, e);
        return "<" + objectToString + " threw " + e.getClass().getName() + ">";
    }
}
*********************************

#### Score: 15.07682


#### Java Tokens: exception, argument, cdefghijkl, integer, source, bcdefghijk, good, empty, edge, truncate, abcdefghij, utils, else, truncates, specifically, greater, raspberry, pre, offset, like, specify, peach, less, illegal, klm, str, input, left, efghijklmn, must, since, maxwidth, illegalargumentexception, works, code, string, fgh, maxwith, turn, substring, result, characters, negative, min, param, men, value, allows, abc, may, max, fghij, length, abcdefghijklmno, fghijklmno, truncated, positive, stringutils, min_value, width, cannot, maximum, time, klmno, defghijklm, max_value 


public static String truncate(final String str, final int offset, final int maxWidth) {
    if (offset < 0) {
        throw new IllegalArgumentException("offset cannot be negative");
    }
    if (maxWidth < 0) {
        throw new IllegalArgumentException("maxWith cannot be negative");
    }
    if (str == null) {
        return null;
    }
    if (offset > str.length()) {
        return EMPTY;
    }
    if (str.length() > maxWidth) {
        final int ix = offset + maxWidth > str.length() ? str.length() : offset + maxWidth;
        return str.substring(offset, ix);
    }
    return str.substring(offset);
}
*********************************

#### Score: 14.85497


#### Java Tokens: exception, equivalent, added, use, deprecated, moved, replace, prepend, abc123, empty, reference, mode, java, compile, reg, utils, text, given, pre, method, &lt;__&gt;b, matcher, no-op, matches, cabc, input, regex, util, safe, matched, option, since, code, string, regexutils, [a-z], line, automatically, pattern, link, patternsyntaxexception, remove, substring, dotall, see, abcabc123abc, known, param, unlike, abcabc, single-line, passed, perl, regular, expression, abc, may, also, replaceall, (?s)&lt;.*&gt;, removepattern, &lt;.*&gt;, stringutils, single, processed, removeall, a&lt;__&gt;, syntax, removes, (?s) 


@Deprecated
public static String removeAll(final String text, final String regex) {
    return RegExUtils.removeAll(text, regex);
}
*********************************

#### Score: 14.73857


#### Java Tokens: uppercase, exception, splits, gettype, called, use, arrayutils, type, isempty, empty, empty_string_array, character, split, tochararray, java, camel, utils, whether, lowercase_letter, camel-case, case, add, camelcase, list, splitbycharactertype, tokenstart, str, input, size, letter, following, parsed, contiguous, since, code, belong, string, rather, immediately, characters, current, strings, array, pos, param, currenttype, get, tokens, lang, so-called, types, lowercase, may, start, length, groups, arraylist, uppercase_letter, token, stringutils, newtokenstart, toarray, char, preceding, returned, complete 


private static String[] splitByCharacterType(final String str, final boolean camelCase) {
    if (str == null) {
        return null;
    }
    if (str.isEmpty()) {
        return ArrayUtils.EMPTY_STRING_ARRAY;
    }
    final char[] c = str.toCharArray();
    final List<String> list = new ArrayList<>();
    int tokenStart = 0;
    int currentType = Character.getType(c[tokenStart]);
    for (int pos = tokenStart + 1; pos < c.length; pos++) {
        final int type = Character.getType(c[pos]);
        if (type == currentType) {
            continue;
        }
        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {
            final int newTokenStart = pos - 1;
            if (newTokenStart != tokenStart) {
                list.add(new String(c, tokenStart, newTokenStart - tokenStart));
                tokenStart = newTokenStart;
            }
        } else {
            list.add(new String(c, tokenStart, pos - tokenStart));
            tokenStart = pos;
        }
        currentType = type;
    }
    list.add(new String(c, tokenStart, c.length - tokenStart));
    return list.toArray(new String[list.size()]);
}
*********************************

#### Score: 14.70024


#### Java Tokens: yxabc, code, string, link, stripped, isempty, substring, strips, remove, empty, strlen, characters, character, strip, found, len, param, utils, stripstart, xyz, charat, defined, treated, pre, set, abc, may, index_not_found, start, length, index, str, stringutils, input, stripchars, returns, whitespace, iswhitespace, indexof, chars 


public static String stripStart(final String str, final String stripChars) {
    int strLen = length(str);
    if (strLen == 0) {
        return str;
    }
    int start = 0;
    if (stripChars == null) {
        while (start != strLen && Character.isWhitespace(str.charAt(start))) {
            start++;
        }
    } else if (stripChars.isEmpty()) {
        return str;
    } else {
        while (start != strLen && stripChars.indexOf(str.charAt(start)) != INDEX_NOT_FOUND) {
            start++;
        }
    }
    return str.substring(start);
}
*********************************

#### Score: 14.65930


#### Java Tokens: replacechars, replace, used, isempty, strlength, empty, mos, utils, modified, shorter, ignored, pre, method, abcba, index, str, input, longer, returns, searchchars, hello, quot, since, code, string, ayzya, delete, example, replacecharslength, characters, search, param, extra, builder, jelly, charat, set, abc, may, replaces, one, length, multiple, also, ayya, stringutils, equal, buf, deleted, yzx, stringbuilder, indexof, tostring, chars, append, normally 


public static String replaceChars(final String str, final String searchChars, String replaceChars) {
    if (isEmpty(str) || isEmpty(searchChars)) {
        return str;
    }
    if (replaceChars == null) {
        replaceChars = EMPTY;
    }
    boolean modified = false;
    final int replaceCharsLength = replaceChars.length();
    final int strLength = str.length();
    final StringBuilder buf = new StringBuilder(strLength);
    for (int i = 0; i < strLength; i++) {
        final char ch = str.charAt(i);
        final int index = searchChars.indexOf(ch);
        if (index >= 0) {
            modified = true;
            if (index < replaceCharsLength) {
                buf.append(replaceChars.charAt(index));
            }
        } else {
            buf.append(ch);
        }
    }
    if (modified) {
        return buf.toString();
    }
    return str;
}