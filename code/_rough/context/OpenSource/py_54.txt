### Py Tokens: lower, converted, return, string, copy, lowercase 

### Py functions

def lower(s):

  return s.lower()
*********************************

#### Score: 8.33247


#### Java Tokens: code, string, link, rules, locale, defines, cased, param, utils, tolowercase, english, per, case, pre, abc, lowercase, may, lower, converts, transformation, str, stringutils, input, returns, must, since 


public static String lowerCase(final String str, final Locale locale) {
    if (str == null) {
        return null;
    }
    return str.toLowerCase(locale);
}
*********************************

#### Score: 7.59312


#### Java Tokens: code, string, signature, non, isempty, charsequence, empty, characters, character, param, utils, ab/c, case, charat, ab1c, pre, abc, lowercase, may, lower, islowercase, length, check, stringutils, non-null, sequence, contains, checks, isalllowercase, char, since, changed 


public static boolean isAllLowerCase(final CharSequence cs) {
    if (isEmpty(cs)) {
        return false;
    }
    final int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if (!Character.isLowerCase(cs.charAt(i))) {
            return false;
        }
    }
    return true;
}
*********************************

#### Score: 7.59312


#### Java Tokens: note, strong, code, string, independent, link, used, locale, platform, result, current, cased, platform-independent, param, utils, tolowercase, english, per, case, pre, abc, lowercase, method, may, lower, converts, specific, affected, str, stringutils, input, transformations, returns 


public static String lowerCase(final String str) {
    if (str == null) {
        return null;
    }
    return str.toLowerCase();
}
*********************************

#### Score: 7.42908


#### Java Tokens: uppercase, code, string, upper, mixed, isempty, charsequence, empty, casing, characters, character, param, utils, containsuppercase, case, charat, pre, containslowercase, abc, lowercase, may, islowercase, lower, length, check, stringutils, sequence, contains, a1c, checks, a/c, isuppercase, char, ismixedcase, since 


public static boolean isMixedCase(final CharSequence cs) {
    if (isEmpty(cs) || cs.length() == 1) {
        return false;
    }
    boolean containsUppercase = false;
    boolean containsLowercase = false;
    final int sz = cs.length();
    for (int i = 0; i < sz; i++) {
        if (containsUppercase && containsLowercase) {
            return true;
        } else if (Character.isUpperCase(cs.charAt(i))) {
            containsUppercase = true;
        } else if (Character.isLowerCase(cs.charAt(i))) {
            containsLowercase = true;
        }
    }
    return containsUppercase && containsLowercase;
}
*********************************

#### Score: 7.42908


#### Java Tokens: uppercase, note, strong, code, string, independent, upper, link, used, locale, platform, result, current, cased, platform-independent, param, utils, english, per, case, pre, abc, method, lowercase, may, lower, converts, specific, affected, str, stringutils, input, transformations, returns, touppercase 




public static String upperCase(final String str) {
    if (str == null) {
        return null;
    }
    return str.toUpperCase();
}
*********************************

#### Score: 5.65089


#### Java Tokens: given, using, string, lower-case, lower, torootlowercase, link, source, converts, manner, locale, stringutils, param, utils, root, tolowercase, safe, case, null-safe, since 


public static String toRootLowerCase(final String source) {
    return source == null ? null : source.toLowerCase(Locale.ROOT);
}
*********************************

#### Score: 5.47602


#### Java Tokens: codepoint, uncapitalizes, changing, points, strlen, character, apache, len, utils, lang3, text, per, case, algorithm, based, pre, wordutils, offset, charcount, already, lower, count, capitalize, remaining, str, input, longer, returns, word, changed, since, code, string, link, codepointat, newcodepoints, point, commons, newcodepoint, characters, see, param, array, cat, tolowercase, copy, lang, may, org, length, firstcodepoint, stringutils, uncapitalize, capitalized, inoffset, cannot, ones, uncapitalized, first, outoffset 


public static String uncapitalize(final String str) {
    int strLen = length(str);
    if (strLen == 0) {
        return str;
    }
    final int firstCodepoint = str.codePointAt(0);
    final int newCodePoint = Character.toLowerCase(firstCodepoint);
    if (firstCodepoint == newCodePoint) {
        
        return str;
    }
    
    final int[] newCodePoints = new int[strLen];
    int outOffset = 0;
    
    newCodePoints[outOffset++] = newCodePoint;
    for (int inOffset = Character.charCount(firstCodepoint); inOffset < strLen; ) {
        final int codepoint = str.codePointAt(inOffset);
        
        newCodePoints[outOffset++] = codepoint;
        inOffset += Character.charCount(codepoint);
    }
    return new String(newCodePoints, 0, outOffset);
}
*********************************

#### Score: 4.13653


#### Java Tokens: code, string, isolated, arrayutils, units, convert, codepointat, charsequence, point, pairs, points, empty, codepointcount, result, valid, character, high, array, low, param, utils, supplementary, surrogate, preceded, pre, charcount, length, count, index, converts, followed, empty_int_array, int, as-is, str, stringutils, single, sequence, converted, char, tocodepoints, returned, tostring, since 


public static int[] toCodePoints(final CharSequence str) {
    if (str == null) {
        return null;
    }
    if (str.length() == 0) {
        return ArrayUtils.EMPTY_INT_ARRAY;
    }
    final String s = str.toString();
    final int[] result = new int[s.codePointCount(0, s.length())];
    int index = 0;
    for (int i = 0; i < result.length; i++) {
        result[i] = s.codePointAt(index);
        index += Character.charCount(result[i]);
    }
    return result;
}
*********************************

#### Score: 3.45988


#### Java Tokens: exception, uppercase, splits, gettype, rules, type, number, character, bar, split, java, camel, utils, lowercase_letter, case, pre, splitbycharactertypecamelcase, splitbycharactertype, foo200bar, str, input, 200, following, letter, parsed, contiguous, since, code, belong, string, rather, foo, asfrules, immediately, ab:cd:ef, number5, characters, foobar, strings, param, array, get, tokens, lang, lowercase, may, groups, uppercase_letter, token, stringutils, asf, preceding, returned, complete 


public static String[] splitByCharacterTypeCamelCase(final String str) {
    return splitByCharacterType(str, true);
}
*********************************

#### Score: 3.09406


#### Java Tokens: uppercase, exception, splits, gettype, called, use, arrayutils, type, isempty, empty, empty_string_array, character, split, tochararray, java, camel, utils, whether, lowercase_letter, camel-case, case, add, camelcase, list, splitbycharactertype, tokenstart, str, input, size, letter, following, parsed, contiguous, since, code, belong, string, rather, immediately, characters, current, strings, array, pos, param, currenttype, get, tokens, lang, so-called, types, lowercase, may, start, length, groups, arraylist, uppercase_letter, token, stringutils, newtokenstart, toarray, char, preceding, returned, complete 


private static String[] splitByCharacterType(final String str, final boolean camelCase) {
    if (str == null) {
        return null;
    }
    if (str.isEmpty()) {
        return ArrayUtils.EMPTY_STRING_ARRAY;
    }
    final char[] c = str.toCharArray();
    final List<String> list = new ArrayList<>();
    int tokenStart = 0;
    int currentType = Character.getType(c[tokenStart]);
    for (int pos = tokenStart + 1; pos < c.length; pos++) {
        final int type = Character.getType(c[pos]);
        if (type == currentType) {
            continue;
        }
        if (camelCase && type == Character.LOWERCASE_LETTER && currentType == Character.UPPERCASE_LETTER) {
            final int newTokenStart = pos - 1;
            if (newTokenStart != tokenStart) {
                list.add(new String(c, tokenStart, newTokenStart - tokenStart));
                tokenStart = newTokenStart;
            }
        } else {
            list.add(new String(c, tokenStart, pos - tokenStart));
            tokenStart = pos;
        }
        currentType = type;
    }
    list.add(new String(c, tokenStart, c.length - tokenStart));
    return list.toArray(new String[list.size()]);
}