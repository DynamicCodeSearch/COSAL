### Py Tokens: npieces, upper, frac, segmentremaining, lnext, len, cuts, yupper, total, segment, needed, append, areas, lower, segmentarea, xnext, area, areafromleft, totalarea, width, unext, size, remaining, ylower, left 

### Py functions

def func_dff5312368634be18708bbe1364f200b(lower, npieces, upper):
    li = ui = 0
    areas = []
    total_area = 0
    x = 0
    h1 = upper[0][1] - lower[0][1]
    W = lower[-1][0]
    while x < W:
        lnext = lower[li + 1]
        unext = upper[ui + 1]
        if lnext[0] == unext[0]:
            xnext = lnext[0]
            h2 = unext[1] - lnext[1]
            li += 1
            ui += 1
        elif lnext[0] < upper[ui + 1][0]:
            xnext = lnext[0]
            frac = 1.0 * (xnext - upper[ui][0]) / (unext[0] - upper[ui][0])
            yupper = upper[ui][1] + frac * (unext[1] - upper[ui][1])
            h2 = yupper - lnext[1]
            li += 1
        else:
            xnext = unext[0]
            frac = 1.0 * (xnext - lower[li][0]) / (lnext[0] - lower[li][0])
            ylower = lower[li][1] + frac * (lnext[1] - lower[li][1])
            h2 = unext[1] - ylower
            ui += 1
        da = (xnext - x) * (h1 + h2) / 2.0
        total_area += da
        areas.append((x, xnext, h1, h2, da, total_area))
        x = xnext
        h1 = h2
    size = total_area / npieces
    cuts = []
    needed = size
    for x1, x2, h1, h2, segment_area, total_area in areas:
        segment_remaining = segment_area
        area_from_left = 0
        while segment_remaining >= needed:
            area_from_left += needed
            width = x2 - x1
            if h1 == h2:
                x = area_from_left / h1
            else:
                qa = (h2 - h1) / (2 * width)
                qb = h1
                qc = -area_from_left
                x = (-qb + (qb ** 2 - 4 * qa * qc) ** 0.5) / (2 * qa)
            cuts.append(x1 + x)
            if len(cuts) == npieces - 1:
                return cuts
            segment_remaining -= needed
            needed = size
        needed -= segment_remaining
    return width

def func_5f344e7ef57d4aeab68d8af15d71f9b5(lower, npieces, upper):
    li = ui = 0
    areas = []
    total_area = 0
    x = 0
    h1 = upper[0][1] - lower[0][1]
    W = lower[-1][0]
    while x < W:
        lnext = lower[li + 1]
        unext = upper[ui + 1]
        if lnext[0] == unext[0]:
            xnext = lnext[0]
            h2 = unext[1] - lnext[1]
            li += 1
            ui += 1
        elif lnext[0] < upper[ui + 1][0]:
            xnext = lnext[0]
            frac = 1.0 * (xnext - upper[ui][0]) / (unext[0] - upper[ui][0])
            yupper = upper[ui][1] + frac * (unext[1] - upper[ui][1])
            h2 = yupper - lnext[1]
            li += 1
        else:
            xnext = unext[0]
            frac = 1.0 * (xnext - lower[li][0]) / (lnext[0] - lower[li][0])
            ylower = lower[li][1] + frac * (lnext[1] - lower[li][1])
            h2 = unext[1] - ylower
            ui += 1
        da = (xnext - x) * (h1 + h2) / 2.0
        total_area += da
        areas.append((x, xnext, h1, h2, da, total_area))
        x = xnext
        h1 = h2
    size = total_area / npieces
    cuts = []
    needed = size
    for x1, x2, h1, h2, segment_area, total_area in areas:
        segment_remaining = segment_area
        area_from_left = 0
        while segment_remaining >= needed:
            area_from_left += needed
            width = x2 - x1
            if h1 == h2:
                x = area_from_left / h1
            else:
                qa = (h2 - h1) / (2 * width)
                qb = h1
                qc = -area_from_left
                x = (-qb + (qb ** 2 - 4 * qa * qc) ** 0.5) / (2 * qa)
            cuts.append(x1 + x)
            if len(cuts) == npieces - 1:
                return cuts
            segment_remaining -= needed
            needed = size
        needed -= segment_remaining
    return lower

def func_29e26773d7bc4e578a80e9373eb477ba(li, lower, npieces, ui, upper):
    areas = []
    total_area = 0
    x = 0
    h1 = upper[0][1] - lower[0][1]
    W = lower[-1][0]
    while x < W:
        lnext = lower[li + 1]
        unext = upper[ui + 1]
        if lnext[0] == unext[0]:
            xnext = lnext[0]
            h2 = unext[1] - lnext[1]
            li += 1
            ui += 1
        elif lnext[0] < upper[ui + 1][0]:
            xnext = lnext[0]
            frac = 1.0 * (xnext - upper[ui][0]) / (unext[0] - upper[ui][0])
            yupper = upper[ui][1] + frac * (unext[1] - upper[ui][1])
            h2 = yupper - lnext[1]
            li += 1
        else:
            xnext = unext[0]
            frac = 1.0 * (xnext - lower[li][0]) / (lnext[0] - lower[li][0])
            ylower = lower[li][1] + frac * (lnext[1] - lower[li][1])
            h2 = unext[1] - ylower
            ui += 1
        da = (xnext - x) * (h1 + h2) / 2.0
        total_area += da
        areas.append((x, xnext, h1, h2, da, total_area))
        x = xnext
        h1 = h2
    size = total_area / npieces
    cuts = []
    needed = size
    for x1, x2, h1, h2, segment_area, total_area in areas:
        segment_remaining = segment_area
        area_from_left = 0
        while segment_remaining >= needed:
            area_from_left += needed
            width = x2 - x1
            if h1 == h2:
                x = area_from_left / h1
            else:
                qa = (h2 - h1) / (2 * width)
                qb = h1
                qc = -area_from_left
                x = (-qb + (qb ** 2 - 4 * qa * qc) ** 0.5) / (2 * qa)
            cuts.append(x1 + x)
            if len(cuts) == npieces - 1:
                return cuts
            segment_remaining -= needed
            needed = size
        needed -= segment_remaining
    return areas

def func_4bd33a4ffc224ffeaf5e7c66709a1830(li, lower, npieces, ui, upper):
    areas = []
    total_area = 0
    x = 0
    h1 = upper[0][1] - lower[0][1]
    W = lower[-1][0]
    while x < W:
        lnext = lower[li + 1]
        unext = upper[ui + 1]
        if lnext[0] == unext[0]:
            xnext = lnext[0]
            h2 = unext[1] - lnext[1]
            li += 1
            ui += 1
        elif lnext[0] < upper[ui + 1][0]:
            xnext = lnext[0]
            frac = 1.0 * (xnext - upper[ui][0]) / (unext[0] - upper[ui][0])
            yupper = upper[ui][1] + frac * (unext[1] - upper[ui][1])
            h2 = yupper - lnext[1]
            li += 1
        else:
            xnext = unext[0]
            frac = 1.0 * (xnext - lower[li][0]) / (lnext[0] - lower[li][0])
            ylower = lower[li][1] + frac * (lnext[1] - lower[li][1])
            h2 = unext[1] - ylower
            ui += 1
        da = (xnext - x) * (h1 + h2) / 2.0
        total_area += da
        areas.append((x, xnext, h1, h2, da, total_area))
        x = xnext
        h1 = h2
    size = total_area / npieces
    cuts = []
    needed = size
    for x1, x2, h1, h2, segment_area, total_area in areas:
        segment_remaining = segment_area
        area_from_left = 0
        while segment_remaining >= needed:
            area_from_left += needed
            width = x2 - x1
            if h1 == h2:
                x = area_from_left / h1
            else:
                qa = (h2 - h1) / (2 * width)
                qb = h1
                qc = -area_from_left
                x = (-qb + (qb ** 2 - 4 * qa * qc) ** 0.5) / (2 * qa)
            cuts.append(x1 + x)
            if len(cuts) == npieces - 1:
                return cuts
            segment_remaining -= needed
            needed = size
        needed -= segment_remaining
    return upper

def func_3d8b6dcaab8e47b09127ba05484159cf(li, lower, npieces, ui, upper):
    areas = []
    total_area = 0
    x = 0
    h1 = upper[0][1] - lower[0][1]
    W = lower[-1][0]
    while x < W:
        lnext = lower[li + 1]
        unext = upper[ui + 1]
        if lnext[0] == unext[0]:
            xnext = lnext[0]
            h2 = unext[1] - lnext[1]
            li += 1
            ui += 1
        elif lnext[0] < upper[ui + 1][0]:
            xnext = lnext[0]
            frac = 1.0 * (xnext - upper[ui][0]) / (unext[0] - upper[ui][0])
            yupper = upper[ui][1] + frac * (unext[1] - upper[ui][1])
            h2 = yupper - lnext[1]
            li += 1
        else:
            xnext = unext[0]
            frac = 1.0 * (xnext - lower[li][0]) / (lnext[0] - lower[li][0])
            ylower = lower[li][1] + frac * (lnext[1] - lower[li][1])
            h2 = unext[1] - ylower
            ui += 1
        da = (xnext - x) * (h1 + h2) / 2.0
        total_area += da
        areas.append((x, xnext, h1, h2, da, total_area))
        x = xnext
        h1 = h2
    size = total_area / npieces
    cuts = []
    needed = size
    for x1, x2, h1, h2, segment_area, total_area in areas:
        segment_remaining = segment_area
        area_from_left = 0
        while segment_remaining >= needed:
            area_from_left += needed
            width = x2 - x1
            if h1 == h2:
                x = area_from_left / h1
            else:
                qa = (h2 - h1) / (2 * width)
                qb = h1
                qc = -area_from_left
                x = (-qb + (qb ** 2 - 4 * qa * qc) ** 0.5) / (2 * qa)
            cuts.append(x1 + x)
            if len(cuts) == npieces - 1:
                return cuts
            segment_remaining -= needed
            needed = size
        needed -= segment_remaining
    return lower

*********************************

#### Score: 15.78945


#### Java Tokens: area, total, size, last, upper, lower, totalarea, lastx 

public static double func_16d0490419ba4510a52110bd40c01f1e(ArrayList<Point> lower, ArrayList<Point> upper) { 
 int u = upper.size();
int l = lower.size();
double lastX = 0;
double totalArea = 0.0;
return lastX;
}


public static ArrayList<Point> func_c846638aeeba42209bb1a006bc6af783(ArrayList<Point> lower, ArrayList<Point> upper) { 
 int u = upper.size();
int l = lower.size();
double lastX = 0;
double totalArea = 0.0;
return upper;
}


public static ArrayList<Point> func_53617d74c93043f1be9885559938f98e(ArrayList<Point> lower, ArrayList<Point> upper) { 
 int u = upper.size();
int l = lower.size();
double lastX = 0;
double totalArea = 0.0;
return lower;
}


*********************************

#### Score: 14.33246


#### Java Tokens: area, cur, curl, total, size, last, upper, lower, totalarea, lastx 

public static ArrayList<Point> func_64eb18f95b634db396ad919d2bddc6ec(ArrayList<Point> lower, ArrayList<Point> upper) { 
 int curL = 1;
int u = upper.size();
int l = lower.size();
double lastX = 0;
double totalArea = 0.0;
return upper;
}


public static ArrayList<Point> func_f12d548a1ca944b69282645491e5c57f(ArrayList<Point> lower, ArrayList<Point> upper) { 
 int curL = 1;
int u = upper.size();
int l = lower.size();
double lastX = 0;
double totalArea = 0.0;
return lower;
}


public static double func_8ac2047e2414429aa2fa5e24b6ffe66e(ArrayList<Point> lower, ArrayList<Point> upper) { 
 int curL = 1;
int u = upper.size();
int l = lower.size();
double lastX = 0;
double totalArea = 0.0;
return totalArea;
}


*********************************

#### Score: 14.26873


#### Java Tokens: area, total, size, last, lower, totalarea, lastx 

public static double func_2501cad509714e2f96db233aa59c40dd(ArrayList<Point> lower) { 
 int l = lower.size();
double lastX = 0;
double totalArea = 0.0;
return totalArea;
}


public static int func_c83a1fe6d6b74583a02b75fe8df2aa2b(ArrayList<Point> lower) { 
 int l = lower.size();
double lastX = 0;
double totalArea = 0.0;
return l;
}


public static double func_3b0fb321acde4679948a0b9a4f58cece(ArrayList<Point> lower) { 
 int l = lower.size();
double lastX = 0;
double totalArea = 0.0;
return lastX;
}


*********************************

#### Score: 13.73605


#### Java Tokens: lowerpoint, area, upper, lower, part, point, remaining, upperpoint, remainingarea, segment, partarea, uppersegment, lowersegment 

public static double func_8db9a2efbeca4ec0add84bd29560c67a(double partArea, Point[] lowerPoint, Point[] upperPoint) { 
 Segment upperSegment = new Segment(upperPoint[0], upperPoint[1]);
Segment lowerSegment = new Segment(lowerPoint[0], lowerPoint[1]);
double remainingArea = partArea;
return remainingArea;
}


*********************************

#### Score: 13.70295


#### Java Tokens: area, cur, curl, total, size, last, upper, lower, curu, totalarea, lastx 

public static int func_63bc8e90a0734895a000e1c17826ce63(ArrayList<Point> lower, ArrayList<Point> upper) { 
 int curU = 1;
int curL = 1;
int u = upper.size();
int l = lower.size();
double lastX = 0;
double totalArea = 0.0;
return u;
}


public static int func_17351adbad5d4f818eaa9f8e5fadf1e2(ArrayList<Point> lower, ArrayList<Point> upper) { 
 int curU = 1;
int curL = 1;
int u = upper.size();
int l = lower.size();
double lastX = 0;
double totalArea = 0.0;
return l;
}


public static double func_22f91c209867435d9c4029e94c63cd90(ArrayList<Point> lower, ArrayList<Point> upper) { 
 int curU = 1;
int curL = 1;
int u = upper.size();
int l = lower.size();
double lastX = 0;
double totalArea = 0.0;
return totalArea;
}


*********************************

#### Score: 13.59650


#### Java Tokens: lowerpoint, area, remainingarea, segment, lower, part, partarea, lowersegment, point, remaining 

public static double func_6f37fabca3e84df8a96a12ba15f629a9(double partArea, Point[] lowerPoint) { 
 Segment lowerSegment = new Segment(lowerPoint[0], lowerPoint[1]);
double remainingArea = partArea;
return remainingArea;
}


*********************************

#### Score: 12.30342


#### Java Tokens: left, upper, segment, uppersegment, right 

public static double func_17d984b22fd84ad6aa7c4b1a3d30121c(double x, Segment upperSegment) { 
 double left = upperSegment.a.x;
double right = x;
return right;
}


public static double func_d6d9f293ad234798a21900f66e05eaca(double x, Segment upperSegment) { 
 double left = upperSegment.a.x;
double right = x;
return left;
}


*********************************

#### Score: 12.11566


#### Java Tokens: area, cur, curl, last, upper, lower, totalarea, total, size, get, curheight, curu, lastx, height 

public static int func_e3e70a58ce7d44b4bbbebf18cbfe1638(ArrayList<Point> lower, ArrayList<Point> upper) { 
 double curHeight = 1.0 * upper.get(0).y - lower.get(0).y;
int curU = 1;
int curL = 1;
int u = upper.size();
int l = lower.size();
double lastX = 0;
double totalArea = 0.0;
return curU;
}


public static int func_1159e87b8394469dbe07e868e6ab86db(ArrayList<Point> lower, ArrayList<Point> upper) { 
 double curHeight = 1.0 * upper.get(0).y - lower.get(0).y;
int curU = 1;
int curL = 1;
int u = upper.size();
int l = lower.size();
double lastX = 0;
double totalArea = 0.0;
return curL;
}


public static double func_c499649c1d754c51988f784b1c3fbd18(ArrayList<Point> lower, ArrayList<Point> upper) { 
 double curHeight = 1.0 * upper.get(0).y - lower.get(0).y;
int curU = 1;
int curL = 1;
int u = upper.size();
int l = lower.size();
double lastX = 0;
double totalArea = 0.0;
return curHeight;
}


*********************************

#### Score: 12.02843


#### Java Tokens: area, lower, part, guestcount, upper, count, index, totalarea, point, upperpoint, total, answer, segment, partarea, guest, uppersegment, lowerindex 

public static double func_f94e8ca230c34dc3ab504088c966085a(int guestCount, double totalArea, Point[] upperPoint) { 
 int lowerIndex = 0;
double partArea = totalArea / guestCount;
double[] answer = new double[guestCount - 1];
Segment upperSegment = new Segment(upperPoint[0], upperPoint[1]);
return partArea;
}


public static int func_48187888911445d6909350287fc43055(int guestCount, double totalArea, Point[] upperPoint) { 
 int lowerIndex = 0;
double partArea = totalArea / guestCount;
double[] answer = new double[guestCount - 1];
Segment upperSegment = new Segment(upperPoint[0], upperPoint[1]);
return lowerIndex;
}


*********************************

#### Score: 11.75803


#### Java Tokens: next, area, total, nextint, lower, upper, totalarea, int, point 

public static int func_a86ea935ccb04587b63a355333ef6a76(Scanner in) { 
 // lower points
int l = in.nextInt();
// upper points
int u = in.nextInt();
int // guests
g = in.nextInt();
Point[] lower = new Point[l];
for (int i = 0; i < l; ++i) {
    lower[i] = new Point(in.nextInt(), in.nextInt());
}
Point[] upper = new Point[u];
for (int i = 0; i < u; ++i) {
    upper[i] = new Point(in.nextInt(), in.nextInt());
}
double totalArea = 0.0;
return g;
}


public static Point[] func_2d8096e689e841c88861147576eadc45(Scanner in) { 
 // lower points
int l = in.nextInt();
// upper points
int u = in.nextInt();
int // guests
g = in.nextInt();
Point[] lower = new Point[l];
for (int i = 0; i < l; ++i) {
    lower[i] = new Point(in.nextInt(), in.nextInt());
}
Point[] upper = new Point[u];
for (int i = 0; i < u; ++i) {
    upper[i] = new Point(in.nextInt(), in.nextInt());
}
double totalArea = 0.0;
return lower;
}


public static int func_81f77f79797c4ed28e4ecf933e359c06(Scanner in) { 
 int // width
w = in.nextInt();
// lower points
int l = in.nextInt();
// upper points
int u = in.nextInt();
int // guests
g = in.nextInt();
Point[] lower = new Point[l];
for (int i = 0; i < l; ++i) {
    lower[i] = new Point(in.nextInt(), in.nextInt());
}
Point[] upper = new Point[u];
for (int i = 0; i < u; ++i) {
    upper[i] = new Point(in.nextInt(), in.nextInt());
}
double totalArea = 0.0;
return l;
}

