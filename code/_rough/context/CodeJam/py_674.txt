### Py Tokens: firstsum, last, min, nextfirstsum, max, minimax, lastsum, transistorsum, nextlastsum, currentmax, transistors, first 

### Py functions

def func_334edc67e8954d7bad1d3440be9d5980(N, transistors, transistorsum):
    first = 0
    last = N
    firstsum = 0
    lastsum = 0
    minimax = transistorsum
    while last - first != 1:
        nextfirstsum = firstsum + transistors[first]
        nextlastsum = lastsum + transistors[last - 1]
        if nextfirstsum < nextlastsum:
            firstsum += transistors[first]
            first += 1
        else:
            last -= 1
            lastsum += transistors[last]
        currentmax = max([firstsum, lastsum, transistorsum - firstsum -
            lastsum])
        minimax = min(currentmax, minimax)
    return minimax

def func_ae7d8c6943b24accab021f910ee7740d(first, firstsum, last,
    transistors, transistorsum):
    lastsum = 0
    minimax = transistorsum
    while last - first != 1:
        nextfirstsum = firstsum + transistors[first]
        nextlastsum = lastsum + transistors[last - 1]
        if nextfirstsum < nextlastsum:
            firstsum += transistors[first]
            first += 1
        else:
            last -= 1
            lastsum += transistors[last]
        currentmax = max([firstsum, lastsum, transistorsum - firstsum -
            lastsum])
        minimax = min(currentmax, minimax)
    return transistors

def func_9c57b9ed0d8e49509c010e6bb905ca83(first, last, transistors,
    transistorsum):
    firstsum = 0
    lastsum = 0
    minimax = transistorsum
    while last - first != 1:
        nextfirstsum = firstsum + transistors[first]
        nextlastsum = lastsum + transistors[last - 1]
        if nextfirstsum < nextlastsum:
            firstsum += transistors[first]
            first += 1
        else:
            last -= 1
            lastsum += transistors[last]
        currentmax = max([firstsum, lastsum, transistorsum - firstsum -
            lastsum])
        minimax = min(currentmax, minimax)
    return currentmax

def func_b9604b15a6d744a3ba8f890f7aafae45(first, last, transistors,
    transistorsum):
    firstsum = 0
    lastsum = 0
    minimax = transistorsum
    while last - first != 1:
        nextfirstsum = firstsum + transistors[first]
        nextlastsum = lastsum + transistors[last - 1]
        if nextfirstsum < nextlastsum:
            firstsum += transistors[first]
            first += 1
        else:
            last -= 1
            lastsum += transistors[last]
        currentmax = max([firstsum, lastsum, transistorsum - firstsum -
            lastsum])
        minimax = min(currentmax, minimax)
    return lastsum

def func_3816d73a88d0438591e2e04acd262421(N, first, transistors, transistorsum
    ):
    last = N
    firstsum = 0
    lastsum = 0
    minimax = transistorsum
    while last - first != 1:
        nextfirstsum = firstsum + transistors[first]
        nextlastsum = lastsum + transistors[last - 1]
        if nextfirstsum < nextlastsum:
            firstsum += transistors[first]
            first += 1
        else:
            last -= 1
            lastsum += transistors[last]
        currentmax = max([firstsum, lastsum, transistorsum - firstsum -
            lastsum])
        minimax = min(currentmax, minimax)
    return lastsum

*********************************

#### Score: 8.47877


#### Java Tokens: min, last, max, lastx 

public static double func_515a7808cc804f33b25845fc99140891(int lastX) { 
 double min = 0;
double max = lastX;
return min;
}


public static double func_c85420328fa74166a189b942ac0f172e(int lastX) { 
 double min = 0;
double max = lastX;
return max;
}


*********************************

#### Score: 7.53668


#### Java Tokens: min, last, known, max, lastknown, lastx 

public static double func_af08528ec2d9407d8c49c3cbf7c691a9(int lastX) { 
 double lastKnown = 0;
double min = 0;
double max = lastX;
return max;
}


public static double func_778578aa4780429e866005624993378e(int lastX) { 
 double lastKnown = 0;
double min = 0;
double max = lastX;
return lastKnown;
}


public static double func_d9ea7ed8ab5b4716ad8853ae0d8e8033(int lastX) { 
 double lastKnown = 0;
double min = 0;
double max = lastX;
return min;
}


*********************************

#### Score: 7.40147


#### Java Tokens: sum1, last, mid, sum, first 

public static boolean func_4f17acf744644da1a8f33c3f9f8a2022(int n, long mid, long[] a) { 
 int last = 0;
boolean ok = false;
long sum1 = 0;
int first = 0;
while (first != n && sum1 < mid) {
    sum1 += a[first];
    first++;
}
return ok;
}


public static int func_c1fce54b329a4dda803c6c6faea55fc5(int n, long mid, long[] a) { 
 int last = 0;
boolean ok = false;
long sum1 = 0;
int first = 0;
while (first != n && sum1 < mid) {
    sum1 += a[first];
    first++;
}
return first;
}


public static long func_0009b51825a54814baa916c27d03a974(int n, long mid, long[] a) { 
 int last = 0;
boolean ok = false;
long sum1 = 0;
int first = 0;
while (first != n && sum1 < mid) {
    sum1 += a[first];
    first++;
}
return sum1;
}


*********************************

#### Score: 7.14381


#### Java Tokens: min, last, known, max, poly, mid, lastknown 

public static double[] func_f7572b51b70f46b3b73c11d463d80de6(double lastKnown, double min, double max) { 
 double mid = (min + max) / 2;
double[] poly = new double[8];
poly[0] = mid;
poly[1] = 1001;
poly[2] = mid;
poly[3] = -1001;
poly[4] = lastKnown;
poly[5] = -1001;
return poly;
}


public static double[] func_9586cc54512441959154e810ecc424fb(double lastKnown, double min, double max) { 
 double mid = (min + max) / 2;
double[] poly = new double[8];
poly[0] = mid;
poly[1] = 1001;
poly[2] = mid;
poly[3] = -1001;
poly[4] = lastKnown;
poly[5] = -1001;
poly[6] = lastKnown;
poly[7] = 1001;
return poly;
}


public static double func_5a96df258cf04995a6b88481a854668f(double lastKnown, double min, double max) { 
 double mid = (min + max) / 2;
double[] poly = new double[8];
poly[0] = mid;
poly[1] = 1001;
poly[2] = mid;
poly[3] = -1001;
poly[4] = lastKnown;
poly[5] = -1001;
poly[6] = lastKnown;
return mid;
}


*********************************

#### Score: 6.99350


#### Java Tokens: sum1, last, mid, sum, first, second 

public static int func_effbc8ba099d4cb68b5d8223fcbc1fcf(int n, long mid, long[] a) { 
 int last = 0;
boolean ok = false;
long sum1 = 0;
int first = 0;
while (first != n && sum1 < mid) {
    sum1 += a[first];
    first++;
}
int second = n - 1;
return first;
}


public static int func_b0b18a15cb8741d3818a995dc14bcb14(int n, long mid, long[] a) { 
 int last = 0;
boolean ok = false;
long sum1 = 0;
int first = 0;
while (first != n && sum1 < mid) {
    sum1 += a[first];
    first++;
}
int second = n - 1;
return last;
}


public static long func_72f4c22086004ba095364ea9ef291e65(int n, long mid, long[] a) { 
 int last = 0;
boolean ok = false;
long sum1 = 0;
int first = 0;
while (first != n && sum1 < mid) {
    sum1 += a[first];
    first++;
}
int second = n - 1;
return sum1;
}


*********************************

#### Score: 6.97057


#### Java Tokens: min, third, max, ans, math, first, second 

public static long func_afafb4dffcba42a6a6919612545a2461(int j, int i, long third, long ans, long[] A) { 
 long first = A[j + 2];
long second = A[i + 1] - A[j + 2];
ans = Math.min(ans, Math.max(first, Math.max(second, third)));
return first;
}


public static long func_4acad57935d34f28b57f3066b870ebec(int j, int i, long third, long ans, long[] A) { 
 long first = A[j + 1];
long second = A[i + 1] - A[j + 1];
ans = Math.min(ans, Math.max(first, Math.max(second, third)));
return first;
}


public static long func_6bb8fbc65b424efabcabb0db7f50f2c2(int j, int i, long third, long ans, long[] A) { 
 while (j < i && A[i + 1] - A[j + 2] > A[j + 2]) j++;
{
    long first = A[j + 1];
    long second = A[i + 1] - A[j + 1];
    ans = Math.min(ans, Math.max(first, Math.max(second, third)));
}
return ans;
}


*********************************

#### Score: 6.63068


#### Java Tokens: sum1, sum2, last, mid, sum, first, second 

public static int func_e55407da8f4e4e9f854840e611d2d5b3(int n, long mid, long[] a) { 
 int last = 0;
boolean ok = false;
long sum1 = 0;
int first = 0;
while (first != n && sum1 < mid) {
    sum1 += a[first];
    first++;
}
int second = n - 1;
long sum2 = 0;
return first;
}


public static boolean func_810eaaf26d08494bbdf3fe57ac729d85(int n, long mid, long[] a) { 
 int last = 0;
boolean ok = false;
long sum1 = 0;
int first = 0;
while (first != n && sum1 < mid) {
    sum1 += a[first];
    first++;
}
int second = n - 1;
long sum2 = 0;
return ok;
}


public static int func_87acf6a0d38c4b309491fc40e0a13236(int n, long mid, long[] a) { 
 int last = 0;
boolean ok = false;
long sum1 = 0;
int first = 0;
while (first != n && sum1 < mid) {
    sum1 += a[first];
    first++;
}
int second = n - 1;
long sum2 = 0;
return last;
}


*********************************

#### Score: 6.63068


#### Java Tokens: sum1, last, left, mid, sum, right, first 

public static int func_b556a46c54a94ba1960762af1319d01f(int n, long right, long left, long[] a) { 
 long mid = (left + right) / 2;
int last = 0;
boolean ok = false;
long sum1 = 0;
int first = 0;
while (first != n && sum1 < mid) {
    sum1 += a[first];
    first++;
}
return first;
}


public static long func_6710317378fb4e78abcaab5d9e87c820(int n, long right, long left, long[] a) { 
 long mid = (left + right) / 2;
int last = 0;
boolean ok = false;
long sum1 = 0;
int first = 0;
while (first != n && sum1 < mid) {
    sum1 += a[first];
    first++;
}
return sum1;
}


public static long func_c755bda6082f49afabad6d2eaa5853be(long right, long left) { 
 long mid = (left + right) / 2;
int last = 0;
boolean ok = false;
long sum1 = 0;
int first = 0;
return mid;
}


*********************************

#### Score: 6.62796


#### Java Tokens: res, min, third, max, ans, math, first, second 

public static long[] func_fca8c456d81e48b5965cb158958a1664(int N, long q, long s, long r, long p) { 
 long[] a = new long[N];
for (int i = 0; i < N; i++) a[i] = ((i * p + q) % r + s);
long[] A = new long[N + 1];
for (int i = 0; i < N; i++) A[i + 1] = A[i] + a[i];
int j = 0;
long ans = A[N];
for (int i = 0; i < N; i++) {
    long third = A[N] - A[i + 1];
    while (j < i && A[i + 1] - A[j + 2] > A[j + 2]) j++;
    {
        long first = A[j + 1];
        long second = A[i + 1] - A[j + 1];
        ans = Math.min(ans, Math.max(first, Math.max(second, third)));
    }
    if (j < i) {
        long first = A[j + 2];
        long second = A[i + 1] - A[j + 2];
        ans = Math.min(ans, Math.max(first, Math.max(second, third)));
    }
}
double res = (A[N] - ans) * 1.0 / A[N];
return A;
}


public static int func_c716d2e6d97544f198887d9bd5066b7c(int N, long[] A) { 
 int j = 0;
long ans = A[N];
for (int i = 0; i < N; i++) {
    long third = A[N] - A[i + 1];
    while (j < i && A[i + 1] - A[j + 2] > A[j + 2]) j++;
    {
        long first = A[j + 1];
        long second = A[i + 1] - A[j + 1];
        ans = Math.min(ans, Math.max(first, Math.max(second, third)));
    }
    if (j < i) {
        long first = A[j + 2];
        long second = A[i + 1] - A[j + 2];
        ans = Math.min(ans, Math.max(first, Math.max(second, third)));
    }
}
double res = (A[N] - ans) * 1.0 / A[N];
return j;
}


public static long[] func_81d5736f710547b88d4802552b7627d3(int N, long q, long s, long r, long p) { 
 long[] a = new long[N];
for (int i = 0; i < N; i++) a[i] = ((i * p + q) % r + s);
long[] A = new long[N + 1];
for (int i = 0; i < N; i++) A[i + 1] = A[i] + a[i];
int j = 0;
long ans = A[N];
for (int i = 0; i < N; i++) {
    long third = A[N] - A[i + 1];
    while (j < i && A[i + 1] - A[j + 2] > A[j + 2]) j++;
    {
        long first = A[j + 1];
        long second = A[i + 1] - A[j + 1];
        ans = Math.min(ans, Math.max(first, Math.max(second, third)));
    }
    if (j < i) {
        long first = A[j + 2];
        long second = A[i + 1] - A[j + 2];
        ans = Math.min(ans, Math.max(first, Math.max(second, third)));
    }
}
double res = (A[N] - ans) * 1.0 / A[N];
return a;
}


*********************************

#### Score: 6.62796


#### Java Tokens: res, min, max, left, sum, math, first, second 

public static double func_4c746d2a2e674d1a9df41c902c6d83cb(int first, int N, int second, long sum, long[] dp) { 
 double res = 0;
for (int i = Math.max(0, first - 100); i < Math.min(N, first + 100); ++i) {
    for (int j = Math.max(0, second - 100); j < Math.min(N, second + 100); ++j) {
        if (j <= i) {
            continue;
        }
        long a = dp[i + 1];
        long b = dp[j] - dp[i + 1];
        long c = dp[N] - dp[j];
        long left = sum - Math.max(a, Math.max(b, c));
        res = Math.max(res, 1.0 * left / sum);
    }
}
return res;
}

