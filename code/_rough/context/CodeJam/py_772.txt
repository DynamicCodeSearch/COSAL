### Py Tokens: need, bisectleft, bisect, first, pos, left 

### Py functions

def func_fa71c6c62965482ca49f01f10ed2fcc1(a, i):
    first = a[i]
    need = first + (a[-1] - first) / 2
    pos = bisect.bisect_left(a, need)
    return i

def func_4876087fe86b4387b7de34a2863a85c9(a, i):
    first = a[i]
    need = first + (a[-1] - first) / 2
    pos = bisect.bisect_left(a, need)
    return a

*********************************

#### Score: 9.02196


#### Java Tokens: left, need, right 

public static long func_17f71a3fbdf14d668a145dde1465d1df(int i, long eq, long left, long right) { 
 long up = (left + right) / 2;
long need = eq + i * up;
return up;
}


public static long func_5937e82ecc73452fb8fb2543632ab580(int i, long eq, long left, long right) { 
 long up = (left + right) / 2;
long need = eq + i * up;
return need;
}


*********************************

#### Score: 6.77129


#### Java Tokens: money, left, need, max, ans, right, math, prof 

public static double func_7ecaec56d42b44fcb5f7f83571efc283(int m, long money, long[] a, double ans) { 
 for (int i = 1; i <= m; i++) {
    long now = a[i - 1];
    long eq = 0;
    for (int j = 0; j < i; j++) {
        eq += now - a[j];
    }
    int same = 0;
    for (int j = i; j < m; j++) {
        if (a[j] == now) {
            same++;
        }
    }
    if (eq + same > money) {
        break;
    }
    long left = 0;
    long right = money + 1;
    while (left + 1 < right) {
        long up = (left + right) / 2;
        long need = eq + i * up;
        for (int j = i; j < m; j++) {
            need += Math.max((now + up + 1) - a[j], 0);
            if (need > money) {
                break;
            }
        }
        if (need > money) {
            right = up;
        } else {
            left = up;
        }
    }
    long up = left;
    double prof = -eq - up * i;
    for (int j = i; j < m; j++) {
        prof -= Math.max((now + up + 1) - a[j], 0);
    }
    for (int j = 0; j < i; j++) {
        prof += (now + up - a[j]) * 36.0 / i;
    }
    ans = Math.max(ans, prof);
}
return ans;
}


public static double func_64eadc23139f41658102c24af6193d85(int m, long money, long[] a) { 
 double ans = 0;
for (int i = 1; i <= m; i++) {
    long now = a[i - 1];
    long eq = 0;
    for (int j = 0; j < i; j++) {
        eq += now - a[j];
    }
    int same = 0;
    for (int j = i; j < m; j++) {
        if (a[j] == now) {
            same++;
        }
    }
    if (eq + same > money) {
        break;
    }
    long left = 0;
    long right = money + 1;
    while (left + 1 < right) {
        long up = (left + right) / 2;
        long need = eq + i * up;
        for (int j = i; j < m; j++) {
            need += Math.max((now + up + 1) - a[j], 0);
            if (need > money) {
                break;
            }
        }
        if (need > money) {
            right = up;
        } else {
            left = up;
        }
    }
    long up = left;
    double prof = -eq - up * i;
    for (int j = i; j < m; j++) {
        prof -= Math.max((now + up + 1) - a[j], 0);
    }
    for (int j = 0; j < i; j++) {
        prof += (now + up - a[j]) * 36.0 / i;
    }
    ans = Math.max(ans, prof);
}
return ans;
}


*********************************

#### Score: 6.53703


#### Java Tokens: pos 

public static int func_1196f0d0aef14fc1ac52ae7c8892dfd2(int i, int[][] pos) { 
 int nx = pos[i][0];
int ny = pos[i][1];
return ny;
}


public static int func_67d659eeef4941deb5e9de0dca048017(int l, int py, int px, int[][] pos) { 
 px = pos[l][0];
py = pos[l][1];
return px;
}


public static int func_644c113398604f858135ae9caaaf0ac7(int[][] pos) { 
 int px = pos[0][0];
int py = pos[0][1];
return py;
}


*********************************

#### Score: 6.20068


#### Java Tokens: sum1, last, left, mid, sum, right, first 

public static int func_b556a46c54a94ba1960762af1319d01f(int n, long right, long left, long[] a) { 
 long mid = (left + right) / 2;
int last = 0;
boolean ok = false;
long sum1 = 0;
int first = 0;
while (first != n && sum1 < mid) {
    sum1 += a[first];
    first++;
}
return first;
}


public static long func_6710317378fb4e78abcaab5d9e87c820(int n, long right, long left, long[] a) { 
 long mid = (left + right) / 2;
int last = 0;
boolean ok = false;
long sum1 = 0;
int first = 0;
while (first != n && sum1 < mid) {
    sum1 += a[first];
    first++;
}
return sum1;
}


public static long func_c755bda6082f49afabad6d2eaa5853be(long right, long left) { 
 long mid = (left + right) / 2;
int last = 0;
boolean ok = false;
long sum1 = 0;
int first = 0;
return mid;
}


*********************************

#### Score: 6.17000


#### Java Tokens: println, system, money, left, need, max, ans, right, math, prof 

public static double func_3566555dbea14fb6bcdcf03323b98a38(int m, long money, long[] a, double ans) { 
 for (int i = 1; i <= m; i++) {
    long now = a[i - 1];
    long eq = 0;
    for (int j = 0; j < i; j++) {
        eq += now - a[j];
    }
    int same = 0;
    for (int j = i; j < m; j++) {
        if (a[j] == now) {
            same++;
        }
    }
    if (eq + same > money) {
        break;
    }
    long left = 0;
    long right = money + 1;
    while (left + 1 < right) {
        long up = (left + right) / 2;
        long need = eq + i * up;
        for (int j = i; j < m; j++) {
            need += Math.max((now + up + 1) - a[j], 0);
            if (need > money) {
                break;
            }
        }
        if (need > money) {
            right = up;
        } else {
            left = up;
        }
    }
    long up = left;
    double prof = -eq - up * i;
    for (int j = i; j < m; j++) {
        prof -= Math.max((now + up + 1) - a[j], 0);
    }
    for (int j = 0; j < i; j++) {
        prof += (now + up - a[j]) * 36.0 / i;
    }
    ans = Math.max(ans, prof);
}
System.out.println(ans);
A.out.println(ans);
return ans;
}


public static double func_5ddf75c3e04b4396be94b130db8546ac(int m, long money, long[] a) { 
 double ans = 0;
for (int i = 1; i <= m; i++) {
    long now = a[i - 1];
    long eq = 0;
    for (int j = 0; j < i; j++) {
        eq += now - a[j];
    }
    int same = 0;
    for (int j = i; j < m; j++) {
        if (a[j] == now) {
            same++;
        }
    }
    if (eq + same > money) {
        break;
    }
    long left = 0;
    long right = money + 1;
    while (left + 1 < right) {
        long up = (left + right) / 2;
        long need = eq + i * up;
        for (int j = i; j < m; j++) {
            need += Math.max((now + up + 1) - a[j], 0);
            if (need > money) {
                break;
            }
        }
        if (need > money) {
            right = up;
        } else {
            left = up;
        }
    }
    long up = left;
    double prof = -eq - up * i;
    for (int j = i; j < m; j++) {
        prof -= Math.max((now + up + 1) - a[j], 0);
    }
    for (int j = 0; j < i; j++) {
        prof += (now + up - a[j]) * 36.0 / i;
    }
    ans = Math.max(ans, prof);
}
System.out.println(ans);
return ans;
}


public static double func_dbc6fe7121664a8f8e391bf82f0c0724(int m, long money, long[] a) { 
 double ans = 0;
for (int i = 1; i <= m; i++) {
    long now = a[i - 1];
    long eq = 0;
    for (int j = 0; j < i; j++) {
        eq += now - a[j];
    }
    int same = 0;
    for (int j = i; j < m; j++) {
        if (a[j] == now) {
            same++;
        }
    }
    if (eq + same > money) {
        break;
    }
    long left = 0;
    long right = money + 1;
    while (left + 1 < right) {
        long up = (left + right) / 2;
        long need = eq + i * up;
        for (int j = i; j < m; j++) {
            need += Math.max((now + up + 1) - a[j], 0);
            if (need > money) {
                break;
            }
        }
        if (need > money) {
            right = up;
        } else {
            left = up;
        }
    }
    long up = left;
    double prof = -eq - up * i;
    for (int j = i; j < m; j++) {
        prof -= Math.max((now + up + 1) - a[j], 0);
    }
    for (int j = 0; j < i; j++) {
        prof += (now + up - a[j]) * 36.0 / i;
    }
    ans = Math.max(ans, prof);
}
System.out.println(ans);
A.out.println(ans);
return ans;
}


*********************************

#### Score: 6.17000


#### Java Tokens: money, left, need, max, ans, arrays, sort, right, math, prof 

public static double func_334782fec40c425aa170dfacff764a66(int m, long money, long[] a) { 
 Arrays.sort(a);
double ans = 0;
for (int i = 1; i <= m; i++) {
    long now = a[i - 1];
    long eq = 0;
    for (int j = 0; j < i; j++) {
        eq += now - a[j];
    }
    int same = 0;
    for (int j = i; j < m; j++) {
        if (a[j] == now) {
            same++;
        }
    }
    if (eq + same > money) {
        break;
    }
    long left = 0;
    long right = money + 1;
    while (left + 1 < right) {
        long up = (left + right) / 2;
        long need = eq + i * up;
        for (int j = i; j < m; j++) {
            need += Math.max((now + up + 1) - a[j], 0);
            if (need > money) {
                break;
            }
        }
        if (need > money) {
            right = up;
        } else {
            left = up;
        }
    }
    long up = left;
    double prof = -eq - up * i;
    for (int j = i; j < m; j++) {
        prof -= Math.max((now + up + 1) - a[j], 0);
    }
    for (int j = 0; j < i; j++) {
        prof += (now + up - a[j]) * 36.0 / i;
    }
    ans = Math.max(ans, prof);
}
return ans;
}


*********************************

#### Score: 6.07038


#### Java Tokens: pos, bound 

public static int func_e56fbf72e0224d66b77b40ae8b9f585b(int w, int[][] pos) { 
 double[] bound = new double[w + 1];
int px = pos[0][0];
int py = pos[0][1];
return py;
}


public static int func_6b9bb5b3b1cd4a60ac5a15167a40b0c6(int w, int[][] pos) { 
 double[] bound = new double[w + 1];
int px = pos[0][0];
return px;
}


public static int func_97cddfce9b7c452f8695797bae1d62e3(int w, int[][] pos) { 
 double[] bound = new double[w + 1];
int px = pos[0][0];
int py = pos[0][1];
return px;
}


*********************************

#### Score: 6.07038


#### Java Tokens: div, pos 

public static int func_cd9b5fe359cb40bf81b56ae592a1baa4(int nx, int i, int px, int[][] pos) { 
 int ny = pos[i][1];
double div = nx - px;
return ny;
}


public static int func_ccafa875904d402aad92ff0ee0925965(int px, int i, int[][] pos) { 
 int nx = pos[i][0];
int ny = pos[i][1];
double div = nx - px;
return ny;
}


public static double func_9a6f36d3b0f749569eb0f7063a887413(int nx, int px, int i, int[][] pos) { 
 int ny = pos[i][1];
double div = nx - px;
return div;
}


*********************************

#### Score: 6.07038


#### Java Tokens: pos, exp 

public static int func_d0a7c296e021459dacf6b862a210eb59(int n, double[] exp) { 
 int pos = 0;
for (int k = 1; k < n; k++) {
    if (exp[k] > exp[pos]) {
        pos = k;
    }
}
return pos;
}


*********************************

#### Score: 5.89843


#### Java Tokens: sum1, last, left, mid, sum, right, first, second 

public static int func_f80e820de2814c65ab99a82d97a1920a(int n, long right, long left, long[] a) { 
 long mid = (left + right) / 2;
int last = 0;
boolean ok = false;
long sum1 = 0;
int first = 0;
while (first != n && sum1 < mid) {
    sum1 += a[first];
    first++;
}
int second = n - 1;
return second;
}


public static long func_9e483109833f41be8520f97fd2cb36af(int n, long right, long left, long[] a) { 
 long mid = (left + right) / 2;
int last = 0;
boolean ok = false;
long sum1 = 0;
int first = 0;
while (first != n && sum1 < mid) {
    sum1 += a[first];
    first++;
}
int second = n - 1;
return sum1;
}


public static boolean func_823329376d504486aaa12addfd4ef6ea(int n, long right, long left, long[] a) { 
 long mid = (left + right) / 2;
int last = 0;
boolean ok = false;
long sum1 = 0;
int first = 0;
while (first != n && sum1 < mid) {
    sum1 += a[first];
    first++;
}
int second = n - 1;
return ok;
}

