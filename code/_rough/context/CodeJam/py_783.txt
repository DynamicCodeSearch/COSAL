### Py Tokens: third, bisect, max, float, pos, second, bisectleft, need, first, best, left 

### Py functions

def func_f0f26af37e6d4d319e86951009986378(a, best, i, q):
    first = a[i]
    need = first + (a[-1] - first) / 2
    pos = bisect.bisect_left(a, need)
    second = a[pos] - first
    third = a[-1] - first - second
    m = a[-1] - max(first, second, third)
    if float(m) / float(a[-1]) > best:
        q = i, pos
        best = float(m) / float(a[-1])
    return third

def func_6793902e14294fde954c503a002001b2(a, best, i, q):
    first = a[i]
    need = first + (a[-1] - first) / 2
    pos = bisect.bisect_left(a, need)
    second = a[pos] - first
    third = a[-1] - first - second
    m = a[-1] - max(first, second, third)
    if float(m) / float(a[-1]) > best:
        q = i, pos
        best = float(m) / float(a[-1])
    return best

def func_05da3e494d324c86afe8dda945e0792a(a, best, first, i, q):
    need = first + (a[-1] - first) / 2
    pos = bisect.bisect_left(a, need)
    second = a[pos] - first
    third = a[-1] - first - second
    m = a[-1] - max(first, second, third)
    if float(m) / float(a[-1]) > best:
        q = i, pos
        best = float(m) / float(a[-1])
    if pos - 1 > i:
        second = a[pos - 1] - first
        third = a[-1] - first - second
        m = a[-1] - max(first, second, third)
        if float(m) / float(a[-1]) > best:
            best = float(m) / float(a[-1])
            q = i, pos - 1
    return best

def func_8eb1ab933ab74758899c527f5de0a35e(a, best, first, i, q):
    need = first + (a[-1] - first) / 2
    pos = bisect.bisect_left(a, need)
    second = a[pos] - first
    third = a[-1] - first - second
    m = a[-1] - max(first, second, third)
    if float(m) / float(a[-1]) > best:
        q = i, pos
        best = float(m) / float(a[-1])
    return need

def func_78f2a095dd644fd5a8e114acdaaf48ad(a, best, first, i, q):
    need = first + (a[-1] - first) / 2
    pos = bisect.bisect_left(a, need)
    second = a[pos] - first
    third = a[-1] - first - second
    m = a[-1] - max(first, second, third)
    if float(m) / float(a[-1]) > best:
        q = i, pos
        best = float(m) / float(a[-1])
    if pos - 1 > i:
        second = a[pos - 1] - first
        third = a[-1] - first - second
        m = a[-1] - max(first, second, third)
        if float(m) / float(a[-1]) > best:
            best = float(m) / float(a[-1])
            q = i, pos - 1
    return third

*********************************

#### Score: 14.71463


#### Java Tokens: third, max, math, first, partials, second 

public static long func_9bef6ad9dbad4d8296578483419abeba(int n, int a, int b, long[] partials) { 
 long first = partials[a];
long second = partials[b] - partials[a];
long third = partials[n] - partials[b];
return Math.max(first, Math.max(second, third));

}


*********************************

#### Score: 14.71463


#### Java Tokens: third, max, math, partials, first, second 

public static long func_602ab9a28f8c49649d64967ae142b68d(int n, int b, long first, long second, long[] partials) { 
 long third = partials[n] - partials[b];
return Math.max(first, Math.max(second, third));

}


public static long func_cbf8f04ab48043459e7dbf88a7da3dea(int n, int a, int b, long first, long[] partials) { 
 long second = partials[b] - partials[a];
long third = partials[n] - partials[b];
return Math.max(first, Math.max(second, third));

}


*********************************

#### Score: 14.60295


#### Java Tokens: third, first, partials, second 

public static long func_2926cd6f08dd42f7abdf12de7632dccb(int n, int a, int b, long[] partials) { 
 long first = partials[a];
long second = partials[b] - partials[a];
long third = partials[n] - partials[b];
return third;
}


public static long func_b0b89ea38bcc416395fd797ba799f139(int n, int a, int b, long[] partials) { 
 long first = partials[a];
long second = partials[b] - partials[a];
long third = partials[n] - partials[b];
return second;
}


public static long func_c5863e24bd924b0cb8d86ef7f95cf124(int n, int a, int b, long[] partials) { 
 long first = partials[a];
long second = partials[b] - partials[a];
long third = partials[n] - partials[b];
return first;
}


*********************************

#### Score: 13.92469


#### Java Tokens: min, third, max, ans, math, first, second 

public static long func_afafb4dffcba42a6a6919612545a2461(int j, int i, long third, long ans, long[] A) { 
 long first = A[j + 2];
long second = A[i + 1] - A[j + 2];
ans = Math.min(ans, Math.max(first, Math.max(second, third)));
return first;
}


public static long func_4acad57935d34f28b57f3066b870ebec(int j, int i, long third, long ans, long[] A) { 
 long first = A[j + 1];
long second = A[i + 1] - A[j + 1];
ans = Math.min(ans, Math.max(first, Math.max(second, third)));
return first;
}


public static long func_6bb8fbc65b424efabcabb0db7f50f2c2(int j, int i, long third, long ans, long[] A) { 
 while (j < i && A[i + 1] - A[j + 2] > A[j + 2]) j++;
{
    long first = A[j + 1];
    long second = A[i + 1] - A[j + 1];
    ans = Math.min(ans, Math.max(first, Math.max(second, third)));
}
return ans;
}


*********************************

#### Score: 13.21757


#### Java Tokens: res, min, third, max, ans, math, first, second 

public static long[] func_fca8c456d81e48b5965cb158958a1664(int N, long q, long s, long r, long p) { 
 long[] a = new long[N];
for (int i = 0; i < N; i++) a[i] = ((i * p + q) % r + s);
long[] A = new long[N + 1];
for (int i = 0; i < N; i++) A[i + 1] = A[i] + a[i];
int j = 0;
long ans = A[N];
for (int i = 0; i < N; i++) {
    long third = A[N] - A[i + 1];
    while (j < i && A[i + 1] - A[j + 2] > A[j + 2]) j++;
    {
        long first = A[j + 1];
        long second = A[i + 1] - A[j + 1];
        ans = Math.min(ans, Math.max(first, Math.max(second, third)));
    }
    if (j < i) {
        long first = A[j + 2];
        long second = A[i + 1] - A[j + 2];
        ans = Math.min(ans, Math.max(first, Math.max(second, third)));
    }
}
double res = (A[N] - ans) * 1.0 / A[N];
return A;
}


public static int func_c716d2e6d97544f198887d9bd5066b7c(int N, long[] A) { 
 int j = 0;
long ans = A[N];
for (int i = 0; i < N; i++) {
    long third = A[N] - A[i + 1];
    while (j < i && A[i + 1] - A[j + 2] > A[j + 2]) j++;
    {
        long first = A[j + 1];
        long second = A[i + 1] - A[j + 1];
        ans = Math.min(ans, Math.max(first, Math.max(second, third)));
    }
    if (j < i) {
        long first = A[j + 2];
        long second = A[i + 1] - A[j + 2];
        ans = Math.min(ans, Math.max(first, Math.max(second, third)));
    }
}
double res = (A[N] - ans) * 1.0 / A[N];
return j;
}


public static long[] func_81d5736f710547b88d4802552b7627d3(int N, long q, long s, long r, long p) { 
 long[] a = new long[N];
for (int i = 0; i < N; i++) a[i] = ((i * p + q) % r + s);
long[] A = new long[N + 1];
for (int i = 0; i < N; i++) A[i + 1] = A[i] + a[i];
int j = 0;
long ans = A[N];
for (int i = 0; i < N; i++) {
    long third = A[N] - A[i + 1];
    while (j < i && A[i + 1] - A[j + 2] > A[j + 2]) j++;
    {
        long first = A[j + 1];
        long second = A[i + 1] - A[j + 1];
        ans = Math.min(ans, Math.max(first, Math.max(second, third)));
    }
    if (j < i) {
        long first = A[j + 2];
        long second = A[i + 1] - A[j + 2];
        ans = Math.min(ans, Math.max(first, Math.max(second, third)));
    }
}
double res = (A[N] - ans) * 1.0 / A[N];
return a;
}


*********************************

#### Score: 11.74218


#### Java Tokens: third, partials, second 

public static long func_b2c98da8adf349b8b50ee71be4284e1a(int n, int a, int b, long[] partials) { 
 long second = partials[b] - partials[a];
long third = partials[n] - partials[b];
return third;
}


public static long func_0fcdac1e337b47c390d82d5c204eb54a(int n, int a, int b, long[] partials) { 
 long second = partials[b] - partials[a];
long third = partials[n] - partials[b];
return second;
}


*********************************

#### Score: 11.02185


#### Java Tokens: res, min, max, left, sum, math, first, second 

public static double func_4c746d2a2e674d1a9df41c902c6d83cb(int first, int N, int second, long sum, long[] dp) { 
 double res = 0;
for (int i = Math.max(0, first - 100); i < Math.min(N, first + 100); ++i) {
    for (int j = Math.max(0, second - 100); j < Math.min(N, second + 100); ++j) {
        if (j <= i) {
            continue;
        }
        long a = dp[i + 1];
        long b = dp[j] - dp[i + 1];
        long c = dp[N] - dp[j];
        long left = sum - Math.max(a, Math.max(b, c));
        res = Math.max(res, 1.0 * left / sum);
    }
}
return res;
}


*********************************

#### Score: 9.94084


#### Java Tokens: sum1, sum2, last, left, mid, sum, right, first, second, second-- 

public static long func_f2dbea602aa149e3b81b075be6c2c66e(int n, long right, long left, long[] a) { 
 long mid = (left + right) / 2;
int last = 0;
boolean ok = false;
long sum1 = 0;
int first = 0;
while (first != n && sum1 < mid) {
    sum1 += a[first];
    first++;
}
int second = n - 1;
long sum2 = 0;
while (second != -1 && sum2 < mid) {
    sum2 += a[second];
    second--;
}
return sum1;
}


public static int func_df5e24485337484e94260a0ec67a439e(int n, long right, long left, long[] a) { 
 long mid = (left + right) / 2;
int last = 0;
boolean ok = false;
long sum1 = 0;
int first = 0;
while (first != n && sum1 < mid) {
    sum1 += a[first];
    first++;
}
int second = n - 1;
long sum2 = 0;
while (second != -1 && sum2 < mid) {
    sum2 += a[second];
    second--;
}
return last;
}


public static boolean func_1f3643c778f3486688e0beb7d6c436ce(int n, long right, long left, long[] a) { 
 long mid = (left + right) / 2;
int last = 0;
boolean ok = false;
long sum1 = 0;
int first = 0;
while (first != n && sum1 < mid) {
    sum1 += a[first];
    first++;
}
int second = n - 1;
long sum2 = 0;
while (second != -1 && sum2 < mid) {
    sum2 += a[second];
    second--;
}
return ok;
}


*********************************

#### Score: 9.75865


#### Java Tokens: first, second 

public static long func_05ae5d93a52d45ed8dde238d6245af06(int j, int i, long[] A) { 
 long first = A[j + 2];
long second = A[i + 1] - A[j + 2];
return first;
}


public static long func_24855a22c9de45fdb5ea51748056936d(int j, int i, long[] A) { 
 long first = A[j + 2];
long second = A[i + 1] - A[j + 2];
return second;
}


public static long func_ee5d4f9bc54c41e1afd1cd73fe7b9b9e(int j, int i, long[] A) { 
 long first = A[j + 1];
long second = A[i + 1] - A[j + 1];
return second;
}


*********************************

#### Score: 9.56778


#### Java Tokens: sum1, sum2, total, last, left, mid, sum, right, first, second, second-- 

public static boolean func_fa1043d97adc48faa10a830d131d66db(int n, long right, long left, long[] a, long[] sum) { 
 long mid = (left + right) / 2;
int last = 0;
boolean ok = false;
long sum1 = 0;
int first = 0;
while (first != n && sum1 < mid) {
    sum1 += a[first];
    first++;
}
int second = n - 1;
long sum2 = 0;
while (second != -1 && sum2 < mid) {
    sum2 += a[second];
    second--;
}
if (sum1 >= mid && sum2 >= mid) {
    if (second >= first) {
        ok = true;
    } else {
        long total = 0;
        if (second != -1)
            total += sum[second];
        if (first != n)
            total += sum[n - 1] - sum[first - 1];
        if (total >= mid)
            ok = true;
    }
}
return ok;
}


public static int func_231c3c8249f942929ae5c9a69e0d6a72(int n, long right, long left, long[] a, long[] sum) { 
 long mid = (left + right) / 2;
int last = 0;
boolean ok = false;
long sum1 = 0;
int first = 0;
while (first != n && sum1 < mid) {
    sum1 += a[first];
    first++;
}
int second = n - 1;
long sum2 = 0;
while (second != -1 && sum2 < mid) {
    sum2 += a[second];
    second--;
}
if (sum1 >= mid && sum2 >= mid) {
    if (second >= first) {
        ok = true;
    } else {
        long total = 0;
        if (second != -1)
            total += sum[second];
        if (first != n)
            total += sum[n - 1] - sum[first - 1];
        if (total >= mid)
            ok = true;
    }
}
return second;
}


public static int func_0d4090c96c2a431786186984b15c8096(int n, long right, long left, long[] a, long[] sum) { 
 long mid = (left + right) / 2;
int last = 0;
boolean ok = false;
long sum1 = 0;
int first = 0;
while (first != n && sum1 < mid) {
    sum1 += a[first];
    first++;
}
int second = n - 1;
long sum2 = 0;
while (second != -1 && sum2 < mid) {
    sum2 += a[second];
    second--;
}
if (sum1 >= mid && sum2 >= mid) {
    if (second >= first) {
        ok = true;
    } else {
        long total = 0;
        if (second != -1)
            total += sum[second];
        if (first != n)
            total += sum[n - 1] - sum[first - 1];
        if (total >= mid)
            ok = true;
    }
}
return first;
}

