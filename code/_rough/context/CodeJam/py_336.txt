### Py Tokens: sorted, join, str, cmp1, cmp 

### Py functions

def func_c9693c63583e4e49b7471ac79a57f3ec(c, x):
    c = sorted(c, cmp=cmp1)
    return ' '.join([str(x[0]) for x in c])

def func_7f3406896c6f448c812a9419728f6130(c, x):
    c = sorted(c, cmp=cmp1)
    return ' '.join([str(x[0]) for x in c])

def func_58806116c2d742a1858fcf4df9488d70(c, x):
    c = sorted(c, cmp=cmp1)
    return ' '.join([str(x[0]) for x in c])

*********************************

#### Score: 4.19640


#### Java Tokens: add, sortedset, sorted, set, tree, integer, treeset 

public static SortedSet<Integer> func_908a1fb2d6ea4b70bac7de1f0210bf2e(int l, int[] xl) { 
 SortedSet<Integer> xs = new TreeSet<Integer>();
for (int i = 0; i < l; i++) {
    xs.add(xl[i]);
}
return xs;
}


public static SortedSet<Integer> func_33d30156f21a452c9e7e9783fd47a69d(int l, int u, int[] xu, int[] xl) { 
 SortedSet<Integer> xs = new TreeSet<Integer>();
for (int i = 0; i < l; i++) {
    xs.add(xl[i]);
}
for (int i = 0; i < u; i++) {
    xs.add(xu[i]);
}
return xs;
}


*********************************

#### Score: 3.99921


#### Java Tokens: add, sortedset, sorted, set, size, tree, integer, treeset 

public static SortedSet<Integer> func_4ce0a44eab0542dfa8546f1c61bacac4(int l, int u, int[] xu, int[] xl) { 
 SortedSet<Integer> xs = new TreeSet<Integer>();
for (int i = 0; i < l; i++) {
    xs.add(xl[i]);
}
for (int i = 0; i < u; i++) {
    xs.add(xu[i]);
}
int[] nx = new int[xs.size()];
return xs;
}


public static int[] func_1fe4188d08b24ee0990c1d1b63842dc2(int l, int u, int[] xu, int[] xl) { 
 SortedSet<Integer> xs = new TreeSet<Integer>();
for (int i = 0; i < l; i++) {
    xs.add(xl[i]);
}
for (int i = 0; i < u; i++) {
    xs.add(xu[i]);
}
int[] nx = new int[xs.size()];
return nx;
}


public static int[] func_900079f612634215823886119e9e27bb(int l, int u, int[] xu, int[] xl) { 
 SortedSet<Integer> xs = new TreeSet<Integer>();
for (int i = 0; i < l; i++) {
    xs.add(xl[i]);
}
for (int i = 0; i < u; i++) {
    xs.add(xu[i]);
}
int[] nx = new int[xs.size()];
{
    int i = 0;
    for (int xx : xs) {
        nx[i++] = xx;
    }
}
return nx;
}


*********************************

#### Score: 3.82166


#### Java Tokens: add, sortedset, sorted, set, size, tree, length, integer, treeset 

public static int[] func_6a5e7e859297479b9467357300fe07c1(int l, int u, int[] xu, int[] xl) { 
 SortedSet<Integer> xs = new TreeSet<Integer>();
for (int i = 0; i < l; i++) {
    xs.add(xl[i]);
}
for (int i = 0; i < u; i++) {
    xs.add(xu[i]);
}
int[] nx = new int[xs.size()];
{
    int i = 0;
    for (int xx : xs) {
        nx[i++] = xx;
    }
}
double[] ny = new double[nx.length];
return nx;
}


public static SortedSet<Integer> func_ce9d48e027814f3992228953ecdf796f(int l, int u, int[] xu, int[] xl) { 
 SortedSet<Integer> xs = new TreeSet<Integer>();
for (int i = 0; i < l; i++) {
    xs.add(xl[i]);
}
for (int i = 0; i < u; i++) {
    xs.add(xu[i]);
}
int[] nx = new int[xs.size()];
{
    int i = 0;
    for (int xx : xs) {
        nx[i++] = xx;
    }
}
double[] ny = new double[nx.length];
return xs;
}


public static double[] func_985ac19939df45b0aa6e6fb24e535b72(int l, int u, int[] xu, int[] xl) { 
 SortedSet<Integer> xs = new TreeSet<Integer>();
for (int i = 0; i < l; i++) {
    xs.add(xl[i]);
}
for (int i = 0; i < u; i++) {
    xs.add(xu[i]);
}
int[] nx = new int[xs.size()];
{
    int i = 0;
    for (int xx : xs) {
        nx[i++] = xx;
    }
}
double[] ny = new double[nx.length];
return ny;
}


*********************************

#### Score: 0.43437


#### Java Tokens: next, area, println, irregularcakes, part, irregular, cakes 

public static double func_9b932effc3ed4da4b1b5fcd52925f5d3(int W, double part) { 
 double lb = 0;
double ub = W;
while (ub - lb > 0.000000001) {
    double next = (ub + lb) / 2;
    double area = IrregularCakes.area(next);
    if (area > part) {
        ub = next;
    } else {
        lb = next;
    }
}
IrregularCakes.out.println(lb);
return ub;
}


public static double func_9e53938a4375458c87dac84506b255ef(double ub, double part, double lb) { 
 while (ub - lb > 0.000000001) {
    double next = (ub + lb) / 2;
    double area = IrregularCakes.area(next);
    if (area > part) {
        ub = next;
    } else {
        lb = next;
    }
}
IrregularCakes.out.println(lb);
return lb;
}


public static double func_d734fc60f73449708bc872e3e25b145a(double ub, double part, double lb) { 
 while (ub - lb > 0.000000001) {
    double next = (ub + lb) / 2;
    double area = IrregularCakes.area(next);
    if (area > part) {
        ub = next;
    } else {
        lb = next;
    }
}
IrregularCakes.out.println(lb);
return ub;
}


*********************************

#### Score: 0.43437


#### Java Tokens: next, beforehalf, half, nextint, best, sum, int, beforehalfsum 

public static long func_eea237da523c48979f2af872bd17374e(int N, long q, long p, long r, Scanner in) { 
 long s = in.nextInt();
long[] A = new long[N];
for (int n = 0; n < N; n++) {
    A[n] = (n * p + q) % r + s;
}
long[] best = new long[N];
int beforeHalf = 0;
long beforeHalfSum = 0;
return s;
}


public static int func_8ea3224b72af4442a1bf756ef8ada3b2(int N, long q, long p, Scanner in) { 
 long r = in.nextInt();
long s = in.nextInt();
long[] A = new long[N];
for (int n = 0; n < N; n++) {
    A[n] = (n * p + q) % r + s;
}
long[] best = new long[N];
int beforeHalf = 0;
long beforeHalfSum = 0;
return beforeHalf;
}


public static long func_cfa345a37df74b58a2ad0f406318ab15(int N, Scanner in) { 
 long p = in.nextInt();
long q = in.nextInt();
long r = in.nextInt();
long s = in.nextInt();
long[] A = new long[N];
for (int n = 0; n < N; n++) {
    A[n] = (n * p + q) % r + s;
}
long[] best = new long[N];
int beforeHalf = 0;
long beforeHalfSum = 0;
long sum = 0;
return beforeHalfSum;
}


*********************************

#### Score: 0.43437


#### Java Tokens: next, nextint, upper, int 

public static int func_39e1a9be4764446598f02bc609026128(int y0, int x, int x0, double[] upper, Scanner in) { 
 int y = in.nextInt();
double k = 1.0 * (y - y0) / (x - x0);
for (int j = x0 + 1; j <= x; j++) {
    upper[j] = k * (j - x0) + y0;
}
x0 = x;
return y;
}


public static double[] func_8c9c7d9b4f9b4fffa51f72b93ac2690e(int y0, int w, int x0, int u, Scanner in) { 
 double[] upper = new double[w + 1];
x0 = in.nextInt();
y0 = in.nextInt();
upper[x0] = y0;
for (int i = 1; i < u; i++) {
    int x = in.nextInt();
    int y = in.nextInt();
    double k = 1.0 * (y - y0) / (x - x0);
    for (int j = x0 + 1; j <= x; j++) {
        upper[j] = k * (j - x0) + y0;
    }
    x0 = x;
    y0 = y;
}
return upper;
}


public static double func_29681fe80fda48dfb884ce18d7d3cb9a(int y0, int x, int x0, double[] upper, Scanner in) { 
 int y = in.nextInt();
double k = 1.0 * (y - y0) / (x - x0);
for (int j = x0 + 1; j <= x; j++) {
    upper[j] = k * (j - x0) + y0;
}
return k;
}


*********************************

#### Score: 0.43437


#### Java Tokens: size, last, upper, lower, lastx 

public static double func_052c8eccdefb487eaf36cb72797024c2(ArrayList<Point> lower, ArrayList<Point> upper) { 
 int u = upper.size();
int l = lower.size();
double lastX = 0;
return lastX;
}


public static ArrayList<Point> func_841846f506c64d949c3eead004f6ca88(ArrayList<Point> lower, ArrayList<Point> upper) { 
 int u = upper.size();
int l = lower.size();
double lastX = 0;
return lower;
}


public static int func_31fb1b921e4b400993fcc498fe66b711(ArrayList<Point> lower, ArrayList<Point> upper) { 
 int u = upper.size();
int l = lower.size();
double lastX = 0;
return u;
}


*********************************

#### Score: 0.43437


#### Java Tokens: next, nextint, int 

public static int func_49beec80c9b14d67aad9f4a1e836ec79(int y0, int x0, int x, Scanner in) { 
 int y = in.nextInt();
double k = 1.0 * (y - y0) / (x - x0);
return y;
}


public static int[] func_401517a72a97474c99008672c057858d(int l, Scanner sc) { 
 int u = sc.nextInt();
int g = sc.nextInt();
int[] xl = new int[l];
int[] yl = new int[l];
int[] xu = new int[u];
int[] yu = new int[u];
for (int i = 0; i < l; ++i) {
    xl[i] = sc.nextInt();
    yl[i] = sc.nextInt();
}
for (int i = 0; i < u; ++i) {
    xu[i] = sc.nextInt();
    yu[i] = sc.nextInt();
}
int[] xs = new int[l + u];
for (int i = 0; i < l; ++i) xs[i] = xl[i];
for (int i = 0; i < u; ++i) xs[l + i] = xu[i];
return yu;
}


public static int func_0979c9bc1328433fbee0ff8e8107b77c(Scanner in) { 
 int l = in.nextInt();
int u = in.nextInt();
return u;
}


*********************************

#### Score: 0.43437


#### Java Tokens:  

public static int[] func_a8cc3da20ae44db280f81c6771fe739c(int U, int L) { 
 int[][] x = new int[][] { new int[L], new int[U] }, y = new int[][] { new int[L], new int[U] };
int[] c = new int[] { L, U };
return c;
}


public static double func_5cb7357b94fc46e1afea6b52b8cc90b7(int W, double S, double[] down, double[] up) { 
 for (int i = 0; i < W; i++) {
    S += (up[i] + up[i + 1] - down[i] - down[i + 1]) / 2;
}
return S;
}


public static int func_d93da97531a74049b55cbbd993192896(int x0, int x1, double x) { 
 x = x1;
x0 = (int) x;
x1 = x0 + 1;
return x1;
}


*********************************

#### Score: 0.43437


#### Java Tokens: next, cur, curl, nextint, lowheight, upper, prev, lowerpoints, answers, totalarea, point, points, thisheight, total, min, low, array, lowx, curx, upheight, curu, height, linked, area, add, linkedlist, goal, last, upperpoints, err, double, lower, arraylist, list, int, target, curheight, prevx, math, upx, lastx 

public static int func_3efc2e8dc8704cff8d0a500d0ae47d2c(int l, Scanner in) { 
 // upper points
int u = in.nextInt();
int // guests
g = in.nextInt();
Point[] lower = new Point[l];
for (int i = 0; i < l; ++i) {
    lower[i] = new Point(in.nextInt(), in.nextInt());
}
Point[] upper = new Point[u];
for (int i = 0; i < u; ++i) {
    upper[i] = new Point(in.nextInt(), in.nextInt());
}
double totalArea = 0.0;
int curL = 1;
int curU = 1;
int lastX = 0;
double curHeight = 1.0 * upper[0].y - lower[0].y;
while (curL < l && curU < u) {
    int lowX = lower[curL].x;
    int upX = upper[curU].x;
    int curX = Math.min(lowX, upX);
    if (curX == lowX && curX == upX) {
        double thisHeight = upper[curU].y - lower[curL].y;
        totalArea += (1.0 * curHeight + thisHeight) / 2 * (curX - lastX);
        // System.out.println("dist: " + (curX-lastX));
        // System.out.println("newHeight: " + thisHeight);
        // System.out.println("oldHeight: " + curHeight);
        curHeight = thisHeight;
        lastX = curX;
        ++curL;
        ++curU;
    } else if (curX == lowX) {
        double upHeight = upper[curU - 1].y + (upper[curU].y - upper[curU - 1].y) * (1.0 * (curX - upper[curU - 1].x) / (upper[curU].x - upper[curU - 1].x));
        upHeight -= lower[curL].y;
        totalArea += ((1.0 * curHeight) + upHeight) / 2 * (curX - lastX);
        // System.out.println("dist: " + (curX-lastX));
        // System.out.println("newHeight: " + upHeight);
        // System.out.println("oldHeight: " + curHeight);
        curHeight = upHeight;
        lastX = curX;
        ++curL;
    } else {
        double lowHeight = lower[curL - 1].y + (lower[curL].y - lower[curL - 1].y) * (1.0 * (curX - lower[curL - 1].x) / (lower[curL].x - lower[curL - 1].x));
        // System.out.println("prevLowHeight: " + lowHeight);
        lowHeight = upper[curU].y - lowHeight;
        totalArea += ((1.0 * curHeight) + lowHeight) / 2 * (curX - lastX);
        // System.out.println("dist: " + (curX-lastX));
        // System.out.println("newHeight: " + lowHeight);
        // System.out.println("oldHeight: " + curHeight);
        curHeight = lowHeight;
        lastX = curX;
        ++curU;
    }
// System.out.println(totalArea);
}
// System.out.println(totalArea);
ArrayList<Point> upperPoints = new ArrayList<Point>();
for (Point p : upper) {
    upperPoints.add(p);
}
ArrayList<Point> lowerPoints = new ArrayList<Point>();
for (Point p : lower) {
    lowerPoints.add(p);
}
double prevX = 0.0;
double goal = totalArea / g;
double target = 0.0;
double ERR = 0.000001;
List<Double> answers = new LinkedList<Double>();
return u;
}


public static int func_cb760fad996c4462b70eebc290f8cc09(int u, int g, int l, Scanner in) { 
 Point[] lower = new Point[l];
for (int i = 0; i < l; ++i) {
    lower[i] = new Point(in.nextInt(), in.nextInt());
}
Point[] upper = new Point[u];
for (int i = 0; i < u; ++i) {
    upper[i] = new Point(in.nextInt(), in.nextInt());
}
double totalArea = 0.0;
int curL = 1;
int curU = 1;
int lastX = 0;
double curHeight = 1.0 * upper[0].y - lower[0].y;
while (curL < l && curU < u) {
    int lowX = lower[curL].x;
    int upX = upper[curU].x;
    int curX = Math.min(lowX, upX);
    if (curX == lowX && curX == upX) {
        double thisHeight = upper[curU].y - lower[curL].y;
        totalArea += (1.0 * curHeight + thisHeight) / 2 * (curX - lastX);
        // System.out.println("dist: " + (curX-lastX));
        // System.out.println("newHeight: " + thisHeight);
        // System.out.println("oldHeight: " + curHeight);
        curHeight = thisHeight;
        lastX = curX;
        ++curL;
        ++curU;
    } else if (curX == lowX) {
        double upHeight = upper[curU - 1].y + (upper[curU].y - upper[curU - 1].y) * (1.0 * (curX - upper[curU - 1].x) / (upper[curU].x - upper[curU - 1].x));
        upHeight -= lower[curL].y;
        totalArea += ((1.0 * curHeight) + upHeight) / 2 * (curX - lastX);
        // System.out.println("dist: " + (curX-lastX));
        // System.out.println("newHeight: " + upHeight);
        // System.out.println("oldHeight: " + curHeight);
        curHeight = upHeight;
        lastX = curX;
        ++curL;
    } else {
        double lowHeight = lower[curL - 1].y + (lower[curL].y - lower[curL - 1].y) * (1.0 * (curX - lower[curL - 1].x) / (lower[curL].x - lower[curL - 1].x));
        // System.out.println("prevLowHeight: " + lowHeight);
        lowHeight = upper[curU].y - lowHeight;
        totalArea += ((1.0 * curHeight) + lowHeight) / 2 * (curX - lastX);
        // System.out.println("dist: " + (curX-lastX));
        // System.out.println("newHeight: " + lowHeight);
        // System.out.println("oldHeight: " + curHeight);
        curHeight = lowHeight;
        lastX = curX;
        ++curU;
    }
// System.out.println(totalArea);
}
// System.out.println(totalArea);
ArrayList<Point> upperPoints = new ArrayList<Point>();
for (Point p : upper) {
    upperPoints.add(p);
}
ArrayList<Point> lowerPoints = new ArrayList<Point>();
for (Point p : lower) {
    lowerPoints.add(p);
}
double prevX = 0.0;
double goal = totalArea / g;
double target = 0.0;
double ERR = 0.000001;
List<Double> answers = new LinkedList<Double>();
return lastX;
}


public static double func_ea02d23095b14f51a0b5be80aeadec9c(int u, int g, int l, Scanner in) { 
 Point[] lower = new Point[l];
for (int i = 0; i < l; ++i) {
    lower[i] = new Point(in.nextInt(), in.nextInt());
}
Point[] upper = new Point[u];
for (int i = 0; i < u; ++i) {
    upper[i] = new Point(in.nextInt(), in.nextInt());
}
double totalArea = 0.0;
int curL = 1;
int curU = 1;
int lastX = 0;
double curHeight = 1.0 * upper[0].y - lower[0].y;
while (curL < l && curU < u) {
    int lowX = lower[curL].x;
    int upX = upper[curU].x;
    int curX = Math.min(lowX, upX);
    if (curX == lowX && curX == upX) {
        double thisHeight = upper[curU].y - lower[curL].y;
        totalArea += (1.0 * curHeight + thisHeight) / 2 * (curX - lastX);
        // System.out.println("dist: " + (curX-lastX));
        // System.out.println("newHeight: " + thisHeight);
        // System.out.println("oldHeight: " + curHeight);
        curHeight = thisHeight;
        lastX = curX;
        ++curL;
        ++curU;
    } else if (curX == lowX) {
        double upHeight = upper[curU - 1].y + (upper[curU].y - upper[curU - 1].y) * (1.0 * (curX - upper[curU - 1].x) / (upper[curU].x - upper[curU - 1].x));
        upHeight -= lower[curL].y;
        totalArea += ((1.0 * curHeight) + upHeight) / 2 * (curX - lastX);
        // System.out.println("dist: " + (curX-lastX));
        // System.out.println("newHeight: " + upHeight);
        // System.out.println("oldHeight: " + curHeight);
        curHeight = upHeight;
        lastX = curX;
        ++curL;
    } else {
        double lowHeight = lower[curL - 1].y + (lower[curL].y - lower[curL - 1].y) * (1.0 * (curX - lower[curL - 1].x) / (lower[curL].x - lower[curL - 1].x));
        // System.out.println("prevLowHeight: " + lowHeight);
        lowHeight = upper[curU].y - lowHeight;
        totalArea += ((1.0 * curHeight) + lowHeight) / 2 * (curX - lastX);
        // System.out.println("dist: " + (curX-lastX));
        // System.out.println("newHeight: " + lowHeight);
        // System.out.println("oldHeight: " + curHeight);
        curHeight = lowHeight;
        lastX = curX;
        ++curU;
    }
// System.out.println(totalArea);
}
// System.out.println(totalArea);
ArrayList<Point> upperPoints = new ArrayList<Point>();
for (Point p : upper) {
    upperPoints.add(p);
}
ArrayList<Point> lowerPoints = new ArrayList<Point>();
for (Point p : lower) {
    lowerPoints.add(p);
}
double prevX = 0.0;
double goal = totalArea / g;
double target = 0.0;
double ERR = 0.000001;
List<Double> answers = new LinkedList<Double>();
return prevX;
}

