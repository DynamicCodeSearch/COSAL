### Py Tokens: firstsum, last, min, max, minimax, float, lastsum, transistorsum, nextlastsum, currentmax, answer, nextfirstsum, transistors, first 

### Py functions

def func_d86d5512dac34288b1fa3549417dd0c4(N, first, transistors, transistorsum
    ):
    last = N
    firstsum = 0
    lastsum = 0
    minimax = transistorsum
    while last - first != 1:
        nextfirstsum = firstsum + transistors[first]
        nextlastsum = lastsum + transistors[last - 1]
        if nextfirstsum < nextlastsum:
            firstsum += transistors[first]
            first += 1
        else:
            last -= 1
            lastsum += transistors[last]
        currentmax = max([firstsum, lastsum, transistorsum - firstsum -
            lastsum])
        minimax = min(currentmax, minimax)
    answer = float(transistorsum - minimax) / float(transistorsum)
    return N

def func_cbbc6c3960b34076ac7139ddd1acc63f(N, transistors, transistorsum):
    first = 0
    last = N
    firstsum = 0
    lastsum = 0
    minimax = transistorsum
    while last - first != 1:
        nextfirstsum = firstsum + transistors[first]
        nextlastsum = lastsum + transistors[last - 1]
        if nextfirstsum < nextlastsum:
            firstsum += transistors[first]
            first += 1
        else:
            last -= 1
            lastsum += transistors[last]
        currentmax = max([firstsum, lastsum, transistorsum - firstsum -
            lastsum])
        minimax = min(currentmax, minimax)
    answer = float(transistorsum - minimax) / float(transistorsum)
    return N

*********************************

#### Score: 8.47877


#### Java Tokens: min, last, max, lastx 

public static double func_515a7808cc804f33b25845fc99140891(int lastX) { 
 double min = 0;
double max = lastX;
return min;
}


public static double func_c85420328fa74166a189b942ac0f172e(int lastX) { 
 double min = 0;
double max = lastX;
return max;
}


*********************************

#### Score: 8.03133


#### Java Tokens: suffixes, max, count, remaining, mos.search, min, binarysearch, answer, binary, arrays, math, first, at2, at1

public static long func_23e642bba7e14b24be3cea59aaf32b62(int count, long remaining, long first, long answer, long[] suffixes) { 
 int at = Arrays.binarySearch(suffixes, remaining >> 1);
if (at >= 0)
    answer = Math.min(answer, Math.max(first, Math.max(suffixes[at], remaining - suffixes[at])));
else {
    int at1 = -at - 1;
    int at2 = -at - 2;
    if (at1 >= 0 && at1 <= count)
        answer = Math.min(answer, Math.max(first, Math.max(suffixes[at1], remaining - suffixes[at1])));
    if (at2 >= 0 && at2 <= count)
        answer = Math.min(answer, Math.max(first, Math.max(suffixes[at2], remaining - suffixes[at2])));
}
return answer;
}


public static int func_a71aac85fbf040099633def0f8febf6f(int count, long remaining, long first, long answer, long[] suffixes) { 
 int at = Arrays.binarySearch(suffixes, remaining >> 1);
if (at >= 0)
    answer = Math.min(answer, Math.max(first, Math.max(suffixes[at], remaining - suffixes[at])));
else {
    int at1 = -at - 1;
    int at2 = -at - 2;
    if (at1 >= 0 && at1 <= count)
        answer = Math.min(answer, Math.max(first, Math.max(suffixes[at1], remaining - suffixes[at1])));
    if (at2 >= 0 && at2 <= count)
        answer = Math.min(answer, Math.max(first, Math.max(suffixes[at2], remaining - suffixes[at2])));
}
return at;
}


*********************************

#### Score: 7.74001


#### Java Tokens: suffixes, max, count, remaining, mos.search, min, answer, binarysearch, binary, arrays, math, partial, first, at2, at1

public static long func_2facb4ddbb07490abe54ee9b055dfaca(int count, long answer, long[] partial, long[] suffixes) { 
 for (int i = 0; i < count; i++) {
    long first = partial[i] - partial[0];
    if (first > answer)
        continue;
    long remaining = partial[count] - first;
    int at = Arrays.binarySearch(suffixes, remaining >> 1);
    if (at >= 0)
        answer = Math.min(answer, Math.max(first, Math.max(suffixes[at], remaining - suffixes[at])));
    else {
        int at1 = -at - 1;
        int at2 = -at - 2;
        if (at1 >= 0 && at1 <= count)
            answer = Math.min(answer, Math.max(first, Math.max(suffixes[at1], remaining - suffixes[at1])));
        if (at2 >= 0 && at2 <= count)
            answer = Math.min(answer, Math.max(first, Math.max(suffixes[at2], remaining - suffixes[at2])));
    }
}
return answer;
}


public static long func_783bb4edb9a24865892ff26cd719410c(int count, long[] partial, long[] suffixes) { 
 long answer = partial[count];
for (int i = 0; i < count; i++) {
    long first = partial[i] - partial[0];
    if (first > answer)
        continue;
    long remaining = partial[count] - first;
    int at = Arrays.binarySearch(suffixes, remaining >> 1);
    if (at >= 0)
        answer = Math.min(answer, Math.max(first, Math.max(suffixes[at], remaining - suffixes[at])));
    else {
        int at1 = -at - 1;
        int at2 = -at - 2;
        if (at1 >= 0 && at1 <= count)
            answer = Math.min(answer, Math.max(first, Math.max(suffixes[at1], remaining - suffixes[at1])));
        if (at2 >= 0 && at2 <= count)
            answer = Math.min(answer, Math.max(first, Math.max(suffixes[at2], remaining - suffixes[at2])));
    }
}
return answer;
}


public static long func_a886f67e0c9a4357bac0fc94c0128424(int count, long[] partial) { 
 long[] suffixes = new long[count + 1];
for (int i = 0; i <= count; i++) suffixes[i] = partial[count] - partial[count - i];
long answer = partial[count];
for (int i = 0; i < count; i++) {
    long first = partial[i] - partial[0];
    if (first > answer)
        continue;
    long remaining = partial[count] - first;
    int at = Arrays.binarySearch(suffixes, remaining >> 1);
    if (at >= 0)
        answer = Math.min(answer, Math.max(first, Math.max(suffixes[at], remaining - suffixes[at])));
    else {
        int at1 = -at - 1;
        int at2 = -at - 2;
        if (at1 >= 0 && at1 <= count)
            answer = Math.min(answer, Math.max(first, Math.max(suffixes[at1], remaining - suffixes[at1])));
        if (at2 >= 0 && at2 <= count)
            answer = Math.min(answer, Math.max(first, Math.max(suffixes[at2], remaining - suffixes[at2])));
    }
}
return answer;
}


*********************************

#### Score: 7.74001


#### Java Tokens: suffixes, max, count, remaining, mos.search, min, binarysearch, answer, binary, arrays, math, partial, first, at2, at1

public static int func_c329edeeeca14fa2b8fb1f82201e8c29(int count, long first, long answer, long[] partial, long[] suffixes) { 
 long remaining = partial[count] - first;
int at = Arrays.binarySearch(suffixes, remaining >> 1);
if (at >= 0)
    answer = Math.min(answer, Math.max(first, Math.max(suffixes[at], remaining - suffixes[at])));
else {
    int at1 = -at - 1;
    int at2 = -at - 2;
    if (at1 >= 0 && at1 <= count)
        answer = Math.min(answer, Math.max(first, Math.max(suffixes[at1], remaining - suffixes[at1])));
    if (at2 >= 0 && at2 <= count)
        answer = Math.min(answer, Math.max(first, Math.max(suffixes[at2], remaining - suffixes[at2])));
}
return at;
}


public static long func_8bf31460a6eb450d9e773d2f7140f996(int count, long first, long answer, long[] partial, long[] suffixes) { 
 long remaining = partial[count] - first;
int at = Arrays.binarySearch(suffixes, remaining >> 1);
if (at >= 0)
    answer = Math.min(answer, Math.max(first, Math.max(suffixes[at], remaining - suffixes[at])));
else {
    int at1 = -at - 1;
    int at2 = -at - 2;
    if (at1 >= 0 && at1 <= count)
        answer = Math.min(answer, Math.max(first, Math.max(suffixes[at1], remaining - suffixes[at1])));
    if (at2 >= 0 && at2 <= count)
        answer = Math.min(answer, Math.max(first, Math.max(suffixes[at2], remaining - suffixes[at2])));
}
return answer;
}


public static long func_e595ed43e0ae46fea80a29ad4f3a5c55(int count, long first, long answer, long[] partial, long[] suffixes) { 
 long remaining = partial[count] - first;
int at = Arrays.binarySearch(suffixes, remaining >> 1);
if (at >= 0)
    answer = Math.min(answer, Math.max(first, Math.max(suffixes[at], remaining - suffixes[at])));
else {
    int at1 = -at - 1;
    int at2 = -at - 2;
    if (at1 >= 0 && at1 <= count)
        answer = Math.min(answer, Math.max(first, Math.max(suffixes[at1], remaining - suffixes[at1])));
    if (at2 >= 0 && at2 <= count)
        answer = Math.min(answer, Math.max(first, Math.max(suffixes[at2], remaining - suffixes[at2])));
}
return remaining;
}


*********************************

#### Score: 7.53668


#### Java Tokens: min, last, known, max, lastknown, lastx 

public static double func_af08528ec2d9407d8c49c3cbf7c691a9(int lastX) { 
 double lastKnown = 0;
double min = 0;
double max = lastX;
return max;
}


public static double func_778578aa4780429e866005624993378e(int lastX) { 
 double lastKnown = 0;
double min = 0;
double max = lastX;
return lastKnown;
}


public static double func_d9ea7ed8ab5b4716ad8853ae0d8e8033(int lastX) { 
 double lastKnown = 0;
double min = 0;
double max = lastX;
return min;
}


*********************************

#### Score: 7.40147


#### Java Tokens: sum1, last, mid, sum, first 

public static boolean func_4f17acf744644da1a8f33c3f9f8a2022(int n, long mid, long[] a) { 
 int last = 0;
boolean ok = false;
long sum1 = 0;
int first = 0;
while (first != n && sum1 < mid) {
    sum1 += a[first];
    first++;
}
return ok;
}


public static int func_c1fce54b329a4dda803c6c6faea55fc5(int n, long mid, long[] a) { 
 int last = 0;
boolean ok = false;
long sum1 = 0;
int first = 0;
while (first != n && sum1 < mid) {
    sum1 += a[first];
    first++;
}
return first;
}


public static long func_0009b51825a54814baa916c27d03a974(int n, long mid, long[] a) { 
 int last = 0;
boolean ok = false;
long sum1 = 0;
int first = 0;
while (first != n && sum1 < mid) {
    sum1 += a[first];
    first++;
}
return sum1;
}


*********************************

#### Score: 7.21166


#### Java Tokens: sub, min, answer, max, subsum, best, sum, math, n-- 

public static long func_46d07cdc1d3b47cca724f82eda3730df(int N, long sum, long[] best, long[] A) { 
 long min = best[N - 1];
long subSum = 0;
for (int n = N - 1; n >= 1; n--) {
    subSum += A[n];
    min = Math.min(min, Math.max(subSum, best[n - 1]));
}
double answer = (sum - min) / (double) sum;
return subSum;
}


public static double func_2377f49406914e328597a05e642104f5(int N, long sum, long[] best, long[] A) { 
 long min = best[N - 1];
long subSum = 0;
for (int n = N - 1; n >= 1; n--) {
    subSum += A[n];
    min = Math.min(min, Math.max(subSum, best[n - 1]));
}
double answer = (sum - min) / (double) sum;
return answer;
}


public static long func_2aa1ff7540e34c8a9c69da057b4deee9(int N, long sum, long[] best, long[] A) { 
 long min = best[N - 1];
long subSum = 0;
for (int n = N - 1; n >= 1; n--) {
    subSum += A[n];
    min = Math.min(min, Math.max(subSum, best[n - 1]));
}
double answer = (sum - min) / (double) sum;
return min;
}


*********************************

#### Score: 7.21166


#### Java Tokens: sub, min, answer, max, subsum, sum, best, math, n-- 

public static double func_08bcd5b6ab6845fa8f67aae442da48b7(int N, long min, long sum, long[] best, long[] A) { 
 long subSum = 0;
for (int n = N - 1; n >= 1; n--) {
    subSum += A[n];
    min = Math.min(min, Math.max(subSum, best[n - 1]));
}
double answer = (sum - min) / (double) sum;
return answer;
}


public static long func_99dff45c18cd4546a25e6f2af492f72e(int N, long min, long sum, long[] best, long[] A) { 
 long subSum = 0;
for (int n = N - 1; n >= 1; n--) {
    subSum += A[n];
    min = Math.min(min, Math.max(subSum, best[n - 1]));
}
double answer = (sum - min) / (double) sum;
return min;
}


public static long func_f54dd5f559284bf38ab30e60bee0cebb(int N, long min, long sum, long[] best, long[] A) { 
 long subSum = 0;
for (int n = N - 1; n >= 1; n--) {
    subSum += A[n];
    min = Math.min(min, Math.max(subSum, best[n - 1]));
}
double answer = (sum - min) / (double) sum;
return subSum;
}


*********************************

#### Score: 7.14381


#### Java Tokens: min, last, known, max, poly, mid, lastknown 

public static double[] func_f7572b51b70f46b3b73c11d463d80de6(double lastKnown, double min, double max) { 
 double mid = (min + max) / 2;
double[] poly = new double[8];
poly[0] = mid;
poly[1] = 1001;
poly[2] = mid;
poly[3] = -1001;
poly[4] = lastKnown;
poly[5] = -1001;
return poly;
}


public static double[] func_9586cc54512441959154e810ecc424fb(double lastKnown, double min, double max) { 
 double mid = (min + max) / 2;
double[] poly = new double[8];
poly[0] = mid;
poly[1] = 1001;
poly[2] = mid;
poly[3] = -1001;
poly[4] = lastKnown;
poly[5] = -1001;
poly[6] = lastKnown;
poly[7] = 1001;
return poly;
}


public static double func_5a96df258cf04995a6b88481a854668f(double lastKnown, double min, double max) { 
 double mid = (min + max) / 2;
double[] poly = new double[8];
poly[0] = mid;
poly[1] = 1001;
poly[2] = mid;
poly[3] = -1001;
poly[4] = lastKnown;
poly[5] = -1001;
poly[6] = lastKnown;
return mid;
}


*********************************

#### Score: 7.01665


#### Java Tokens: println, min, answer, sum, case 

public static PrintWriter func_50dfd2d6a8df4289a047231a0991b3f7(int t, long min, long sum, PrintWriter out) { 
 double answer = (sum - min) / (double) sum;
out.println("Case #" + (t + 1) + ": " + answer);
return out;
}


public static double func_1f2ef31e98ae448597aef375506de172(int t, long min, long sum, PrintWriter out) { 
 double answer = (sum - min) / (double) sum;
out.println("Case #" + (t + 1) + ": " + answer);
return answer;
}

