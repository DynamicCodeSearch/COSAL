### Py Tokens: xrange, set, cle, sum, req, list, best, bag, ocle, crem, max, sorted, append 

### Py functions

def func_b82fbdba30a34af18242f7954f83bad5(b, cas, cx, ocle, x):
    cx = list(x)
    sx = sum(x)
    mx = x[-1]
    for i in xrange(1, 37):
        crem = x[i - 1] * i - sum(x[:i])
        if b >= crem:
            cx.append(x[i - 1] + (b - crem) / i)
    cx = cx + [(y - 1) for y in cx if y]
    cx = cx + [(y + 1) for y in cx]
    cx = sorted(set(cx))
    best = 0
    for v in cx:
        cle = sum(1 for w in x if w <= v)
        req = cle * v - sum(w for w in x if w <= v)
        if req <= b and cle:
            for j in xrange(cle):
                if req + j <= b:
                    bag = ((cle - j) * v - sum(x[:cle - j])) * 36 * ocle / (cle
                         - j) - (req + j) * ocle
                    best = max(best, bag)
    return y

def func_49e7d30d37d1424da937b6896d0eb9f4(b, cas, cx, ocle, x):
    cx = list(x)
    sx = sum(x)
    mx = x[-1]
    for i in xrange(1, 37):
        crem = x[i - 1] * i - sum(x[:i])
        if b >= crem:
            cx.append(x[i - 1] + (b - crem) / i)
    cx = cx + [(y - 1) for y in cx if y]
    cx = cx + [(y + 1) for y in cx]
    cx = sorted(set(cx))
    best = 0
    for v in cx:
        cle = sum(1 for w in x if w <= v)
        req = cle * v - sum(w for w in x if w <= v)
        if req <= b and cle:
            for j in xrange(cle):
                if req + j <= b:
                    bag = ((cle - j) * v - sum(x[:cle - j])) * 36 * ocle / (cle
                         - j) - (req + j) * ocle
                    best = max(best, bag)
    return x

def func_d56aae9069b247a9b18747fc550ca621(b, cas, cx, ocle, x):
    cx = list(x)
    sx = sum(x)
    mx = x[-1]
    for i in xrange(1, 37):
        crem = x[i - 1] * i - sum(x[:i])
        if b >= crem:
            cx.append(x[i - 1] + (b - crem) / i)
    cx = cx + [(y - 1) for y in cx if y]
    cx = cx + [(y + 1) for y in cx]
    cx = sorted(set(cx))
    best = 0
    for v in cx:
        cle = sum(1 for w in x if w <= v)
        req = cle * v - sum(w for w in x if w <= v)
        if req <= b and cle:
            for j in xrange(cle):
                if req + j <= b:
                    bag = ((cle - j) * v - sum(x[:cle - j])) * 36 * ocle / (cle
                         - j) - (req + j) * ocle
                    best = max(best, bag)
    return v

def func_e48a2e5b029847858c0f1aa8ddb80138(b, cas, cx, ocle, x):
    cx = list(x)
    sx = sum(x)
    mx = x[-1]
    for i in xrange(1, 37):
        crem = x[i - 1] * i - sum(x[:i])
        if b >= crem:
            cx.append(x[i - 1] + (b - crem) / i)
    cx = cx + [(y - 1) for y in cx if y]
    cx = cx + [(y + 1) for y in cx]
    cx = sorted(set(cx))
    best = 0
    for v in cx:
        cle = sum(1 for w in x if w <= v)
        req = cle * v - sum(w for w in x if w <= v)
        if req <= b and cle:
            for j in xrange(cle):
                if req + j <= b:
                    bag = ((cle - j) * v - sum(x[:cle - j])) * 36 * ocle / (cle
                         - j) - (req + j) * ocle
                    best = max(best, bag)
    return cx

def func_342df7bfee84489eae39649f78df9e62(b, cas, cx, ocle, x):
    cx = list(x)
    sx = sum(x)
    mx = x[-1]
    for i in xrange(1, 37):
        crem = x[i - 1] * i - sum(x[:i])
        if b >= crem:
            cx.append(x[i - 1] + (b - crem) / i)
    cx = cx + [(y - 1) for y in cx if y]
    cx = cx + [(y + 1) for y in cx]
    cx = sorted(set(cx))
    best = 0
    for v in cx:
        cle = sum(1 for w in x if w <= v)
        req = cle * v - sum(w for w in x if w <= v)
        if req <= b and cle:
            for j in xrange(cle):
                if req + j <= b:
                    bag = ((cle - j) * v - sum(x[:cle - j])) * 36 * ocle / (cle
                         - j) - (req + j) * ocle
                    best = max(best, bag)
    return j

*********************************

#### Score: 8.88784


#### Java Tokens: bound, sum, req 

public static double func_cb6075579afd41538cec7f7bef0d66a3(int g, int w, double sum, double[] bound) { 
 for (int i = 0; i < w; ++i) {
    sum += (bound[i] + bound[i + 1]) / 2.0;
}
double req = sum / g;
return req;
}


public static double func_1670fe700cc84ba39c57aa7bad72557f(int g, int w, double sum, double[] bound) { 
 for (int i = 0; i < w; ++i) {
    sum += (bound[i] + bound[i + 1]) / 2.0;
}
double req = sum / g;
return sum;
}


public static double func_7895eaba6f0d4d8c98b5a3c4480cdb8f(int g, int w, double[] bound) { 
 double sum = 0.0;
for (int i = 0; i < w; ++i) {
    sum += (bound[i] + bound[i + 1]) / 2.0;
}
double req = sum / g;
return sum;
}


*********************************

#### Score: 8.88784


#### Java Tokens: cur, sum, req 

public static int func_69624e4970c84dc5a86090b1b703b759(int g, double sum) { 
 double req = sum / g;
double cur = 0.0;
int p = 0;
return p;
}


public static double func_efdf9712f59949e7a9aa34d2a1a73ebe(int g, double sum) { 
 double req = sum / g;
double cur = 0.0;
int p = 0;
return cur;
}


public static double func_f63fa2c694d54a228cea145935406d4e(int g, double sum) { 
 double req = sum / g;
double cur = 0.0;
return req;
}


*********************************

#### Score: 8.49292


#### Java Tokens: add, set, max, length, tree, sum, best, value, treeset, long, max_value 

public static long func_01d93a72fc59451ea766af125d86cc20(int r, int p, int s, int q, int n) { 
 long[] a = new long[n];
long sum = 0;
for (int i = 0; i < a.length; i++) {
    a[i] = (1L * i * p + q) % r + s;
    sum += a[i];
}
TreeSet<Long> all = new TreeSet<Long>();
all.add(0L);
long x = 0;
long best = Long.MAX_VALUE;
return x;
}


public static long func_70d0c2c9710347a9bec5342a1e39ba0c(int r, int p, int s, int q, long[] a) { 
 long sum = 0;
for (int i = 0; i < a.length; i++) {
    a[i] = (1L * i * p + q) % r + s;
    sum += a[i];
}
TreeSet<Long> all = new TreeSet<Long>();
all.add(0L);
long x = 0;
long best = Long.MAX_VALUE;
return sum;
}


public static long func_b788c2fff10c482f91f66911d6a10f05(int r, int p, int s, int q, long[] a) { 
 long sum = 0;
for (int i = 0; i < a.length; i++) {
    a[i] = (1L * i * p + q) % r + s;
    sum += a[i];
}
TreeSet<Long> all = new TreeSet<Long>();
all.add(0L);
long x = 0;
long best = Long.MAX_VALUE;
return x;
}


*********************************

#### Score: 8.32718


#### Java Tokens: cur, bound, sum, req 

public static int func_2b59aef10a314794b2ec07b10370004e(int g, int w, double[] bound) { 
 double sum = 0.0;
for (int i = 0; i < w; ++i) {
    sum += (bound[i] + bound[i + 1]) / 2.0;
}
double req = sum / g;
double cur = 0.0;
int p = 0;
return p;
}


public static int func_948a6592050b4599b63f069ae3fa5a81(int g, int w, double sum, double[] bound) { 
 for (int i = 0; i < w; ++i) {
    sum += (bound[i] + bound[i + 1]) / 2.0;
}
double req = sum / g;
double cur = 0.0;
int p = 0;
return p;
}


public static double func_8f0b790409424170abb06310b7a43da9(int g, int w, double[] bound) { 
 double sum = 0.0;
for (int i = 0; i < w; ++i) {
    sum += (bound[i] + bound[i + 1]) / 2.0;
}
double req = sum / g;
double cur = 0.0;
int p = 0;
return cur;
}


*********************************

#### Score: 8.32718


#### Java Tokens: cur, sum, used, req 

public static int func_39b3fb805b124e9687f397147ad0a60b(int g, double sum) { 
 double req = sum / g;
double cur = 0.0;
int p = 0;
double used = 0.0;
return p;
}


public static double func_69c65bf356634fa6b743730fba85a5fa(int g, double sum) { 
 double req = sum / g;
double cur = 0.0;
int p = 0;
double used = 0.0;
return req;
}


public static double func_b8f0fa7b9ce5419ab48619a9f82856dd(int g, double sum) { 
 double req = sum / g;
double cur = 0.0;
int p = 0;
double used = 0.0;
return cur;
}


*********************************

#### Score: 7.97284


#### Java Tokens: add, sortedset, sorted, set, tree, integer, treeset 

public static SortedSet<Integer> func_908a1fb2d6ea4b70bac7de1f0210bf2e(int l, int[] xl) { 
 SortedSet<Integer> xs = new TreeSet<Integer>();
for (int i = 0; i < l; i++) {
    xs.add(xl[i]);
}
return xs;
}


public static SortedSet<Integer> func_33d30156f21a452c9e7e9783fd47a69d(int l, int u, int[] xu, int[] xl) { 
 SortedSet<Integer> xs = new TreeSet<Integer>();
for (int i = 0; i < l; i++) {
    xs.add(xl[i]);
}
for (int i = 0; i < u; i++) {
    xs.add(xu[i]);
}
return xs;
}


*********************************

#### Score: 7.83627


#### Java Tokens: cur, bound, sum, used, req 

public static double func_edf1d55aac094286a60c846ccfb61474(int g, int w, double sum, double[] bound) { 
 for (int i = 0; i < w; ++i) {
    sum += (bound[i] + bound[i + 1]) / 2.0;
}
double req = sum / g;
double cur = 0.0;
int p = 0;
double used = 0.0;
return used;
}


public static double func_b06cc8c2e7a1445ea8f79553fa392498(int g, int w, double[] bound) { 
 double sum = 0.0;
for (int i = 0; i < w; ++i) {
    sum += (bound[i] + bound[i + 1]) / 2.0;
}
double req = sum / g;
double cur = 0.0;
int p = 0;
double used = 0.0;
return req;
}


public static int func_f836832a9a5c4cfb9d86f292ace80bf1(int g, int w, double[] bound) { 
 double sum = 0.0;
for (int i = 0; i < w; ++i) {
    sum += (bound[i] + bound[i + 1]) / 2.0;
}
double req = sum / g;
double cur = 0.0;
int p = 0;
double used = 0.0;
return p;
}


*********************************

#### Score: 7.83627


#### Java Tokens: div, pos, bound, sum, req 

public static int func_ff71298ea8b84c648bd9e0ffd9667472(int l, int g, int u, int w, int[][] pos) { 
 double[] bound = new double[w + 1];
int px = pos[0][0];
int py = pos[0][1];
for (int i = 1; i < l; ++i) {
    int nx = pos[i][0];
    int ny = pos[i][1];
    double div = nx - px;
    for (int j = px + (i == 1 ? 0 : 1); j <= nx; ++j) {
        bound[j] -= (ny - py) / div * (j - px) + py;
    }
    px = nx;
    py = ny;
}
px = pos[l][0];
py = pos[l][1];
for (int i = l + 1; i < l + u; ++i) {
    int nx = pos[i][0];
    int ny = pos[i][1];
    double div = nx - px;
    for (int j = px + (i == l + 1 ? 0 : 1); j <= nx; ++j) {
        bound[j] += (ny - py) / div * (j - px) + py;
    }
    px = nx;
    py = ny;
}
double sum = 0.0;
for (int i = 0; i < w; ++i) {
    sum += (bound[i] + bound[i + 1]) / 2.0;
}
double req = sum / g;
return py;
}


public static double func_07bb6f347aca4dbcbb8da2ee63f72342(int l, int g, int u, int w, int[][] pos) { 
 double[] bound = new double[w + 1];
int px = pos[0][0];
int py = pos[0][1];
for (int i = 1; i < l; ++i) {
    int nx = pos[i][0];
    int ny = pos[i][1];
    double div = nx - px;
    for (int j = px + (i == 1 ? 0 : 1); j <= nx; ++j) {
        bound[j] -= (ny - py) / div * (j - px) + py;
    }
    px = nx;
    py = ny;
}
px = pos[l][0];
py = pos[l][1];
for (int i = l + 1; i < l + u; ++i) {
    int nx = pos[i][0];
    int ny = pos[i][1];
    double div = nx - px;
    for (int j = px + (i == l + 1 ? 0 : 1); j <= nx; ++j) {
        bound[j] += (ny - py) / div * (j - px) + py;
    }
    px = nx;
    py = ny;
}
double sum = 0.0;
for (int i = 0; i < w; ++i) {
    sum += (bound[i] + bound[i + 1]) / 2.0;
}
double req = sum / g;
return req;
}


public static double func_390c6c85f04f4d8cbebc585a632356a0(int l, int g, int u, int w, int[][] pos) { 
 double[] bound = new double[w + 1];
int px = pos[0][0];
int py = pos[0][1];
for (int i = 1; i < l; ++i) {
    int nx = pos[i][0];
    int ny = pos[i][1];
    double div = nx - px;
    for (int j = px + (i == 1 ? 0 : 1); j <= nx; ++j) {
        bound[j] -= (ny - py) / div * (j - px) + py;
    }
    px = nx;
    py = ny;
}
px = pos[l][0];
py = pos[l][1];
for (int i = l + 1; i < l + u; ++i) {
    int nx = pos[i][0];
    int ny = pos[i][1];
    double div = nx - px;
    for (int j = px + (i == l + 1 ? 0 : 1); j <= nx; ++j) {
        bound[j] += (ny - py) / div * (j - px) + py;
    }
    px = nx;
    py = ny;
}
double sum = 0.0;
for (int i = 0; i < w; ++i) {
    sum += (bound[i] + bound[i + 1]) / 2.0;
}
double req = sum / g;
return sum;
}


*********************************

#### Score: 7.57770


#### Java Tokens: add, sortedset, sorted, set, size, tree, integer, treeset 

public static SortedSet<Integer> func_4ce0a44eab0542dfa8546f1c61bacac4(int l, int u, int[] xu, int[] xl) { 
 SortedSet<Integer> xs = new TreeSet<Integer>();
for (int i = 0; i < l; i++) {
    xs.add(xl[i]);
}
for (int i = 0; i < u; i++) {
    xs.add(xu[i]);
}
int[] nx = new int[xs.size()];
return xs;
}


public static int[] func_1fe4188d08b24ee0990c1d1b63842dc2(int l, int u, int[] xu, int[] xl) { 
 SortedSet<Integer> xs = new TreeSet<Integer>();
for (int i = 0; i < l; i++) {
    xs.add(xl[i]);
}
for (int i = 0; i < u; i++) {
    xs.add(xu[i]);
}
int[] nx = new int[xs.size()];
return nx;
}


public static int[] func_900079f612634215823886119e9e27bb(int l, int u, int[] xu, int[] xl) { 
 SortedSet<Integer> xs = new TreeSet<Integer>();
for (int i = 0; i < l; i++) {
    xs.add(xl[i]);
}
for (int i = 0; i < u; i++) {
    xs.add(xu[i]);
}
int[] nx = new int[xs.size()];
{
    int i = 0;
    for (int xx : xs) {
        nx[i++] = xx;
    }
}
return nx;
}


*********************************

#### Score: 7.52889


#### Java Tokens: add, ceiling, set, max, tree, best, sum, long, min, math, floor, value, treeset, max_value 

public static long func_a72905d695394d9bb2cc529a06f77481(int n, long sum, long[] a) { 
 TreeSet<Long> all = new TreeSet<Long>();
all.add(0L);
long x = 0;
long best = Long.MAX_VALUE;
for (int i = 0; i < n; i++) {
    x += a[i];
    Long up = all.ceiling(x / 2 + 1);
    if (up != null) {
        long now = Math.max(up, Math.max(x - up, sum - x));
        best = Math.min(best, now);
    }
    Long down = all.floor(x / 2);
    if (down != null) {
        long now = Math.max(down, Math.max(x - down, sum - x));
        best = Math.min(best, now);
    }
    all.add(x);
}
return x;
}


public static long func_a7b8a6858f204306832053b2d8ceeb78(int n, long sum, long[] a) { 
 TreeSet<Long> all = new TreeSet<Long>();
all.add(0L);
long x = 0;
long best = Long.MAX_VALUE;
for (int i = 0; i < n; i++) {
    x += a[i];
    Long up = all.ceiling(x / 2 + 1);
    if (up != null) {
        long now = Math.max(up, Math.max(x - up, sum - x));
        best = Math.min(best, now);
    }
    Long down = all.floor(x / 2);
    if (down != null) {
        long now = Math.max(down, Math.max(x - down, sum - x));
        best = Math.min(best, now);
    }
    all.add(x);
}
return best;
}


public static TreeSet<Long> func_a84fba87bdac40148ebfb094f3f7cec5(int n, long sum, long[] a) { 
 TreeSet<Long> all = new TreeSet<Long>();
all.add(0L);
long x = 0;
long best = Long.MAX_VALUE;
for (int i = 0; i < n; i++) {
    x += a[i];
    Long up = all.ceiling(x / 2 + 1);
    if (up != null) {
        long now = Math.max(up, Math.max(x - up, sum - x));
        best = Math.min(best, now);
    }
    Long down = all.floor(x / 2);
    if (down != null) {
        long now = Math.max(down, Math.max(x - down, sum - x));
        best = Math.min(best, now);
    }
    all.add(x);
}
return all;
}

