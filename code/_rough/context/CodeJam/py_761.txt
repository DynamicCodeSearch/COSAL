### Py Tokens: alo, score, minsolveigscore, min, ahi, solveig 

### Py functions

def func_be08a663a4e442debd694c52aba5d26e(N, S, a_lo):
    a_lo = 0
    a_hi = N - 1
    min_solveig_score = S[N] + 1
    return a_lo

def func_fc3e6877d8794901b4e21077e2c2429c(N, S, a_lo):
    a_lo = 0
    a_hi = N - 1
    min_solveig_score = S[N] + 1
    return N

def func_b3f000dd0ab9462bb627b1561444236d(N, S, a_lo):
    a_lo = 0
    a_hi = N - 1
    min_solveig_score = S[N] + 1
    return min_solveig_score

def func_2490da06e47c461f87c83c2705d8fd72(N, S, a_lo):
    a_lo = 0
    a_hi = N - 1
    min_solveig_score = S[N] + 1
    return S

def func_a41b860a72ff4f94ba9077cdbae6f390(N, S, a_lo):
    a_lo = 0
    a_hi = N - 1
    min_solveig_score = S[N] + 1
    return a_hi

*********************************

#### Score: 5.66624


#### Java Tokens: solveig, middle, max, start, count, mid, right, long, rightcount, min, left, minsolveig, midcount, value, sums, max_value 

public static long func_60da854ca29b429d993100b9af9988f5(int start, int N, long[] sums) { 
 int left = start;
int right = N;
while (left <= right) {
    final int middle = (left + right) >> 1;
    final long midCount = sums[middle] - sums[start];
    final long rightCount = sums[N] - sums[middle];
    if (midCount < rightCount) {
        left = middle + 1;
    } else {
        right = middle - 1;
    }
}
long minSolveig = Long.MAX_VALUE;
return minSolveig;
}


public static int func_ff2a8435f7c64c469ddf393f3f2eb072(int start, int N, long[] sums) { 
 int left = start;
int right = N;
while (left <= right) {
    final int middle = (left + right) >> 1;
    final long midCount = sums[middle] - sums[start];
    final long rightCount = sums[N] - sums[middle];
    if (midCount < rightCount) {
        left = middle + 1;
    } else {
        right = middle - 1;
    }
}
long minSolveig = Long.MAX_VALUE;
return right;
}


public static int func_1f942c39ffb24de7956f9c067cf443c7(int start, int N, long[] sums) { 
 int left = start;
int right = N;
while (left <= right) {
    final int middle = (left + right) >> 1;
    final long midCount = sums[middle] - sums[start];
    final long rightCount = sums[N] - sums[middle];
    if (midCount < rightCount) {
        left = middle + 1;
    } else {
        right = middle - 1;
    }
}
long minSolveig = Long.MAX_VALUE;
return left;
}


*********************************

#### Score: 5.66624


#### Java Tokens: solveig, middle, max, count, start, mid, right, long, rightcount, min, left, minsolveig, midcount, value, sums, max_value 

public static int func_f8956746a63741d1b7aaa24c96877aef(int start, int N, int left, long[] sums) { 
 int right = N;
while (left <= right) {
    final int middle = (left + right) >> 1;
    final long midCount = sums[middle] - sums[start];
    final long rightCount = sums[N] - sums[middle];
    if (midCount < rightCount) {
        left = middle + 1;
    } else {
        right = middle - 1;
    }
}
long minSolveig = Long.MAX_VALUE;
return right;
}


public static int func_76c6fdf860c74edfbfcd099afbae5a10(int start, int N, int left, long[] sums) { 
 int right = N;
while (left <= right) {
    final int middle = (left + right) >> 1;
    final long midCount = sums[middle] - sums[start];
    final long rightCount = sums[N] - sums[middle];
    if (midCount < rightCount) {
        left = middle + 1;
    } else {
        right = middle - 1;
    }
}
long minSolveig = Long.MAX_VALUE;
return left;
}


public static int func_b1cb5569cafc49408e7b9f212690655b(int right, int start, int N, int left, long[] sums) { 
 while (left <= right) {
    final int middle = (left + right) >> 1;
    final long midCount = sums[middle] - sums[start];
    final long rightCount = sums[N] - sums[middle];
    if (midCount < rightCount) {
        left = middle + 1;
    } else {
        right = middle - 1;
    }
}
long minSolveig = Long.MAX_VALUE;
return left;
}


*********************************

#### Score: 5.47991


#### Java Tokens: leftcount, solveig, middle, max, count, start, mid, right, long, rightcount, min, left, minsolveig, midcount, value, sums, max_value 

public static long func_3765df1d9cde42d6a7e63d237e8a0aa6(int start, int N, long[] sums) { 
 final long leftCount = sums[start];
int left = start;
int right = N;
while (left <= right) {
    final int middle = (left + right) >> 1;
    final long midCount = sums[middle] - sums[start];
    final long rightCount = sums[N] - sums[middle];
    if (midCount < rightCount) {
        left = middle + 1;
    } else {
        right = middle - 1;
    }
}
long minSolveig = Long.MAX_VALUE;
return leftCount;
}


public static int func_43aaab78c4674843a2bc9c2eaca68b58(int start, int N, long[] sums) { 
 final long leftCount = sums[start];
int left = start;
int right = N;
while (left <= right) {
    final int middle = (left + right) >> 1;
    final long midCount = sums[middle] - sums[start];
    final long rightCount = sums[N] - sums[middle];
    if (midCount < rightCount) {
        left = middle + 1;
    } else {
        right = middle - 1;
    }
}
long minSolveig = Long.MAX_VALUE;
return left;
}


public static long func_379a893bd7584ba7a6760b00ea240ee2(int start, int N, long[] sums) { 
 final long leftCount = sums[start];
int left = start;
int right = N;
while (left <= right) {
    final int middle = (left + right) >> 1;
    final long midCount = sums[middle] - sums[start];
    final long rightCount = sums[N] - sums[middle];
    if (midCount < rightCount) {
        left = middle + 1;
    } else {
        right = middle - 1;
    }
}
long minSolveig = Long.MAX_VALUE;
return minSolveig;
}


*********************************

#### Score: 3.20588


#### Java Tokens: min 

public static long func_40c821d502a243948e6e225ebbc61cbd(int i, long[] v) { 
 long min = 0;
for (int j = 0; j < i; j++) {
    min += v[j];
}
return min;
}


*********************************

#### Score: 2.99395


#### Java Tokens: min, sum 

public static long[] func_44da2473d9f5488297c33072d535d623(int r, int s, int n, int p, int q) { 
 long sum = 0;
long[] a = new long[n];
for (int i = 0; i < n; i++) {
    a[i] = (((long) i * p + q) % r + s);
    sum += a[i];
}
long min = sum;
return a;
}


public static long func_5b4fc7d443574ce2817d7c2f940a29a1(int r, int s, int n, int p, int q) { 
 long sum = 0;
long[] a = new long[n];
for (int i = 0; i < n; i++) {
    a[i] = (((long) i * p + q) % r + s);
    sum += a[i];
}
long min = sum;
long si = 0, sj = 0;
return si;
}


public static long func_d5ae4614feaa4c499b25483858cf4acb(int r, int s, int n, int p, int q) { 
 long sum = 0;
long[] a = new long[n];
for (int i = 0; i < n; i++) {
    a[i] = (((long) i * p + q) % r + s);
    sum += a[i];
}
long min = sum;
long si = 0, sj = 0;
return min;
}


*********************************

#### Score: 2.99395


#### Java Tokens: sec, min 

public static long func_432caba609c146a18915b245ddf0eac9(long ms) { 
 long sec = ms / 1000;
ms = ms % 1000;
long min = sec / 60;
sec = sec % 60;
return ms;
}


public static long func_06ee3736c85f4998a2893959c44f0146(long sec, long ms) { 
 ms = ms % 1000;
long min = sec / 60;
sec = sec % 60;
return min;
}


public static long func_c2e408a71b7d437cbfb82f9ff38f3e2f(long sec) { 
 long min = sec / 60;
sec = sec % 60;
return sec;
}


*********************************

#### Score: 2.99395


#### Java Tokens: min, math 

public static double func_415312e3f6ee486daf98ad147c431644(int p2, int p1, int[] x2, int[] y1, int[] x1) { 
 // System.out.println (p1 + " " + p2 + " " + ca);
double nx = Math.min(x1[p1 + 1], x2[p2 + 1]);
double a1 = y1[p1 + 1] - y1[p1];
double b1 = x1[p1] - x1[p1 + 1];
return a1;
}


public static double func_b21e3034c891452bb715b71e2db83b76(int p2, int p1, int[] x2, int[] y1, int[] x1) { 
 // System.out.println (p1 + " " + p2 + " " + ca);
double nx = Math.min(x1[p1 + 1], x2[p2 + 1]);
double a1 = y1[p1 + 1] - y1[p1];
double b1 = x1[p1] - x1[p1 + 1];
return nx;
}


public static double func_eaaabaef89164431b4e1e6241ead5435(int p2, int p1, int[] x2, int[] y1, int[] x1) { 
 // System.out.println (p1 + " " + p2 + " " + ca);
double nx = Math.min(x1[p1 + 1], x2[p2 + 1]);
double a1 = y1[p1 + 1] - y1[p1];
double b1 = x1[p1] - x1[p1 + 1];
double c1 = a1 * x1[p1] + b1 * y1[p1];
return b1;
}


*********************************

#### Score: 2.99395


#### Java Tokens: bet, min 

public static long func_89576d1bee414a2bb97c873c687a8b65(int i, long[] v) { 
 long bet = i * (v[i] - 1);
long min = 0;
for (int j = 0; j < i; j++) {
    min += v[j];
}
return min;
}


public static long func_6297b6de147c4fa08dcd5994fa0221ce(int i, long[] v) { 
 long bet = i * (v[i] - 1);
long min = 0;
return bet;
}


public static long func_a487c2f03dae4afab5b57f1c4b9ede88(int i, long[] v) { 
 long bet = i * (v[i] - 1);
long min = 0;
for (int j = 0; j < i; j++) {
    min += v[j];
}
return bet;
}


*********************************

#### Score: 2.99395


#### Java Tokens: min, max 

public static int func_8c98f5c7c4d7479ea4c39e4462691c43(int i, int n) { 
 int min = i;
int max = n - 1;
return min;
}


public static int func_510cfd37c6274b7386ccf8e8bef4839d(int n, int h) { 
 int min = h;
int max = n - 1;
return min;
}


public static double func_d120afe8bfa04104a16940e1840c70c6(int W) { 
 double min = 0.0;
double max = W + 0.00000001337;
return max;
}


*********************************

#### Score: 2.81214


#### Java Tokens: xnew, min, math 

public static double func_8a9f23b2fa944c2387d439893c24faec(int il, int iu, double[][] u, double[][] l) { 
 double xnew = Math.min(l[il + 1][0], u[iu + 1][0]);
double kl = (l[il + 1][1] - l[il][1]) / (l[il + 1][0] - l[il][0]);
double bl = l[il][1] - (kl * l[il][0]);
double ku = (u[iu + 1][1] - u[iu][1]) / (u[iu + 1][0] - u[iu][0]);
double bu = u[iu][1] - (ku * u[iu][0]);
return bl;
}


public static double func_ddd18861415747c89c80f19763935e82(int il, int iu, double[][] u, double[][] l) { 
 double xnew = Math.min(l[il + 1][0], u[iu + 1][0]);
double kl = (l[il + 1][1] - l[il][1]) / (l[il + 1][0] - l[il][0]);
double bl = l[il][1] - (kl * l[il][0]);
double ku = (u[iu + 1][1] - u[iu][1]) / (u[iu + 1][0] - u[iu][0]);
double bu = u[iu][1] - (ku * u[iu][0]);
return xnew;
}


public static double func_294960110cdc4e15ae52c060d78c12aa(int il, int iu, double[][] u, double[][] l) { 
 double xnew = Math.min(l[il + 1][0], u[iu + 1][0]);
double kl = (l[il + 1][1] - l[il][1]) / (l[il + 1][0] - l[il][0]);
return kl;
}

