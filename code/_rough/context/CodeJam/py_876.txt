### Py Tokens: sort, max, right, vsota, amid, range, rem, cum, best, left 

### Py functions

def func_f0b4b3d040174b7884581774338f3050(cum, n, p, s, vsota):
    best = 0.0
    for b in range(n - 1, -1, -1):
        rem = vsota - (cum[n] - cum[b])
        al = 0
        ar = b
        while al + 1 < ar:
            amid = (al + ar) // 2
            left = cum[amid]
            right = cum[b] - cum[amid]
            if left > right:
                ar = amid
            else:
                al = amid
        s = [cum[al], cum[b] - cum[al], cum[n] - cum[b]]
        s.sort()
        p = (s[0] + s[1]) / vsota
        best = max(best, p)
        s = [cum[ar], cum[b] - cum[ar], cum[n] - cum[b]]
        s.sort()
        p = (s[0] + s[1]) / vsota
        best = max(best, p)
    return rem

def func_7645abb932944a7b83a4850e3fdabfaa(cum, n, p, s, vsota):
    best = 0.0
    for b in range(n - 1, -1, -1):
        rem = vsota - (cum[n] - cum[b])
        al = 0
        ar = b
        while al + 1 < ar:
            amid = (al + ar) // 2
            left = cum[amid]
            right = cum[b] - cum[amid]
            if left > right:
                ar = amid
            else:
                al = amid
        s = [cum[al], cum[b] - cum[al], cum[n] - cum[b]]
        s.sort()
        p = (s[0] + s[1]) / vsota
        best = max(best, p)
        s = [cum[ar], cum[b] - cum[ar], cum[n] - cum[b]]
        s.sort()
        p = (s[0] + s[1]) / vsota
        best = max(best, p)
    return best

def func_465e41989098464dabeb03a7b12e6877(cum, n, p, s, vsota):
    best = 0.0
    for b in range(n - 1, -1, -1):
        rem = vsota - (cum[n] - cum[b])
        al = 0
        ar = b
        while al + 1 < ar:
            amid = (al + ar) // 2
            left = cum[amid]
            right = cum[b] - cum[amid]
            if left > right:
                ar = amid
            else:
                al = amid
        s = [cum[al], cum[b] - cum[al], cum[n] - cum[b]]
        s.sort()
        p = (s[0] + s[1]) / vsota
        best = max(best, p)
        s = [cum[ar], cum[b] - cum[ar], cum[n] - cum[b]]
        s.sort()
        p = (s[0] + s[1]) / vsota
        best = max(best, p)
    return best

def func_f0999732a5584e6fabbf92392ae5dff5(cum, n, p, s, vsota):
    best = 0.0
    for b in range(n - 1, -1, -1):
        rem = vsota - (cum[n] - cum[b])
        al = 0
        ar = b
        while al + 1 < ar:
            amid = (al + ar) // 2
            left = cum[amid]
            right = cum[b] - cum[amid]
            if left > right:
                ar = amid
            else:
                al = amid
        s = [cum[al], cum[b] - cum[al], cum[n] - cum[b]]
        s.sort()
        p = (s[0] + s[1]) / vsota
        best = max(best, p)
        s = [cum[ar], cum[b] - cum[ar], cum[n] - cum[b]]
        s.sort()
        p = (s[0] + s[1]) / vsota
        best = max(best, p)
    return left

def func_ff30ce0044254f9aa37e6b171c1d0848(cum, n, p, s, vsota):
    best = 0.0
    for b in range(n - 1, -1, -1):
        rem = vsota - (cum[n] - cum[b])
        al = 0
        ar = b
        while al + 1 < ar:
            amid = (al + ar) // 2
            left = cum[amid]
            right = cum[b] - cum[amid]
            if left > right:
                ar = amid
            else:
                al = amid
        s = [cum[al], cum[b] - cum[al], cum[n] - cum[b]]
        s.sort()
        p = (s[0] + s[1]) / vsota
        best = max(best, p)
        s = [cum[ar], cum[b] - cum[ar], cum[n] - cum[b]]
        s.sort()
        p = (s[0] + s[1]) / vsota
        best = max(best, p)
    return rem

*********************************

#### Score: 9.57146


#### Java Tokens: min, left, max, right 

public static int func_26ea343e785e42efb3753036a0b2a5ba(int max, int min) { 
 int left = (2 * min + max) / 3;
int right = (2 * max + min) / 3;
return right;
}


public static int func_947a3ae64cb84a41b3092ef70726de88(int max, int min) { 
 int left = (2 * min + max) / 3;
int right = (2 * max + min) / 3;
return left;
}


*********************************

#### Score: 9.26245


#### Java Tokens: area, cur, left, remarea, rem, curleft 

public static double func_39e93559773949fab9c9976333441ffd(int uk, double curLeft, double remArea) { 
 curLeft -= remArea;
uk++;
return curLeft;
}


*********************************

#### Score: 9.21588


#### Java Tokens: money, left, need, max, ans, arrays, sort, right, math, prof 

public static double func_334782fec40c425aa170dfacff764a66(int m, long money, long[] a) { 
 Arrays.sort(a);
double ans = 0;
for (int i = 1; i <= m; i++) {
    long now = a[i - 1];
    long eq = 0;
    for (int j = 0; j < i; j++) {
        eq += now - a[j];
    }
    int same = 0;
    for (int j = i; j < m; j++) {
        if (a[j] == now) {
            same++;
        }
    }
    if (eq + same > money) {
        break;
    }
    long left = 0;
    long right = money + 1;
    while (left + 1 < right) {
        long up = (left + right) / 2;
        long need = eq + i * up;
        for (int j = i; j < m; j++) {
            need += Math.max((now + up + 1) - a[j], 0);
            if (need > money) {
                break;
            }
        }
        if (need > money) {
            right = up;
        } else {
            left = up;
        }
    }
    long up = left;
    double prof = -eq - up * i;
    for (int j = i; j < m; j++) {
        prof -= Math.max((now + up + 1) - a[j], 0);
    }
    for (int j = 0; j < i; j++) {
        prof += (now + up - a[j]) * 36.0 / i;
    }
    ans = Math.max(ans, prof);
}
return ans;
}


*********************************

#### Score: 8.65615


#### Java Tokens: left, right 

public static double func_f328a2bad7564210944accc2c7503d97(double w) { 
 double left = 0;
double right = w;
return left;
}


public static long func_c4c9d8488eac4e89a49b17b875ec73ca(long right, long left) { 
 long m1 = (left * 2 + right) / 3;
long m2 = (left + right * 2) / 3;
return m1;
}


public static long func_797121d40d924bb2a5d55be16bde3934(long right, long left) { 
 long m1 = (left * 2 + right) / 3;
long m2 = (left + right * 2) / 3;
return m2;
}


*********************************

#### Score: 8.50141


#### Java Tokens: take, left, max, center, right, math 

public static long func_1a176fd327f44bee8d050710b5f1476d(int n, long left, long max, long center, long[] S) { 
 long right = S[n] - left - center;
long take = S[n] - Math.max(center, Math.max(left, right));
max = Math.max(max, take);
return right;
}


public static long func_332f55a1dc534bef85ef7c3481d5a74e(int n, long left, long center, long[] S) { 
 long right = S[n] - left - center;
long take = S[n] - Math.max(center, Math.max(left, right));
return right;
}


public static long func_33cbe8508f0942df9d9b56ecfb6abbaf(int n, long left, long max, long center, long[] S) { 
 long right = S[n] - left - center;
long take = S[n] - Math.max(center, Math.max(left, right));
max = Math.max(max, take);
return take;
}


*********************************

#### Score: 8.50141


#### Java Tokens: leftcount, min, max, left, count, right 

public static long func_4314bd12473d4d378ec0241c32a86aa0(int i, int left, int max, int min) { 
 int right = (2 * max + min) / 3;
long leftCount = A.count(i, left);
return leftCount;
}


public static int func_1868896cd94d4e33910e57d3a7e0231b(int i, int left, int max, int min) { 
 int right = (2 * max + min) / 3;
long leftCount = A.count(i, left);
return right;
}


*********************************

#### Score: 8.50141


#### Java Tokens: leftcount, min, left, max, count, right 

public static long func_721ee9104d894bb198bf48abdb9c2936(int i, int max, int min) { 
 int left = (2 * min + max) / 3;
int right = (2 * max + min) / 3;
long leftCount = A.count(i, left);
return leftCount;
}


public static int func_1a051775fe4c4f6da8e486c9a1f9de92(int i, int max, int min) { 
 int left = (2 * min + max) / 3;
int right = (2 * max + min) / 3;
long leftCount = A.count(i, left);
return left;
}


public static int func_3842023784024eab962b977c7af4c371(int i, int max, int min) { 
 int left = (2 * min + max) / 3;
int right = (2 * max + min) / 3;
long leftCount = A.count(i, left);
return right;
}


*********************************

#### Score: 8.50141


#### Java Tokens: min, max, left, lowx, math, right 

public static double func_39a43ed698374621839b5b4ee02e3b0c(int l, double right, double left) { 
 double ax = Math.max(A.lowx[l], left);
double bx = Math.min(A.lowx[l + 1], right);
return bx;
}


public static double func_a23169e98a134297ba3469550e340fbb(int l, double right, double left) { 
 double ax = Math.max(A.lowx[l], left);
double bx = Math.min(A.lowx[l + 1], right);
return ax;
}


*********************************

#### Score: 8.50141


#### Java Tokens: min, max, left, math, right, highx 

public static double func_27387ed4fd1849fc9908822aeebed822(int l, double right, double left) { 
 double ax = Math.max(A.highx[l], left);
double bx = Math.min(A.highx[l + 1], right);
return ax;
}


public static double func_1d80eefaf47d4d389adb67becb58051f(int l, double right, double left) { 
 double ax = Math.max(A.highx[l], left);
double bx = Math.min(A.highx[l + 1], right);
return bx;
}


*********************************

#### Score: 8.45484


#### Java Tokens: println, system, money, left, need, max, ans, arrays, sort, right, math, prof 

public static double func_7536eea71da1462b8dabcd446ecfaf45(int m, long money, long[] a) { 
 Arrays.sort(a);
double ans = 0;
for (int i = 1; i <= m; i++) {
    long now = a[i - 1];
    long eq = 0;
    for (int j = 0; j < i; j++) {
        eq += now - a[j];
    }
    int same = 0;
    for (int j = i; j < m; j++) {
        if (a[j] == now) {
            same++;
        }
    }
    if (eq + same > money) {
        break;
    }
    long left = 0;
    long right = money + 1;
    while (left + 1 < right) {
        long up = (left + right) / 2;
        long need = eq + i * up;
        for (int j = i; j < m; j++) {
            need += Math.max((now + up + 1) - a[j], 0);
            if (need > money) {
                break;
            }
        }
        if (need > money) {
            right = up;
        } else {
            left = up;
        }
    }
    long up = left;
    double prof = -eq - up * i;
    for (int j = i; j < m; j++) {
        prof -= Math.max((now + up + 1) - a[j], 0);
    }
    for (int j = 0; j < i; j++) {
        prof += (now + up - a[j]) * 36.0 / i;
    }
    ans = Math.max(ans, prof);
}
System.out.println(ans);
A.out.println(ans);
return ans;
}


public static double func_66a835f036704ffbb2032b11bb168df3(int m, long money, long[] a) { 
 Arrays.sort(a);
double ans = 0;
for (int i = 1; i <= m; i++) {
    long now = a[i - 1];
    long eq = 0;
    for (int j = 0; j < i; j++) {
        eq += now - a[j];
    }
    int same = 0;
    for (int j = i; j < m; j++) {
        if (a[j] == now) {
            same++;
        }
    }
    if (eq + same > money) {
        break;
    }
    long left = 0;
    long right = money + 1;
    while (left + 1 < right) {
        long up = (left + right) / 2;
        long need = eq + i * up;
        for (int j = i; j < m; j++) {
            need += Math.max((now + up + 1) - a[j], 0);
            if (need > money) {
                break;
            }
        }
        if (need > money) {
            right = up;
        } else {
            left = up;
        }
    }
    long up = left;
    double prof = -eq - up * i;
    for (int j = i; j < m; j++) {
        prof -= Math.max((now + up + 1) - a[j], 0);
    }
    for (int j = 0; j < i; j++) {
        prof += (now + up - a[j]) * 36.0 / i;
    }
    ans = Math.max(ans, prof);
}
System.out.println(ans);
return ans;
}

