### Py Tokens: minvyska, vyska, najmensich, treba, range, vyhra 

### Py functions

def func_f3720abc322949a599470001fe641c62(X, i, minvyska, najmensich):
    vyska = minvyska
    treba = 0
    vyhra = 0
    for i in range(najmensich):
        treba += vyska - X[i]
        vyhra += vyska - X[i]
    for i in range(najmensich, 37):
        if X[i] <= vyska:
            treba += vyska + 1 - X[i]
    return minvyska

def func_380cd3cef50a41f88218a1b448645798(X, i, minvyska, najmensich):
    vyska = minvyska
    treba = 0
    vyhra = 0
    for i in range(najmensich):
        treba += vyska - X[i]
        vyhra += vyska - X[i]
    return treba

def func_19472d95317944d3bde670fb7255c3ae(X, i, minvyska, najmensich):
    vyska = minvyska
    treba = 0
    vyhra = 0
    for i in range(najmensich):
        treba += vyska - X[i]
        vyhra += vyska - X[i]
    for i in range(najmensich, 37):
        if X[i] <= vyska:
            treba += vyska + 1 - X[i]
    return X

def func_06a66c46350e43d6b40f8b8a7462f91e(X, i, minvyska, najmensich):
    vyska = minvyska
    treba = 0
    vyhra = 0
    for i in range(najmensich):
        treba += vyska - X[i]
        vyhra += vyska - X[i]
    return X

def func_fe791290bced4cb98dfae8d093a1684b(X, i, minvyska, najmensich):
    vyska = minvyska
    treba = 0
    vyhra = 0
    for i in range(najmensich):
        treba += vyska - X[i]
        vyhra += vyska - X[i]
    for i in range(najmensich, 37):
        if X[i] <= vyska:
            treba += vyska + 1 - X[i]
    pp = 1.0 / najmensich
    return vyhra

*********************************

#### Score: 0.43437


#### Java Tokens: next, area, println, irregularcakes, part, irregular, cakes 

public static double func_9b932effc3ed4da4b1b5fcd52925f5d3(int W, double part) { 
 double lb = 0;
double ub = W;
while (ub - lb > 0.000000001) {
    double next = (ub + lb) / 2;
    double area = IrregularCakes.area(next);
    if (area > part) {
        ub = next;
    } else {
        lb = next;
    }
}
IrregularCakes.out.println(lb);
return ub;
}


public static double func_9e53938a4375458c87dac84506b255ef(double ub, double part, double lb) { 
 while (ub - lb > 0.000000001) {
    double next = (ub + lb) / 2;
    double area = IrregularCakes.area(next);
    if (area > part) {
        ub = next;
    } else {
        lb = next;
    }
}
IrregularCakes.out.println(lb);
return lb;
}


public static double func_d734fc60f73449708bc872e3e25b145a(double ub, double part, double lb) { 
 while (ub - lb > 0.000000001) {
    double next = (ub + lb) / 2;
    double area = IrregularCakes.area(next);
    if (area > part) {
        ub = next;
    } else {
        lb = next;
    }
}
IrregularCakes.out.println(lb);
return ub;
}


*********************************

#### Score: 0.43437


#### Java Tokens: next, beforehalf, half, nextint, best, sum, int, beforehalfsum 

public static long func_eea237da523c48979f2af872bd17374e(int N, long q, long p, long r, Scanner in) { 
 long s = in.nextInt();
long[] A = new long[N];
for (int n = 0; n < N; n++) {
    A[n] = (n * p + q) % r + s;
}
long[] best = new long[N];
int beforeHalf = 0;
long beforeHalfSum = 0;
return s;
}


public static int func_8ea3224b72af4442a1bf756ef8ada3b2(int N, long q, long p, Scanner in) { 
 long r = in.nextInt();
long s = in.nextInt();
long[] A = new long[N];
for (int n = 0; n < N; n++) {
    A[n] = (n * p + q) % r + s;
}
long[] best = new long[N];
int beforeHalf = 0;
long beforeHalfSum = 0;
return beforeHalf;
}


public static long func_cfa345a37df74b58a2ad0f406318ab15(int N, Scanner in) { 
 long p = in.nextInt();
long q = in.nextInt();
long r = in.nextInt();
long s = in.nextInt();
long[] A = new long[N];
for (int n = 0; n < N; n++) {
    A[n] = (n * p + q) % r + s;
}
long[] best = new long[N];
int beforeHalf = 0;
long beforeHalfSum = 0;
long sum = 0;
return beforeHalfSum;
}


*********************************

#### Score: 0.43437


#### Java Tokens: next, nextint, upper, int 

public static int func_39e1a9be4764446598f02bc609026128(int y0, int x, int x0, double[] upper, Scanner in) { 
 int y = in.nextInt();
double k = 1.0 * (y - y0) / (x - x0);
for (int j = x0 + 1; j <= x; j++) {
    upper[j] = k * (j - x0) + y0;
}
x0 = x;
return y;
}


public static double[] func_8c9c7d9b4f9b4fffa51f72b93ac2690e(int y0, int w, int x0, int u, Scanner in) { 
 double[] upper = new double[w + 1];
x0 = in.nextInt();
y0 = in.nextInt();
upper[x0] = y0;
for (int i = 1; i < u; i++) {
    int x = in.nextInt();
    int y = in.nextInt();
    double k = 1.0 * (y - y0) / (x - x0);
    for (int j = x0 + 1; j <= x; j++) {
        upper[j] = k * (j - x0) + y0;
    }
    x0 = x;
    y0 = y;
}
return upper;
}


public static double func_29681fe80fda48dfb884ce18d7d3cb9a(int y0, int x, int x0, double[] upper, Scanner in) { 
 int y = in.nextInt();
double k = 1.0 * (y - y0) / (x - x0);
for (int j = x0 + 1; j <= x; j++) {
    upper[j] = k * (j - x0) + y0;
}
return k;
}


*********************************

#### Score: 0.43437


#### Java Tokens: size, last, upper, lower, lastx 

public static double func_052c8eccdefb487eaf36cb72797024c2(ArrayList<Point> lower, ArrayList<Point> upper) { 
 int u = upper.size();
int l = lower.size();
double lastX = 0;
return lastX;
}


public static ArrayList<Point> func_841846f506c64d949c3eead004f6ca88(ArrayList<Point> lower, ArrayList<Point> upper) { 
 int u = upper.size();
int l = lower.size();
double lastX = 0;
return lower;
}


public static int func_31fb1b921e4b400993fcc498fe66b711(ArrayList<Point> lower, ArrayList<Point> upper) { 
 int u = upper.size();
int l = lower.size();
double lastX = 0;
return u;
}


*********************************

#### Score: 0.43437


#### Java Tokens: next, nextint, int 

public static int func_49beec80c9b14d67aad9f4a1e836ec79(int y0, int x0, int x, Scanner in) { 
 int y = in.nextInt();
double k = 1.0 * (y - y0) / (x - x0);
return y;
}


public static int[] func_401517a72a97474c99008672c057858d(int l, Scanner sc) { 
 int u = sc.nextInt();
int g = sc.nextInt();
int[] xl = new int[l];
int[] yl = new int[l];
int[] xu = new int[u];
int[] yu = new int[u];
for (int i = 0; i < l; ++i) {
    xl[i] = sc.nextInt();
    yl[i] = sc.nextInt();
}
for (int i = 0; i < u; ++i) {
    xu[i] = sc.nextInt();
    yu[i] = sc.nextInt();
}
int[] xs = new int[l + u];
for (int i = 0; i < l; ++i) xs[i] = xl[i];
for (int i = 0; i < u; ++i) xs[l + i] = xu[i];
return yu;
}


public static int func_0979c9bc1328433fbee0ff8e8107b77c(Scanner in) { 
 int l = in.nextInt();
int u = in.nextInt();
return u;
}


*********************************

#### Score: 0.43437


#### Java Tokens:  

public static int[] func_a8cc3da20ae44db280f81c6771fe739c(int U, int L) { 
 int[][] x = new int[][] { new int[L], new int[U] }, y = new int[][] { new int[L], new int[U] };
int[] c = new int[] { L, U };
return c;
}


public static double func_5cb7357b94fc46e1afea6b52b8cc90b7(int W, double S, double[] down, double[] up) { 
 for (int i = 0; i < W; i++) {
    S += (up[i] + up[i + 1] - down[i] - down[i + 1]) / 2;
}
return S;
}


public static int func_d93da97531a74049b55cbbd993192896(int x0, int x1, double x) { 
 x = x1;
x0 = (int) x;
x1 = x0 + 1;
return x1;
}


*********************************

#### Score: 0.43437


#### Java Tokens: next, cur, curl, nextint, lowheight, upper, prev, lowerpoints, answers, totalarea, point, points, thisheight, total, min, low, array, lowx, curx, upheight, curu, height, linked, area, add, linkedlist, goal, last, upperpoints, err, double, lower, arraylist, list, int, target, curheight, prevx, math, upx, lastx 

public static int func_3efc2e8dc8704cff8d0a500d0ae47d2c(int l, Scanner in) { 
 // upper points
int u = in.nextInt();
int // guests
g = in.nextInt();
Point[] lower = new Point[l];
for (int i = 0; i < l; ++i) {
    lower[i] = new Point(in.nextInt(), in.nextInt());
}
Point[] upper = new Point[u];
for (int i = 0; i < u; ++i) {
    upper[i] = new Point(in.nextInt(), in.nextInt());
}
double totalArea = 0.0;
int curL = 1;
int curU = 1;
int lastX = 0;
double curHeight = 1.0 * upper[0].y - lower[0].y;
while (curL < l && curU < u) {
    int lowX = lower[curL].x;
    int upX = upper[curU].x;
    int curX = Math.min(lowX, upX);
    if (curX == lowX && curX == upX) {
        double thisHeight = upper[curU].y - lower[curL].y;
        totalArea += (1.0 * curHeight + thisHeight) / 2 * (curX - lastX);
        // System.out.println("dist: " + (curX-lastX));
        // System.out.println("newHeight: " + thisHeight);
        // System.out.println("oldHeight: " + curHeight);
        curHeight = thisHeight;
        lastX = curX;
        ++curL;
        ++curU;
    } else if (curX == lowX) {
        double upHeight = upper[curU - 1].y + (upper[curU].y - upper[curU - 1].y) * (1.0 * (curX - upper[curU - 1].x) / (upper[curU].x - upper[curU - 1].x));
        upHeight -= lower[curL].y;
        totalArea += ((1.0 * curHeight) + upHeight) / 2 * (curX - lastX);
        // System.out.println("dist: " + (curX-lastX));
        // System.out.println("newHeight: " + upHeight);
        // System.out.println("oldHeight: " + curHeight);
        curHeight = upHeight;
        lastX = curX;
        ++curL;
    } else {
        double lowHeight = lower[curL - 1].y + (lower[curL].y - lower[curL - 1].y) * (1.0 * (curX - lower[curL - 1].x) / (lower[curL].x - lower[curL - 1].x));
        // System.out.println("prevLowHeight: " + lowHeight);
        lowHeight = upper[curU].y - lowHeight;
        totalArea += ((1.0 * curHeight) + lowHeight) / 2 * (curX - lastX);
        // System.out.println("dist: " + (curX-lastX));
        // System.out.println("newHeight: " + lowHeight);
        // System.out.println("oldHeight: " + curHeight);
        curHeight = lowHeight;
        lastX = curX;
        ++curU;
    }
// System.out.println(totalArea);
}
// System.out.println(totalArea);
ArrayList<Point> upperPoints = new ArrayList<Point>();
for (Point p : upper) {
    upperPoints.add(p);
}
ArrayList<Point> lowerPoints = new ArrayList<Point>();
for (Point p : lower) {
    lowerPoints.add(p);
}
double prevX = 0.0;
double goal = totalArea / g;
double target = 0.0;
double ERR = 0.000001;
List<Double> answers = new LinkedList<Double>();
return u;
}


public static int func_cb760fad996c4462b70eebc290f8cc09(int u, int g, int l, Scanner in) { 
 Point[] lower = new Point[l];
for (int i = 0; i < l; ++i) {
    lower[i] = new Point(in.nextInt(), in.nextInt());
}
Point[] upper = new Point[u];
for (int i = 0; i < u; ++i) {
    upper[i] = new Point(in.nextInt(), in.nextInt());
}
double totalArea = 0.0;
int curL = 1;
int curU = 1;
int lastX = 0;
double curHeight = 1.0 * upper[0].y - lower[0].y;
while (curL < l && curU < u) {
    int lowX = lower[curL].x;
    int upX = upper[curU].x;
    int curX = Math.min(lowX, upX);
    if (curX == lowX && curX == upX) {
        double thisHeight = upper[curU].y - lower[curL].y;
        totalArea += (1.0 * curHeight + thisHeight) / 2 * (curX - lastX);
        // System.out.println("dist: " + (curX-lastX));
        // System.out.println("newHeight: " + thisHeight);
        // System.out.println("oldHeight: " + curHeight);
        curHeight = thisHeight;
        lastX = curX;
        ++curL;
        ++curU;
    } else if (curX == lowX) {
        double upHeight = upper[curU - 1].y + (upper[curU].y - upper[curU - 1].y) * (1.0 * (curX - upper[curU - 1].x) / (upper[curU].x - upper[curU - 1].x));
        upHeight -= lower[curL].y;
        totalArea += ((1.0 * curHeight) + upHeight) / 2 * (curX - lastX);
        // System.out.println("dist: " + (curX-lastX));
        // System.out.println("newHeight: " + upHeight);
        // System.out.println("oldHeight: " + curHeight);
        curHeight = upHeight;
        lastX = curX;
        ++curL;
    } else {
        double lowHeight = lower[curL - 1].y + (lower[curL].y - lower[curL - 1].y) * (1.0 * (curX - lower[curL - 1].x) / (lower[curL].x - lower[curL - 1].x));
        // System.out.println("prevLowHeight: " + lowHeight);
        lowHeight = upper[curU].y - lowHeight;
        totalArea += ((1.0 * curHeight) + lowHeight) / 2 * (curX - lastX);
        // System.out.println("dist: " + (curX-lastX));
        // System.out.println("newHeight: " + lowHeight);
        // System.out.println("oldHeight: " + curHeight);
        curHeight = lowHeight;
        lastX = curX;
        ++curU;
    }
// System.out.println(totalArea);
}
// System.out.println(totalArea);
ArrayList<Point> upperPoints = new ArrayList<Point>();
for (Point p : upper) {
    upperPoints.add(p);
}
ArrayList<Point> lowerPoints = new ArrayList<Point>();
for (Point p : lower) {
    lowerPoints.add(p);
}
double prevX = 0.0;
double goal = totalArea / g;
double target = 0.0;
double ERR = 0.000001;
List<Double> answers = new LinkedList<Double>();
return lastX;
}


public static double func_ea02d23095b14f51a0b5be80aeadec9c(int u, int g, int l, Scanner in) { 
 Point[] lower = new Point[l];
for (int i = 0; i < l; ++i) {
    lower[i] = new Point(in.nextInt(), in.nextInt());
}
Point[] upper = new Point[u];
for (int i = 0; i < u; ++i) {
    upper[i] = new Point(in.nextInt(), in.nextInt());
}
double totalArea = 0.0;
int curL = 1;
int curU = 1;
int lastX = 0;
double curHeight = 1.0 * upper[0].y - lower[0].y;
while (curL < l && curU < u) {
    int lowX = lower[curL].x;
    int upX = upper[curU].x;
    int curX = Math.min(lowX, upX);
    if (curX == lowX && curX == upX) {
        double thisHeight = upper[curU].y - lower[curL].y;
        totalArea += (1.0 * curHeight + thisHeight) / 2 * (curX - lastX);
        // System.out.println("dist: " + (curX-lastX));
        // System.out.println("newHeight: " + thisHeight);
        // System.out.println("oldHeight: " + curHeight);
        curHeight = thisHeight;
        lastX = curX;
        ++curL;
        ++curU;
    } else if (curX == lowX) {
        double upHeight = upper[curU - 1].y + (upper[curU].y - upper[curU - 1].y) * (1.0 * (curX - upper[curU - 1].x) / (upper[curU].x - upper[curU - 1].x));
        upHeight -= lower[curL].y;
        totalArea += ((1.0 * curHeight) + upHeight) / 2 * (curX - lastX);
        // System.out.println("dist: " + (curX-lastX));
        // System.out.println("newHeight: " + upHeight);
        // System.out.println("oldHeight: " + curHeight);
        curHeight = upHeight;
        lastX = curX;
        ++curL;
    } else {
        double lowHeight = lower[curL - 1].y + (lower[curL].y - lower[curL - 1].y) * (1.0 * (curX - lower[curL - 1].x) / (lower[curL].x - lower[curL - 1].x));
        // System.out.println("prevLowHeight: " + lowHeight);
        lowHeight = upper[curU].y - lowHeight;
        totalArea += ((1.0 * curHeight) + lowHeight) / 2 * (curX - lastX);
        // System.out.println("dist: " + (curX-lastX));
        // System.out.println("newHeight: " + lowHeight);
        // System.out.println("oldHeight: " + curHeight);
        curHeight = lowHeight;
        lastX = curX;
        ++curU;
    }
// System.out.println(totalArea);
}
// System.out.println(totalArea);
ArrayList<Point> upperPoints = new ArrayList<Point>();
for (Point p : upper) {
    upperPoints.add(p);
}
ArrayList<Point> lowerPoints = new ArrayList<Point>();
for (Point p : lower) {
    lowerPoints.add(p);
}
double prevX = 0.0;
double goal = totalArea / g;
double target = 0.0;
double ERR = 0.000001;
List<Double> answers = new LinkedList<Double>();
return prevX;
}


*********************************

#### Score: 0.43437


#### Java Tokens: next, cur, curl, nextint, lowheight, upper, prev, lowerpoints, totalarea, point, points, thisheight, total, min, low, array, lowx, curx, upheight, curu, height, area, add, goal, last, upperpoints, lower, arraylist, list, int, target, curheight, prevx, math, upx, lastx 

public static double func_4df7bb8bd1fc4cbe8f8b645aff6297a6(int u, int l, Scanner in) { 
 int // guests
g = in.nextInt();
Point[] lower = new Point[l];
for (int i = 0; i < l; ++i) {
    lower[i] = new Point(in.nextInt(), in.nextInt());
}
Point[] upper = new Point[u];
for (int i = 0; i < u; ++i) {
    upper[i] = new Point(in.nextInt(), in.nextInt());
}
double totalArea = 0.0;
int curL = 1;
int curU = 1;
int lastX = 0;
double curHeight = 1.0 * upper[0].y - lower[0].y;
while (curL < l && curU < u) {
    int lowX = lower[curL].x;
    int upX = upper[curU].x;
    int curX = Math.min(lowX, upX);
    if (curX == lowX && curX == upX) {
        double thisHeight = upper[curU].y - lower[curL].y;
        totalArea += (1.0 * curHeight + thisHeight) / 2 * (curX - lastX);
        // System.out.println("dist: " + (curX-lastX));
        // System.out.println("newHeight: " + thisHeight);
        // System.out.println("oldHeight: " + curHeight);
        curHeight = thisHeight;
        lastX = curX;
        ++curL;
        ++curU;
    } else if (curX == lowX) {
        double upHeight = upper[curU - 1].y + (upper[curU].y - upper[curU - 1].y) * (1.0 * (curX - upper[curU - 1].x) / (upper[curU].x - upper[curU - 1].x));
        upHeight -= lower[curL].y;
        totalArea += ((1.0 * curHeight) + upHeight) / 2 * (curX - lastX);
        // System.out.println("dist: " + (curX-lastX));
        // System.out.println("newHeight: " + upHeight);
        // System.out.println("oldHeight: " + curHeight);
        curHeight = upHeight;
        lastX = curX;
        ++curL;
    } else {
        double lowHeight = lower[curL - 1].y + (lower[curL].y - lower[curL - 1].y) * (1.0 * (curX - lower[curL - 1].x) / (lower[curL].x - lower[curL - 1].x));
        // System.out.println("prevLowHeight: " + lowHeight);
        lowHeight = upper[curU].y - lowHeight;
        totalArea += ((1.0 * curHeight) + lowHeight) / 2 * (curX - lastX);
        // System.out.println("dist: " + (curX-lastX));
        // System.out.println("newHeight: " + lowHeight);
        // System.out.println("oldHeight: " + curHeight);
        curHeight = lowHeight;
        lastX = curX;
        ++curU;
    }
// System.out.println(totalArea);
}
// System.out.println(totalArea);
ArrayList<Point> upperPoints = new ArrayList<Point>();
for (Point p : upper) {
    upperPoints.add(p);
}
ArrayList<Point> lowerPoints = new ArrayList<Point>();
for (Point p : lower) {
    lowerPoints.add(p);
}
double prevX = 0.0;
double goal = totalArea / g;
double target = 0.0;
return target;
}


public static int func_c95a2de86b624b31ae27b938dec55ef9(int l, Scanner in) { 
 // upper points
int u = in.nextInt();
int // guests
g = in.nextInt();
Point[] lower = new Point[l];
for (int i = 0; i < l; ++i) {
    lower[i] = new Point(in.nextInt(), in.nextInt());
}
Point[] upper = new Point[u];
for (int i = 0; i < u; ++i) {
    upper[i] = new Point(in.nextInt(), in.nextInt());
}
double totalArea = 0.0;
int curL = 1;
int curU = 1;
int lastX = 0;
double curHeight = 1.0 * upper[0].y - lower[0].y;
while (curL < l && curU < u) {
    int lowX = lower[curL].x;
    int upX = upper[curU].x;
    int curX = Math.min(lowX, upX);
    if (curX == lowX && curX == upX) {
        double thisHeight = upper[curU].y - lower[curL].y;
        totalArea += (1.0 * curHeight + thisHeight) / 2 * (curX - lastX);
        // System.out.println("dist: " + (curX-lastX));
        // System.out.println("newHeight: " + thisHeight);
        // System.out.println("oldHeight: " + curHeight);
        curHeight = thisHeight;
        lastX = curX;
        ++curL;
        ++curU;
    } else if (curX == lowX) {
        double upHeight = upper[curU - 1].y + (upper[curU].y - upper[curU - 1].y) * (1.0 * (curX - upper[curU - 1].x) / (upper[curU].x - upper[curU - 1].x));
        upHeight -= lower[curL].y;
        totalArea += ((1.0 * curHeight) + upHeight) / 2 * (curX - lastX);
        // System.out.println("dist: " + (curX-lastX));
        // System.out.println("newHeight: " + upHeight);
        // System.out.println("oldHeight: " + curHeight);
        curHeight = upHeight;
        lastX = curX;
        ++curL;
    } else {
        double lowHeight = lower[curL - 1].y + (lower[curL].y - lower[curL - 1].y) * (1.0 * (curX - lower[curL - 1].x) / (lower[curL].x - lower[curL - 1].x));
        // System.out.println("prevLowHeight: " + lowHeight);
        lowHeight = upper[curU].y - lowHeight;
        totalArea += ((1.0 * curHeight) + lowHeight) / 2 * (curX - lastX);
        // System.out.println("dist: " + (curX-lastX));
        // System.out.println("newHeight: " + lowHeight);
        // System.out.println("oldHeight: " + curHeight);
        curHeight = lowHeight;
        lastX = curX;
        ++curU;
    }
// System.out.println(totalArea);
}
// System.out.println(totalArea);
ArrayList<Point> upperPoints = new ArrayList<Point>();
for (Point p : upper) {
    upperPoints.add(p);
}
ArrayList<Point> lowerPoints = new ArrayList<Point>();
for (Point p : lower) {
    lowerPoints.add(p);
}
double prevX = 0.0;
double goal = totalArea / g;
double target = 0.0;
return lastX;
}


public static Point[] func_431f1b051ce94bb8adc2f1e5ae86bd77(int l, Scanner in) { 
 // upper points
int u = in.nextInt();
int // guests
g = in.nextInt();
Point[] lower = new Point[l];
for (int i = 0; i < l; ++i) {
    lower[i] = new Point(in.nextInt(), in.nextInt());
}
Point[] upper = new Point[u];
for (int i = 0; i < u; ++i) {
    upper[i] = new Point(in.nextInt(), in.nextInt());
}
double totalArea = 0.0;
int curL = 1;
int curU = 1;
int lastX = 0;
double curHeight = 1.0 * upper[0].y - lower[0].y;
while (curL < l && curU < u) {
    int lowX = lower[curL].x;
    int upX = upper[curU].x;
    int curX = Math.min(lowX, upX);
    if (curX == lowX && curX == upX) {
        double thisHeight = upper[curU].y - lower[curL].y;
        totalArea += (1.0 * curHeight + thisHeight) / 2 * (curX - lastX);
        // System.out.println("dist: " + (curX-lastX));
        // System.out.println("newHeight: " + thisHeight);
        // System.out.println("oldHeight: " + curHeight);
        curHeight = thisHeight;
        lastX = curX;
        ++curL;
        ++curU;
    } else if (curX == lowX) {
        double upHeight = upper[curU - 1].y + (upper[curU].y - upper[curU - 1].y) * (1.0 * (curX - upper[curU - 1].x) / (upper[curU].x - upper[curU - 1].x));
        upHeight -= lower[curL].y;
        totalArea += ((1.0 * curHeight) + upHeight) / 2 * (curX - lastX);
        // System.out.println("dist: " + (curX-lastX));
        // System.out.println("newHeight: " + upHeight);
        // System.out.println("oldHeight: " + curHeight);
        curHeight = upHeight;
        lastX = curX;
        ++curL;
    } else {
        double lowHeight = lower[curL - 1].y + (lower[curL].y - lower[curL - 1].y) * (1.0 * (curX - lower[curL - 1].x) / (lower[curL].x - lower[curL - 1].x));
        // System.out.println("prevLowHeight: " + lowHeight);
        lowHeight = upper[curU].y - lowHeight;
        totalArea += ((1.0 * curHeight) + lowHeight) / 2 * (curX - lastX);
        // System.out.println("dist: " + (curX-lastX));
        // System.out.println("newHeight: " + lowHeight);
        // System.out.println("oldHeight: " + curHeight);
        curHeight = lowHeight;
        lastX = curX;
        ++curU;
    }
// System.out.println(totalArea);
}
// System.out.println(totalArea);
ArrayList<Point> upperPoints = new ArrayList<Point>();
for (Point p : upper) {
    upperPoints.add(p);
}
ArrayList<Point> lowerPoints = new ArrayList<Point>();
for (Point p : lower) {
    lowerPoints.add(p);
}
double prevX = 0.0;
double goal = totalArea / g;
double target = 0.0;
return upper;
}


*********************************

#### Score: 0.43437


#### Java Tokens: min, last, known, max, lastknown, lastx 

public static double func_af08528ec2d9407d8c49c3cbf7c691a9(int lastX) { 
 double lastKnown = 0;
double min = 0;
double max = lastX;
return max;
}


public static double func_778578aa4780429e866005624993378e(int lastX) { 
 double lastKnown = 0;
double min = 0;
double max = lastX;
return lastKnown;
}


public static double func_d9ea7ed8ab5b4716ad8853ae0d8e8033(int lastX) { 
 double lastKnown = 0;
double min = 0;
double max = lastX;
return min;
}


*********************************

#### Score: 0.43437


#### Java Tokens: winc, places, max, i--, sum, must, curwin, math, win, newmust 

public static long func_68ebd12780234e3997ca64b27d1ada2f(long sum, long up, long[] a, double must, double win) { 
 sum -= must;
for (int i = A.places; i > 0; i--) {
    double newmust = 0;
    for (int j = i; j < A.places; j++) {
        if (a[j] <= up) {
            newmust++;
        }
    }
    if (newmust > sum) {
        break;
    }
    double curwin = 0;
    for (int j = 0; j < i; j++) {
        if (a[j] <= up) {
            curwin = curwin + (up - a[j]) * A.winc * 1.0 / i;
        }
    }
    win = Math.max(win, curwin - must - newmust);
}
return sum;
}


public static double func_71a749c00f70407f9a3fb9d0013ce91d(long sum, long up, long[] a, double must, double win) { 
 sum -= must;
for (int i = A.places; i > 0; i--) {
    double newmust = 0;
    for (int j = i; j < A.places; j++) {
        if (a[j] <= up) {
            newmust++;
        }
    }
    if (newmust > sum) {
        break;
    }
    double curwin = 0;
    for (int j = 0; j < i; j++) {
        if (a[j] <= up) {
            curwin = curwin + (up - a[j]) * A.winc * 1.0 / i;
        }
    }
    win = Math.max(win, curwin - must - newmust);
}
return win;
}

